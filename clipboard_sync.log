2024-11-05 13:32:58,973 - DEBUG - Listening for clipboard updates on port 5000...
2024-11-05 13:32:58,973 - DEBUG - Listening for connection requests on port 5001...
2024-11-05 13:32:59,019 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
PORT = 5000  # Port for broadcasting and listening
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_IPS = []  # List to store target IP addresses

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

def on_quit(icon, item):
    logging.debug("Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Showing main window from system tray.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and minimizing to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Error", f"Logo file '{image_path}' not found. Exiting application.")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show', show_window), item('Quit', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Error", f"Error while setting up system tray icon: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_IPS:
                            sock.sendto(message.encode('utf-8'), (ip, PORT))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return
        
        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, _ = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)
                
                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue
                
                logging.debug(f"Received clipboard content from network: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                    else:
                        logging.debug("Received content is the same as the current clipboard content. No update needed.")
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return
        
        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request message from {addr[0]}: {received_message}")
                if received_message == "REQUEST_CONNECTION":
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request", f"Accept connection request from {addr[0]}?")
                    if result:
                        TARGET_IPS.append(addr[0])
                        logging.debug(f"Accepted connection from {addr[0]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = "CONNECTION_ACCEPTED"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                    else:
                        logging.debug(f"Rejected connection from {addr[0]}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def send_connection_request(target_ip):
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = "REQUEST_CONNECTION"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind((local_ip, RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    if data.decode('utf-8') == "CONNECTION_ACCEPTED":
                        TARGET_IPS.append(target_ip)
                        logging.debug(f"Connection established with {target_ip}")
                        messagebox.showinfo("Connection Request", f"Connection established with {target_ip}")
                        is_connected.set()  # Set connection established flag
                    else:
                        logging.debug(f"Connection request to {target_ip} was not accepted.")
                except socket.timeout:
                    logging.debug(f"No response from {target_ip}. Connection request timed out.")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()

# GUI Setup
def main():
    global root
    root = tk.Tk()
    root.title("Clipboard Sync Dashboard")
    root.geometry("400x300")

    # Display the local IP address at the top of the dashboard
    ip_label = tk.Label(root, text=f"Your IP address: {local_ip}", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=10)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="Send Connection Request", command=lambda: send_connection_request(simpledialog.askstring("Send Request", "Enter IP address to send connection request:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="Waiting for incoming connection requests...")
    listening_label.pack(pady=10)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="Resume Sync")
        else:
            pause_flag.set()
            pause_button.config(text="Pause Sync")
    
    pause_button = tk.Button(root, text="Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Start threads for clipboard sync and connection handling
    start_threads()

    def on_close():
        hide_window()
        messagebox.showinfo("Clipboard Sync", "Clipboard sync will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 13:33:03,413 - DEBUG - Hiding main window and minimizing to system tray.
2024-11-05 13:33:03,458 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 13:33:03,458 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 13:33:03,458 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 13:33:03,458 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 13:33:03,463 - DEBUG - Importing BlpImagePlugin
2024-11-05 13:33:03,464 - DEBUG - Importing BmpImagePlugin
2024-11-05 13:33:03,464 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 13:33:03,465 - DEBUG - Importing CurImagePlugin
2024-11-05 13:33:03,465 - DEBUG - Importing DcxImagePlugin
2024-11-05 13:33:03,466 - DEBUG - Importing DdsImagePlugin
2024-11-05 13:33:03,468 - DEBUG - Importing EpsImagePlugin
2024-11-05 13:33:03,468 - DEBUG - Importing FitsImagePlugin
2024-11-05 13:33:03,469 - DEBUG - Importing FliImagePlugin
2024-11-05 13:33:03,469 - DEBUG - Importing FpxImagePlugin
2024-11-05 13:33:03,470 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 13:33:03,470 - DEBUG - Importing FtexImagePlugin
2024-11-05 13:33:03,471 - DEBUG - Importing GbrImagePlugin
2024-11-05 13:33:03,471 - DEBUG - Importing GifImagePlugin
2024-11-05 13:33:03,471 - DEBUG - Importing GribStubImagePlugin
2024-11-05 13:33:03,471 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 13:33:03,472 - DEBUG - Importing IcnsImagePlugin
2024-11-05 13:33:03,473 - DEBUG - Importing IcoImagePlugin
2024-11-05 13:33:03,474 - DEBUG - Importing ImImagePlugin
2024-11-05 13:33:03,474 - DEBUG - Importing ImtImagePlugin
2024-11-05 13:33:03,475 - DEBUG - Importing IptcImagePlugin
2024-11-05 13:33:03,475 - DEBUG - Importing JpegImagePlugin
2024-11-05 13:33:03,475 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 13:33:03,475 - DEBUG - Importing McIdasImagePlugin
2024-11-05 13:33:03,476 - DEBUG - Importing MicImagePlugin
2024-11-05 13:33:03,476 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 13:33:03,476 - DEBUG - Importing MpegImagePlugin
2024-11-05 13:33:03,477 - DEBUG - Importing MpoImagePlugin
2024-11-05 13:33:03,481 - DEBUG - Importing MspImagePlugin
2024-11-05 13:33:03,481 - DEBUG - Importing PalmImagePlugin
2024-11-05 13:33:03,482 - DEBUG - Importing PcdImagePlugin
2024-11-05 13:33:03,482 - DEBUG - Importing PcxImagePlugin
2024-11-05 13:33:03,482 - DEBUG - Importing PdfImagePlugin
2024-11-05 13:33:03,485 - DEBUG - Importing PixarImagePlugin
2024-11-05 13:33:03,486 - DEBUG - Importing PngImagePlugin
2024-11-05 13:33:03,486 - DEBUG - Importing PpmImagePlugin
2024-11-05 13:33:03,486 - DEBUG - Importing PsdImagePlugin
2024-11-05 13:33:03,486 - DEBUG - Importing QoiImagePlugin
2024-11-05 13:33:03,486 - DEBUG - Importing SgiImagePlugin
2024-11-05 13:33:03,487 - DEBUG - Importing SpiderImagePlugin
2024-11-05 13:33:03,487 - DEBUG - Importing SunImagePlugin
2024-11-05 13:33:03,487 - DEBUG - Importing TgaImagePlugin
2024-11-05 13:33:03,488 - DEBUG - Importing TiffImagePlugin
2024-11-05 13:33:03,488 - DEBUG - Importing WebPImagePlugin
2024-11-05 13:33:03,502 - DEBUG - Importing WmfImagePlugin
2024-11-05 13:33:03,503 - DEBUG - Importing XbmImagePlugin
2024-11-05 13:33:03,504 - DEBUG - Importing XpmImagePlugin
2024-11-05 13:33:03,504 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 13:34:50,548 - DEBUG - Listening for clipboard updates on port 5000...
2024-11-05 13:34:50,548 - DEBUG - Listening for connection requests on port 5001...
2024-11-05 13:35:00,014 - DEBUG - Sent connection request to 192.168.1.26
2024-11-05 13:35:01,441 - DEBUG - Connection established with 192.168.1.26
2024-11-05 13:35:05,907 - DEBUG - Hiding main window and minimizing to system tray.
2024-11-05 13:35:05,931 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 13:35:05,931 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 13:35:05,931 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 13:35:05,931 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 13:35:05,936 - DEBUG - Importing BlpImagePlugin
2024-11-05 13:35:05,937 - DEBUG - Importing BmpImagePlugin
2024-11-05 13:35:05,937 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 13:35:05,938 - DEBUG - Importing CurImagePlugin
2024-11-05 13:35:05,938 - DEBUG - Importing DcxImagePlugin
2024-11-05 13:35:05,939 - DEBUG - Importing DdsImagePlugin
2024-11-05 13:35:05,941 - DEBUG - Importing EpsImagePlugin
2024-11-05 13:35:05,941 - DEBUG - Importing FitsImagePlugin
2024-11-05 13:35:05,943 - DEBUG - Importing FliImagePlugin
2024-11-05 13:35:05,943 - DEBUG - Importing FpxImagePlugin
2024-11-05 13:35:05,944 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 13:35:05,944 - DEBUG - Importing FtexImagePlugin
2024-11-05 13:35:05,944 - DEBUG - Importing GbrImagePlugin
2024-11-05 13:35:05,945 - DEBUG - Importing GifImagePlugin
2024-11-05 13:35:05,945 - DEBUG - Importing GribStubImagePlugin
2024-11-05 13:35:05,945 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 13:35:05,946 - DEBUG - Importing IcnsImagePlugin
2024-11-05 13:35:05,947 - DEBUG - Importing IcoImagePlugin
2024-11-05 13:35:05,948 - DEBUG - Importing ImImagePlugin
2024-11-05 13:35:05,948 - DEBUG - Importing ImtImagePlugin
2024-11-05 13:35:05,949 - DEBUG - Importing IptcImagePlugin
2024-11-05 13:35:05,949 - DEBUG - Importing JpegImagePlugin
2024-11-05 13:35:05,949 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 13:35:05,949 - DEBUG - Importing McIdasImagePlugin
2024-11-05 13:35:05,949 - DEBUG - Importing MicImagePlugin
2024-11-05 13:35:05,950 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 13:35:05,950 - DEBUG - Importing MpegImagePlugin
2024-11-05 13:35:05,950 - DEBUG - Importing MpoImagePlugin
2024-11-05 13:35:05,954 - DEBUG - Importing MspImagePlugin
2024-11-05 13:35:05,954 - DEBUG - Importing PalmImagePlugin
2024-11-05 13:35:05,954 - DEBUG - Importing PcdImagePlugin
2024-11-05 13:35:05,955 - DEBUG - Importing PcxImagePlugin
2024-11-05 13:35:05,955 - DEBUG - Importing PdfImagePlugin
2024-11-05 13:35:05,959 - DEBUG - Importing PixarImagePlugin
2024-11-05 13:35:05,959 - DEBUG - Importing PngImagePlugin
2024-11-05 13:35:05,959 - DEBUG - Importing PpmImagePlugin
2024-11-05 13:35:05,959 - DEBUG - Importing PsdImagePlugin
2024-11-05 13:35:05,960 - DEBUG - Importing QoiImagePlugin
2024-11-05 13:35:05,960 - DEBUG - Importing SgiImagePlugin
2024-11-05 13:35:05,960 - DEBUG - Importing SpiderImagePlugin
2024-11-05 13:35:05,961 - DEBUG - Importing SunImagePlugin
2024-11-05 13:35:05,961 - DEBUG - Importing TgaImagePlugin
2024-11-05 13:35:05,961 - DEBUG - Importing TiffImagePlugin
2024-11-05 13:35:05,961 - DEBUG - Importing WebPImagePlugin
2024-11-05 13:35:05,962 - DEBUG - Importing WmfImagePlugin
2024-11-05 13:35:05,963 - DEBUG - Importing XbmImagePlugin
2024-11-05 13:35:05,963 - DEBUG - Importing XpmImagePlugin
2024-11-05 13:35:05,963 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 13:35:12,803 - DEBUG - Showing main window from system tray.
2024-11-05 13:35:14,327 - DEBUG - Hiding main window and minimizing to system tray.
2024-11-05 13:35:14,346 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 13:35:14,346 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 13:35:14,346 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 13:35:14,346 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 13:35:21,427 - DEBUG - Broadcasting clipboard content:     main()

2024-11-05 13:35:42,916 - DEBUG - Quitting application.
2024-11-05 13:35:42,917 - ERROR - An error occurred when calling message handler
Traceback (most recent call last):
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_win32.py", line 412, in _dispatcher
    return int(icon._message_handlers.get(
               ~~~~~~~~~~~~~~~~~~~~~~~~~~~
        uMsg, lambda w, l: 0)(wParam, lParam) or 0)
        ~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_win32.py", line 224, in _on_notify
    descriptors[index - 1](self)
    ~~~~~~~~~~~~~~~~~~~~~~^^^^^^
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_base.py", line 328, in inner
    callback(self)
    ~~~~~~~~^^^^^^
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_base.py", line 453, in __call__
    return self._action(icon, self)
           ~~~~~~~~~~~~^^^^^^^^^^^^
  File "C:\Users\Dell\Music\clipboard\main.py", line 54, in on_quit
    sys.exit()
    ~~~~~~~~^^
SystemExit
2024-11-05 13:35:44,267 - DEBUG - Quitting application.
2024-11-05 13:35:44,267 - ERROR - An error occurred when calling message handler
Traceback (most recent call last):
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_win32.py", line 412, in _dispatcher
    return int(icon._message_handlers.get(
               ~~~~~~~~~~~~~~~~~~~~~~~~~~~
        uMsg, lambda w, l: 0)(wParam, lParam) or 0)
        ~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_win32.py", line 224, in _on_notify
    descriptors[index - 1](self)
    ~~~~~~~~~~~~~~~~~~~~~~^^^^^^
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_base.py", line 328, in inner
    callback(self)
    ~~~~~~~~^^^^^^
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_base.py", line 453, in __call__
    return self._action(icon, self)
           ~~~~~~~~~~~~^^^^^^^^^^^^
  File "C:\Users\Dell\Music\clipboard\main.py", line 54, in on_quit
    sys.exit()
    ~~~~~~~~^^
SystemExit
2024-11-05 14:15:50,228 - DEBUG - Listening for connection requests on port 5001...
2024-11-05 14:15:50,228 - DEBUG - Listening for clipboard updates on port 5000...
2024-11-05 14:15:50,278 - DEBUG - Broadcasting clipboard content: Mohit
2024-11-05 14:15:53,868 - DEBUG - Hiding main window and minimizing to system tray.
2024-11-05 14:15:53,895 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:15:53,895 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:15:53,895 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:15:53,895 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:15:53,900 - DEBUG - Importing BlpImagePlugin
2024-11-05 14:15:53,901 - DEBUG - Importing BmpImagePlugin
2024-11-05 14:15:53,901 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 14:15:53,901 - DEBUG - Importing CurImagePlugin
2024-11-05 14:15:53,902 - DEBUG - Importing DcxImagePlugin
2024-11-05 14:15:53,902 - DEBUG - Importing DdsImagePlugin
2024-11-05 14:15:53,904 - DEBUG - Importing EpsImagePlugin
2024-11-05 14:15:53,905 - DEBUG - Importing FitsImagePlugin
2024-11-05 14:15:53,906 - DEBUG - Importing FliImagePlugin
2024-11-05 14:15:53,906 - DEBUG - Importing FpxImagePlugin
2024-11-05 14:15:53,907 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 14:15:53,907 - DEBUG - Importing FtexImagePlugin
2024-11-05 14:15:53,907 - DEBUG - Importing GbrImagePlugin
2024-11-05 14:15:53,907 - DEBUG - Importing GifImagePlugin
2024-11-05 14:15:53,908 - DEBUG - Importing GribStubImagePlugin
2024-11-05 14:15:53,908 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 14:15:53,908 - DEBUG - Importing IcnsImagePlugin
2024-11-05 14:15:53,910 - DEBUG - Importing IcoImagePlugin
2024-11-05 14:15:53,910 - DEBUG - Importing ImImagePlugin
2024-11-05 14:15:53,911 - DEBUG - Importing ImtImagePlugin
2024-11-05 14:15:53,912 - DEBUG - Importing IptcImagePlugin
2024-11-05 14:15:53,912 - DEBUG - Importing JpegImagePlugin
2024-11-05 14:15:53,912 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 14:15:53,912 - DEBUG - Importing McIdasImagePlugin
2024-11-05 14:15:53,912 - DEBUG - Importing MicImagePlugin
2024-11-05 14:15:53,913 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 14:15:53,913 - DEBUG - Importing MpegImagePlugin
2024-11-05 14:15:53,913 - DEBUG - Importing MpoImagePlugin
2024-11-05 14:15:53,917 - DEBUG - Importing MspImagePlugin
2024-11-05 14:15:53,918 - DEBUG - Importing PalmImagePlugin
2024-11-05 14:15:53,918 - DEBUG - Importing PcdImagePlugin
2024-11-05 14:15:53,919 - DEBUG - Importing PcxImagePlugin
2024-11-05 14:15:53,919 - DEBUG - Importing PdfImagePlugin
2024-11-05 14:15:53,922 - DEBUG - Importing PixarImagePlugin
2024-11-05 14:15:53,922 - DEBUG - Importing PngImagePlugin
2024-11-05 14:15:53,922 - DEBUG - Importing PpmImagePlugin
2024-11-05 14:15:53,922 - DEBUG - Importing PsdImagePlugin
2024-11-05 14:15:53,923 - DEBUG - Importing QoiImagePlugin
2024-11-05 14:15:53,923 - DEBUG - Importing SgiImagePlugin
2024-11-05 14:15:53,923 - DEBUG - Importing SpiderImagePlugin
2024-11-05 14:15:53,924 - DEBUG - Importing SunImagePlugin
2024-11-05 14:15:53,924 - DEBUG - Importing TgaImagePlugin
2024-11-05 14:15:53,924 - DEBUG - Importing TiffImagePlugin
2024-11-05 14:15:53,924 - DEBUG - Importing WebPImagePlugin
2024-11-05 14:15:53,925 - DEBUG - Importing WmfImagePlugin
2024-11-05 14:15:53,925 - DEBUG - Importing XbmImagePlugin
2024-11-05 14:15:53,926 - DEBUG - Importing XpmImagePlugin
2024-11-05 14:15:53,926 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 14:24:56,184 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:24:56,184 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:24:56,184 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:24:56,184 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:26:29,408 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:26:29,408 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:26:29,408 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:26:29,408 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:26:29,420 - DEBUG - Listening for connection requests on port 5001...
2024-11-05 14:26:29,421 - DEBUG - Listening for clipboard updates on port 5000...
2024-11-05 14:26:29,467 - DEBUG - Broadcasting clipboard content: Image.LANCZOS
2024-11-05 14:26:45,106 - DEBUG - Hiding main window and minimizing to system tray.
2024-11-05 14:26:45,123 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:26:45,124 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:26:45,124 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:26:45,124 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:26:45,131 - DEBUG - Importing BlpImagePlugin
2024-11-05 14:26:45,133 - DEBUG - Importing BmpImagePlugin
2024-11-05 14:26:45,133 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 14:26:45,133 - DEBUG - Importing CurImagePlugin
2024-11-05 14:26:45,134 - DEBUG - Importing DcxImagePlugin
2024-11-05 14:26:45,136 - DEBUG - Importing DdsImagePlugin
2024-11-05 14:26:45,137 - DEBUG - Importing EpsImagePlugin
2024-11-05 14:26:45,138 - DEBUG - Importing FitsImagePlugin
2024-11-05 14:26:45,139 - DEBUG - Importing FliImagePlugin
2024-11-05 14:26:45,139 - DEBUG - Importing FpxImagePlugin
2024-11-05 14:26:45,140 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 14:26:45,140 - DEBUG - Importing FtexImagePlugin
2024-11-05 14:26:45,141 - DEBUG - Importing GbrImagePlugin
2024-11-05 14:26:45,141 - DEBUG - Importing GifImagePlugin
2024-11-05 14:26:45,141 - DEBUG - Importing GribStubImagePlugin
2024-11-05 14:26:45,141 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 14:26:45,142 - DEBUG - Importing IcnsImagePlugin
2024-11-05 14:26:45,143 - DEBUG - Importing IcoImagePlugin
2024-11-05 14:26:45,144 - DEBUG - Importing ImImagePlugin
2024-11-05 14:26:45,144 - DEBUG - Importing ImtImagePlugin
2024-11-05 14:26:45,145 - DEBUG - Importing IptcImagePlugin
2024-11-05 14:26:45,145 - DEBUG - Importing JpegImagePlugin
2024-11-05 14:26:45,145 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 14:26:45,145 - DEBUG - Importing McIdasImagePlugin
2024-11-05 14:26:45,146 - DEBUG - Importing MicImagePlugin
2024-11-05 14:26:45,146 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 14:26:45,146 - DEBUG - Importing MpegImagePlugin
2024-11-05 14:26:45,147 - DEBUG - Importing MpoImagePlugin
2024-11-05 14:26:45,151 - DEBUG - Importing MspImagePlugin
2024-11-05 14:26:45,152 - DEBUG - Importing PalmImagePlugin
2024-11-05 14:26:45,152 - DEBUG - Importing PcdImagePlugin
2024-11-05 14:26:45,153 - DEBUG - Importing PcxImagePlugin
2024-11-05 14:26:45,153 - DEBUG - Importing PdfImagePlugin
2024-11-05 14:26:45,157 - DEBUG - Importing PixarImagePlugin
2024-11-05 14:26:45,157 - DEBUG - Importing PngImagePlugin
2024-11-05 14:26:45,157 - DEBUG - Importing PpmImagePlugin
2024-11-05 14:26:45,157 - DEBUG - Importing PsdImagePlugin
2024-11-05 14:26:45,158 - DEBUG - Importing QoiImagePlugin
2024-11-05 14:26:45,158 - DEBUG - Importing SgiImagePlugin
2024-11-05 14:26:45,158 - DEBUG - Importing SpiderImagePlugin
2024-11-05 14:26:45,159 - DEBUG - Importing SunImagePlugin
2024-11-05 14:26:45,159 - DEBUG - Importing TgaImagePlugin
2024-11-05 14:26:45,159 - DEBUG - Importing TiffImagePlugin
2024-11-05 14:26:45,159 - DEBUG - Importing WebPImagePlugin
2024-11-05 14:26:45,160 - DEBUG - Importing WmfImagePlugin
2024-11-05 14:26:45,160 - DEBUG - Importing XbmImagePlugin
2024-11-05 14:26:45,161 - DEBUG - Importing XpmImagePlugin
2024-11-05 14:26:45,161 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 14:26:49,101 - DEBUG - Quitting application.
2024-11-05 14:26:49,101 - ERROR - An error occurred when calling message handler
Traceback (most recent call last):
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_win32.py", line 412, in _dispatcher
    return int(icon._message_handlers.get(
               ~~~~~~~~~~~~~~~~~~~~~~~~~~~
        uMsg, lambda w, l: 0)(wParam, lParam) or 0)
        ~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_win32.py", line 224, in _on_notify
    descriptors[index - 1](self)
    ~~~~~~~~~~~~~~~~~~~~~~^^^^^^
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_base.py", line 328, in inner
    callback(self)
    ~~~~~~~~^^^^^^
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_base.py", line 453, in __call__
    return self._action(icon, self)
           ~~~~~~~~~~~~^^^^^^^^^^^^
  File "C:\Users\Dell\Music\clipboard\main.py", line 54, in on_quit
    sys.exit()
    ~~~~~~~~^^
SystemExit
2024-11-05 14:37:08,548 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:37:08,548 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:37:08,548 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:37:08,549 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:37:08,576 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:37:08,577 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:37:08,577 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:37:08,577 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:37:36,541 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:37:36,542 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:37:36,542 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:37:36,542 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:37:36,569 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:37:36,569 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:37:36,569 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:37:36,569 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:37:36,577 - DEBUG - Listening for clipboard updates on port 5000...
2024-11-05 14:37:36,578 - DEBUG - Listening for connection requests on port 5001...
2024-11-05 14:37:36,618 - DEBUG - Broadcasting clipboard content: Image.LANCZOS
2024-11-05 14:37:40,941 - DEBUG - Hiding main window and minimizing to system tray.
2024-11-05 14:37:40,958 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:37:40,958 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:37:40,958 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:37:40,958 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:37:40,968 - DEBUG - Importing BlpImagePlugin
2024-11-05 14:37:40,969 - DEBUG - Importing BmpImagePlugin
2024-11-05 14:37:40,969 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 14:37:40,970 - DEBUG - Importing CurImagePlugin
2024-11-05 14:37:40,970 - DEBUG - Importing DcxImagePlugin
2024-11-05 14:37:40,972 - DEBUG - Importing DdsImagePlugin
2024-11-05 14:37:40,974 - DEBUG - Importing EpsImagePlugin
2024-11-05 14:37:40,975 - DEBUG - Importing FitsImagePlugin
2024-11-05 14:37:40,976 - DEBUG - Importing FliImagePlugin
2024-11-05 14:37:40,977 - DEBUG - Importing FpxImagePlugin
2024-11-05 14:37:40,977 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 14:37:40,977 - DEBUG - Importing FtexImagePlugin
2024-11-05 14:37:40,978 - DEBUG - Importing GbrImagePlugin
2024-11-05 14:37:40,978 - DEBUG - Importing GifImagePlugin
2024-11-05 14:37:40,978 - DEBUG - Importing GribStubImagePlugin
2024-11-05 14:37:40,979 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 14:37:40,980 - DEBUG - Importing IcnsImagePlugin
2024-11-05 14:37:40,982 - DEBUG - Importing IcoImagePlugin
2024-11-05 14:37:40,983 - DEBUG - Importing ImImagePlugin
2024-11-05 14:37:40,983 - DEBUG - Importing ImtImagePlugin
2024-11-05 14:37:40,984 - DEBUG - Importing IptcImagePlugin
2024-11-05 14:37:40,984 - DEBUG - Importing JpegImagePlugin
2024-11-05 14:37:40,984 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 14:37:40,984 - DEBUG - Importing McIdasImagePlugin
2024-11-05 14:37:40,985 - DEBUG - Importing MicImagePlugin
2024-11-05 14:37:40,985 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 14:37:40,985 - DEBUG - Importing MpegImagePlugin
2024-11-05 14:37:40,986 - DEBUG - Importing MpoImagePlugin
2024-11-05 14:37:40,990 - DEBUG - Importing MspImagePlugin
2024-11-05 14:37:40,990 - DEBUG - Importing PalmImagePlugin
2024-11-05 14:37:40,991 - DEBUG - Importing PcdImagePlugin
2024-11-05 14:37:40,991 - DEBUG - Importing PcxImagePlugin
2024-11-05 14:37:40,991 - DEBUG - Importing PdfImagePlugin
2024-11-05 14:37:40,995 - DEBUG - Importing PixarImagePlugin
2024-11-05 14:37:40,995 - DEBUG - Importing PngImagePlugin
2024-11-05 14:37:40,995 - DEBUG - Importing PpmImagePlugin
2024-11-05 14:37:40,995 - DEBUG - Importing PsdImagePlugin
2024-11-05 14:37:40,995 - DEBUG - Importing QoiImagePlugin
2024-11-05 14:37:40,996 - DEBUG - Importing SgiImagePlugin
2024-11-05 14:37:40,996 - DEBUG - Importing SpiderImagePlugin
2024-11-05 14:37:40,997 - DEBUG - Importing SunImagePlugin
2024-11-05 14:37:40,997 - DEBUG - Importing TgaImagePlugin
2024-11-05 14:37:40,997 - DEBUG - Importing TiffImagePlugin
2024-11-05 14:37:40,998 - DEBUG - Importing WebPImagePlugin
2024-11-05 14:37:40,998 - DEBUG - Importing WmfImagePlugin
2024-11-05 14:37:40,999 - DEBUG - Importing XbmImagePlugin
2024-11-05 14:37:40,999 - DEBUG - Importing XpmImagePlugin
2024-11-05 14:37:41,000 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 14:37:44,957 - DEBUG - Quitting application.
2024-11-05 14:37:44,958 - ERROR - An error occurred when calling message handler
Traceback (most recent call last):
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_win32.py", line 412, in _dispatcher
    return int(icon._message_handlers.get(
               ~~~~~~~~~~~~~~~~~~~~~~~~~~~
        uMsg, lambda w, l: 0)(wParam, lParam) or 0)
        ~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_win32.py", line 224, in _on_notify
    descriptors[index - 1](self)
    ~~~~~~~~~~~~~~~~~~~~~~^^^^^^
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_base.py", line 328, in inner
    callback(self)
    ~~~~~~~~^^^^^^
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_base.py", line 453, in __call__
    return self._action(icon, self)
           ~~~~~~~~~~~~^^^^^^^^^^^^
  File "C:\Users\Dell\Music\clipboard\main.py", line 54, in on_quit
    sys.exit()
    ~~~~~~~~^^
SystemExit
2024-11-05 14:43:54,869 - DEBUG - Broadcasting clipboard content: 1. set a opction to create a Unique username and also allow to send request to usernames insted 

(also check if the none has set the same username before )

2. Cant send request to yourself (send a alert pop saying "BRUHHH you are sending request to yourself"

3. Change every text to something funny but it shows the actually meaning 

4. Show a Log below in the window Which will show Username or Ip address using different color for every different user (use Username in priority)
2024-11-05 14:44:02,143 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
PORT = 5000  # Port for broadcasting and listening
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_IPS = []  # List to store target IP addresses

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

def on_quit(icon, item):
    logging.debug("Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Showing main window from system tray.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and minimizing to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Error", f"Logo file '{image_path}' not found. Exiting application.")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show', show_window), item('Quit', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Error", f"Error while setting up system tray icon: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_IPS:
                            sock.sendto(message.encode('utf-8'), (ip, PORT))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return
        
        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, _ = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)
                
                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue
                
                logging.debug(f"Received clipboard content from network: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                    else:
                        logging.debug("Received content is the same as the current clipboard content. No update needed.")
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return
        
        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request message from {addr[0]}: {received_message}")
                if received_message == "REQUEST_CONNECTION":
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request", f"Accept connection request from {addr[0]}?")
                    if result:
                        TARGET_IPS.append(addr[0])
                        logging.debug(f"Accepted connection from {addr[0]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = "CONNECTION_ACCEPTED"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                    else:
                        logging.debug(f"Rejected connection from {addr[0]}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def send_connection_request(target_ip):
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = "REQUEST_CONNECTION"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind((local_ip, RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    if data.decode('utf-8') == "CONNECTION_ACCEPTED":
                        TARGET_IPS.append(target_ip)
                        logging.debug(f"Connection established with {target_ip}")
                        messagebox.showinfo("Connection Request", f"Connection established with {target_ip}")
                        is_connected.set()  # Set connection established flag
                    else:
                        logging.debug(f"Connection request to {target_ip} was not accepted.")
                except socket.timeout:
                    logging.debug(f"No response from {target_ip}. Connection request timed out.")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()

# GUI Setup
def main():
    global root
    root = tk.Tk()
    
    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)
    

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Display the local IP address at the top of the dashboard
    ip_label = tk.Label(root, text=f"Your IP address: {local_ip}", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=10)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="Send Connection Request", command=lambda: send_connection_request(simpledialog.askstring("Send Request", "Enter IP address to send connection request:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="Waiting for incoming connection requests...")
    listening_label.pack(pady=10)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="Resume Sync")
        else:
            pause_flag.set()
            pause_button.config(text="Pause Sync")
    
    pause_button = tk.Button(root, text="Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Start threads for clipboard sync and connection handling
    start_threads()

    def on_close():
        hide_window()
        messagebox.showinfo("Clipboard Sync", "Clipboard sync will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:44:33,656 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox, scrolledtext
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
PORT = 5000  # Port for broadcasting and listening clipboard content
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_PORT = 5003  # Port for broadcasting usernames
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target usernames and their IPs

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def on_quit(icon, item):
    logging.debug("Buh-bye! Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Popping the main window back from the shadows.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and teleporting to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Oopsie!", f"Logo file '{image_path}' is missing. Exiting...")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show Me!', show_window), item('Hasta La Vista', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Yikes!", f"System tray setup failed: {e}")

def broadcast_username():
    """Broadcast the username to the network to ensure uniqueness."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        message = f"USERNAME:{username}:{local_ip}"
        sock.sendto(message.encode('utf-8'), ('<broadcast>', USERNAME_PORT))
        logging.debug(f"Broadcasted username '{username}' to the network.")
        # Listen for a short period to check for duplicates
        sock.settimeout(2)
        try:
            while True:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip = received_message.split(':', 2)
                    if received_username == username and received_ip != local_ip:
                        logging.warning(f"Username '{username}' is already taken by {received_ip}.")
                        messagebox.showerror("Username Jam!", f"'{username}' is already taken. Pick another one!")
                        return False
        except socket.timeout:
            pass  # No duplicates found
    return True

def listen_for_usernames():
    """Listen for username broadcasts to maintain the TARGET_USERS dictionary."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('', USERNAME_PORT))
        logging.debug(f"Listening for username broadcasts on port {USERNAME_PORT}...")
        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip = received_message.split(':', 2)
                    if received_ip == local_ip:
                        continue  # Ignore own broadcasts
                    if received_username not in TARGET_USERS:
                        TARGET_USERS[received_username] = received_ip
                        logging.debug(f"Discovered user '{received_username}' at {received_ip}.")
            except Exception as e:
                logging.error(f"Error receiving username broadcasts: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard magic: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for user, ip in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, PORT))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard sorcery: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard whispers on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard snippet from {addr[0]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Injecting received clipboard magic into local clipboard...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated with: {received_text}")
                        # Log the activity
                        log_activity(addr[0], received_text)
                    else:
                        logging.debug("Received clipboard is dj vu. No update needed.")
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard snippets: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection giggles on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection giggle from {addr[0]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, target_username = received_message.split(':', 1)
                    # Prevent accepting connection from self
                    if target_username == username:
                        logging.warning(f"Received connection request from self at {addr[0]}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Ping", f"Do you wanna vibe with '{target_username}' from {addr[0]}?")
                    if result:
                        TARGET_USERS[target_username] = addr[0]
                        logging.debug(f"Accepted connection from '{target_username}' at {addr[0]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = f"CONNECTION_ACCEPTED:{username}"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                        # Assign color for the new user
                        if target_username not in user_colors:
                            user_colors[target_username] = get_next_color()
                    else:
                        logging.debug(f"Declined connection from '{target_username}' at {addr[0]}")
            except Exception as e:
                logging.error(f"Error handling connection giggle: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection acceptance on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    _, responder_username = received_message.split(':', 1)
                    TARGET_USERS[responder_username] = addr[0]
                    logging.debug(f"Connection confirmed with '{responder_username}' at {addr[0]}")
                    messagebox.showinfo("Connection Made", f"You're now in cahoots with '{responder_username}'!")
                    is_connected.set()
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_username):
    if target_username == username:
        messagebox.showwarning("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    if target_username not in TARGET_USERS:
        messagebox.showerror("Whoops!", f"No one named '{target_username}' found in the vicinity.")
        logging.error(f"Attempted to connect to unknown username '{target_username}'.")
        return
    target_ip = TARGET_USERS[target_username]
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"REQUEST_CONNECTION:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection giggle to '{target_username}' at {target_ip}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind((local_ip, RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    response_message = data.decode('utf-8')
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        _, responder_username = response_message.split(':', 1)
                        TARGET_USERS[responder_username] = target_ip
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}")
                        messagebox.showinfo("Connection Success", f"Now sharing vibes with '{responder_username}'!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                except socket.timeout:
                    logging.debug(f"No response from '{target_username}' at {target_ip}. Connection timed out.")
                    messagebox.showerror("No Response", f"'{target_username}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection giggle: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to listen for username broadcasts
    threading.Thread(target=listen_for_usernames, daemon=True).start()

def main():
    global root, username
    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("600x500")
    
    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Prompt user to enter a unique username
    while True:
        username = simpledialog.askstring("Set Your Moniker", "Choose a funky username:")
        if not username:
            messagebox.showerror("No Name, No Game", "You gotta have a username to play!")
            continue
        if broadcast_username():
            break  # Unique username set successfully

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text=f"Your cool alias: {username}", font=("Helvetica", 12, "bold"))
    user_label.pack(pady=5)
    
    ip_label = tk.Label(root, text=f"Your secret lair IP: {local_ip}", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="Invite a Buddy", command=lambda: send_connection_request(simpledialog.askstring("Send Invite", "Enter username to invite:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="Chilling and waiting for buddies to join...", font=("Helvetica", 10, "italic"))
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root)
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"))
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10)
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color)
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Start threads for clipboard sync and connection handling
    start_threads()

    def on_close():
        hide_window()
        messagebox.showinfo("ClipHilarity Sync", "Clipboard antics will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:44:46,201 - DEBUG - Broadcasting clipboard content: 

2024-11-05 14:44:50,973 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:44:50,973 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:44:50,973 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:44:50,973 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:44:51,002 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:44:51,002 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:44:51,002 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:44:51,002 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:45:04,072 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:45:04,072 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:45:04,072 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:45:04,073 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:45:04,100 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:45:04,100 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:45:04,100 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:45:04,101 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:45:18,595 - DEBUG - Broadcasted username 'asd' to the network.
2024-11-05 14:45:20,965 - DEBUG - Listening for clipboard whispers on port 5000...
2024-11-05 14:45:20,965 - DEBUG - Listening for connection giggles on port 5001...
2024-11-05 14:45:20,965 - DEBUG - Listening for username broadcasts on port 5003...
2024-11-05 14:45:20,965 - DEBUG - Listening for connection acceptance on port 5002...
2024-11-05 14:45:21,010 - DEBUG - Broadcasting clipboard magic: Image.ANTIALIAS
2024-11-05 14:45:29,472 - DEBUG - Hiding main window and teleporting to system tray.
2024-11-05 14:45:29,493 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:45:29,493 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:45:29,493 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:45:29,494 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:45:29,502 - DEBUG - Importing BlpImagePlugin
2024-11-05 14:45:29,503 - DEBUG - Importing BmpImagePlugin
2024-11-05 14:45:29,503 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 14:45:29,504 - DEBUG - Importing CurImagePlugin
2024-11-05 14:45:29,504 - DEBUG - Importing DcxImagePlugin
2024-11-05 14:45:29,505 - DEBUG - Importing DdsImagePlugin
2024-11-05 14:45:29,507 - DEBUG - Importing EpsImagePlugin
2024-11-05 14:45:29,508 - DEBUG - Importing FitsImagePlugin
2024-11-05 14:45:29,509 - DEBUG - Importing FliImagePlugin
2024-11-05 14:45:29,509 - DEBUG - Importing FpxImagePlugin
2024-11-05 14:45:29,510 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 14:45:29,510 - DEBUG - Importing FtexImagePlugin
2024-11-05 14:45:29,510 - DEBUG - Importing GbrImagePlugin
2024-11-05 14:45:29,511 - DEBUG - Importing GifImagePlugin
2024-11-05 14:45:29,511 - DEBUG - Importing GribStubImagePlugin
2024-11-05 14:45:29,511 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 14:45:29,511 - DEBUG - Importing IcnsImagePlugin
2024-11-05 14:45:29,513 - DEBUG - Importing IcoImagePlugin
2024-11-05 14:45:29,514 - DEBUG - Importing ImImagePlugin
2024-11-05 14:45:29,514 - DEBUG - Importing ImtImagePlugin
2024-11-05 14:45:29,515 - DEBUG - Importing IptcImagePlugin
2024-11-05 14:45:29,515 - DEBUG - Importing JpegImagePlugin
2024-11-05 14:45:29,515 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 14:45:29,515 - DEBUG - Importing McIdasImagePlugin
2024-11-05 14:45:29,516 - DEBUG - Importing MicImagePlugin
2024-11-05 14:45:29,516 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 14:45:29,516 - DEBUG - Importing MpegImagePlugin
2024-11-05 14:45:29,517 - DEBUG - Importing MpoImagePlugin
2024-11-05 14:45:29,521 - DEBUG - Importing MspImagePlugin
2024-11-05 14:45:29,522 - DEBUG - Importing PalmImagePlugin
2024-11-05 14:45:29,522 - DEBUG - Importing PcdImagePlugin
2024-11-05 14:45:29,523 - DEBUG - Importing PcxImagePlugin
2024-11-05 14:45:29,523 - DEBUG - Importing PdfImagePlugin
2024-11-05 14:45:29,526 - DEBUG - Importing PixarImagePlugin
2024-11-05 14:45:29,527 - DEBUG - Importing PngImagePlugin
2024-11-05 14:45:29,527 - DEBUG - Importing PpmImagePlugin
2024-11-05 14:45:29,527 - DEBUG - Importing PsdImagePlugin
2024-11-05 14:45:29,527 - DEBUG - Importing QoiImagePlugin
2024-11-05 14:45:29,527 - DEBUG - Importing SgiImagePlugin
2024-11-05 14:45:29,528 - DEBUG - Importing SpiderImagePlugin
2024-11-05 14:45:29,528 - DEBUG - Importing SunImagePlugin
2024-11-05 14:45:29,528 - DEBUG - Importing TgaImagePlugin
2024-11-05 14:45:29,528 - DEBUG - Importing TiffImagePlugin
2024-11-05 14:45:29,528 - DEBUG - Importing WebPImagePlugin
2024-11-05 14:45:29,529 - DEBUG - Importing WmfImagePlugin
2024-11-05 14:45:29,530 - DEBUG - Importing XbmImagePlugin
2024-11-05 14:45:29,530 - DEBUG - Importing XpmImagePlugin
2024-11-05 14:45:29,531 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 14:45:35,814 - DEBUG - Buh-bye! Quitting application.
2024-11-05 14:45:35,815 - ERROR - An error occurred when calling message handler
Traceback (most recent call last):
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_win32.py", line 412, in _dispatcher
    return int(icon._message_handlers.get(
               ~~~~~~~~~~~~~~~~~~~~~~~~~~~
        uMsg, lambda w, l: 0)(wParam, lParam) or 0)
        ~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_win32.py", line 224, in _on_notify
    descriptors[index - 1](self)
    ~~~~~~~~~~~~~~~~~~~~~~^^^^^^
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_base.py", line 328, in inner
    callback(self)
    ~~~~~~~~^^^^^^
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_base.py", line 453, in __call__
    return self._action(icon, self)
           ~~~~~~~~~~~~^^^^^^^^^^^^
  File "C:\Users\Dell\Music\clipboard\main.py", line 72, in on_quit
    sys.exit()
    ~~~~~~~~^^
SystemExit
2024-11-05 14:46:33,821 - DEBUG - Broadcasting clipboard magic: Hasta La Vista
2024-11-05 14:53:31,923 - DEBUG - Broadcasting clipboard magic: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_PORT = 5003  # Port for broadcasting usernames
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target usernames and their IPs
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def on_quit(icon, item):
    logging.debug("Buh-bye! Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Popping the main window back from the shadows.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and teleporting to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Oopsie!", f"Logo file '{image_path}' is missing. Exiting...")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show Me!', show_window), item('Hasta La Vista (QUIT)', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Yikes!", f"System tray setup failed: {e}")

def broadcast_username():
    """Broadcast the username to the network to ensure uniqueness."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        message = f"USERNAME:{username}:{local_ip}:{PORT}"
        sock.sendto(message.encode('utf-8'), ('<broadcast>', USERNAME_PORT))
        logging.debug(f"Broadcasted username '{username}' to the network.")
        # Listen for a short period to check for duplicates
        sock.settimeout(2)
        try:
            while True:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_username == username and received_ip != local_ip:
                        logging.warning(f"Username '{username}' is already taken by {received_ip}:{received_port}.")
                        messagebox.showerror("Username Jam!", f"'{username}' is already taken by {received_ip}:{received_port}. Pick another one!")
                        return False
        except socket.timeout:
            pass  # No duplicates found
    return True

def listen_for_usernames():
    """Listen for username broadcasts to maintain the TARGET_USERS dictionary."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('', USERNAME_PORT))
        logging.debug(f"Listening for username broadcasts on port {USERNAME_PORT}...")
        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_ip == local_ip and received_port == str(PORT):
                        continue  # Ignore own broadcasts
                    if received_username not in TARGET_USERS:
                        TARGET_USERS[received_username] = {'ip': received_ip, 'port': int(received_port), 'copy_count': 0}
                        logging.debug(f"Discovered user '{received_username}' at {received_ip}:{received_port}.")
            except Exception as e:
                logging.error(f"Error receiving username broadcasts: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard magic: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for user, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (info['ip'], info['port']))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard sorcery: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard whispers on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard snippet from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Injecting received clipboard magic into local clipboard...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated with: {received_text}")
                        # Update copy count
                        for user, info in TARGET_USERS.items():
                            if info['ip'] == addr[0] and info['port'] == addr[1]:
                                info['copy_count'] += 1
                                log_activity(user, f"Copied: {received_text}")
                                break
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard snippets: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection giggles on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection giggle from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, target_username = received_message.split(':', 1)
                    # Prevent accepting connection from self
                    if target_username == username:
                        logging.warning(f"Received connection request from self at {addr[0]}:{addr[1]}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Ping", f"Do you wanna vibe with '{target_username}' from {addr[0]}:{addr[1]}?")
                    if result:
                        TARGET_USERS[target_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                        logging.debug(f"Accepted connection from '{target_username}' at {addr[0]}:{addr[1]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = f"CONNECTION_ACCEPTED:{username}"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                        # Assign color for the new user
                        if target_username not in user_colors:
                            user_colors[target_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                    else:
                        logging.debug(f"Declined connection from '{target_username}' at {addr[0]}:{addr[1]}")
            except Exception as e:
                logging.error(f"Error handling connection giggle: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection acceptance on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    _, responder_username = received_message.split(':', 1)
                    # Find the IP and port based on the responder's address
                    for user, info in TARGET_USERS.items():
                        if info['ip'] == addr[0]:
                            break
                    else:
                        # If not found, add the user
                        TARGET_USERS[responder_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                    logging.debug(f"Connection confirmed with '{responder_username}' at {addr[0]}:{addr[1]}")
                    messagebox.showinfo("Connection Made", f"You're now in cahoots with '{responder_username}'!")
                    is_connected.set()
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_username):
    if not username:
        messagebox.showwarning("Oops!", "Please set your username first!")
        return
    if target_username == username:
        messagebox.showwarning("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    if target_username not in TARGET_USERS:
        messagebox.showerror("Whoops!", f"No one named '{target_username}' found in the vicinity.")
        logging.error(f"Attempted to connect to unknown username '{target_username}'.")
        return
    target_info = TARGET_USERS[target_username]
    target_ip = target_info['ip']
    target_port = target_info['port']
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"REQUEST_CONNECTION:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection giggle to '{target_username}' at {target_ip}:{target_port}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind(('', RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    response_message = data.decode('utf-8')
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        _, responder_username = response_message.split(':', 1)
                        TARGET_USERS[responder_username] = {'ip': target_ip, 'port': target_port, 'copy_count': 0}
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                        messagebox.showinfo("Connection Success", f"Now sharing vibes with '{responder_username}'!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                except socket.timeout:
                    logging.debug(f"No response from '{target_username}' at {target_ip}:{target_port}. Connection request timed out.")
                    messagebox.showerror("No Response", f"'{target_username}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection giggle: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to listen for username broadcasts
    threading.Thread(target=listen_for_usernames, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for user, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(user, info['ip'], info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Username and Port
    settings_frame = tk.Frame(root)
    settings_frame.pack(pady=10)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10))
    username_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30)
    username_entry.grid(row=0, column=1, padx=5, pady=5)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10))
    port_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30)
    port_entry.grid(row=1, column=1, padx=5, pady=5)
    port_info_label = tk.Label(settings_frame, text="Leave blank for automatic selection (5000-5050)", font=("Helvetica", 8), fg="gray")
    port_info_label.grid(row=2, column=0, columnspan=2, padx=5, pady=2)

    # Button to Set Username and Port
    def set_username_port():
        global username, PORT
        entered_username = username_entry.get().strip()
        entered_port = port_entry.get().strip()
        if not entered_username:
            messagebox.showerror("No Name, No Game", "You gotta have a username to play!")
            return
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        messagebox.showerror("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        return
            except ValueError:
                messagebox.showerror("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                logging.debug(f"Automatically selected free port: {PORT}")
            except Exception as e:
                messagebox.showerror("Port Error", str(e))
                return
        username = entered_username
        if broadcast_username():
            messagebox.showinfo("Username Set", f"Username '{username}' set successfully on port {PORT}.")
            # Disable the entries and button after setting
            username_entry.config(state='disabled')
            port_entry.config(state='disabled')
            set_button.config(state='disabled')
            # Display the username and local IP address at the top of the dashboard
            user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
            ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
            # Start the threads after setting username and port
            start_threads()
        else:
            # Username duplication detected; prompt to enter a new one
            username_entry.delete(0, tk.END)

    set_button = tk.Button(settings_frame, text="\U0001f389 Set Username & Port", command=set_username_port)
    set_button.grid(row=3, column=0, columnspan=2, pady=10)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"))
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled', command=lambda: send_connection_request(simpledialog.askstring("Send Invite", "Enter username to invite:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...", font=("Helvetica", 10, "italic"))
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root)
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"))
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10)
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color)
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"))
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def on_close():
        hide_window()
        messagebox.showinfo("ClipHilarity Sync", "Clipboard antics will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
            request_button.config(state='normal')
        else:
            pause_button.pack_forget()
            request_button.config(state='disabled')
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:53:37,923 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:53:37,923 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:53:37,923 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:53:37,923 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:53:37,951 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:53:37,951 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:53:37,951 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:53:37,951 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:53:52,570 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:53:52,570 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:53:52,570 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:53:52,570 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:53:52,597 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:53:52,597 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:53:52,597 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:53:52,597 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:54:21,288 - DEBUG - Hiding main window and teleporting to system tray.
2024-11-05 14:54:21,316 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:54:21,317 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:54:21,317 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:54:21,317 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:54:21,325 - DEBUG - Importing BlpImagePlugin
2024-11-05 14:54:21,329 - DEBUG - Importing BmpImagePlugin
2024-11-05 14:54:21,329 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 14:54:21,330 - DEBUG - Importing CurImagePlugin
2024-11-05 14:54:21,331 - DEBUG - Importing DcxImagePlugin
2024-11-05 14:54:21,332 - DEBUG - Importing DdsImagePlugin
2024-11-05 14:54:21,334 - DEBUG - Importing EpsImagePlugin
2024-11-05 14:54:21,335 - DEBUG - Importing FitsImagePlugin
2024-11-05 14:54:21,336 - DEBUG - Importing FliImagePlugin
2024-11-05 14:54:21,336 - DEBUG - Importing FpxImagePlugin
2024-11-05 14:54:21,337 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 14:54:21,337 - DEBUG - Importing FtexImagePlugin
2024-11-05 14:54:21,337 - DEBUG - Importing GbrImagePlugin
2024-11-05 14:54:21,338 - DEBUG - Importing GifImagePlugin
2024-11-05 14:54:21,338 - DEBUG - Importing GribStubImagePlugin
2024-11-05 14:54:21,338 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 14:54:21,338 - DEBUG - Importing IcnsImagePlugin
2024-11-05 14:54:21,340 - DEBUG - Importing IcoImagePlugin
2024-11-05 14:54:21,341 - DEBUG - Importing ImImagePlugin
2024-11-05 14:54:21,341 - DEBUG - Importing ImtImagePlugin
2024-11-05 14:54:21,342 - DEBUG - Importing IptcImagePlugin
2024-11-05 14:54:21,342 - DEBUG - Importing JpegImagePlugin
2024-11-05 14:54:21,342 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 14:54:21,342 - DEBUG - Importing McIdasImagePlugin
2024-11-05 14:54:21,343 - DEBUG - Importing MicImagePlugin
2024-11-05 14:54:21,343 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 14:54:21,343 - DEBUG - Importing MpegImagePlugin
2024-11-05 14:54:21,343 - DEBUG - Importing MpoImagePlugin
2024-11-05 14:54:21,347 - DEBUG - Importing MspImagePlugin
2024-11-05 14:54:21,348 - DEBUG - Importing PalmImagePlugin
2024-11-05 14:54:21,348 - DEBUG - Importing PcdImagePlugin
2024-11-05 14:54:21,349 - DEBUG - Importing PcxImagePlugin
2024-11-05 14:54:21,349 - DEBUG - Importing PdfImagePlugin
2024-11-05 14:54:21,352 - DEBUG - Importing PixarImagePlugin
2024-11-05 14:54:21,353 - DEBUG - Importing PngImagePlugin
2024-11-05 14:54:21,353 - DEBUG - Importing PpmImagePlugin
2024-11-05 14:54:21,353 - DEBUG - Importing PsdImagePlugin
2024-11-05 14:54:21,353 - DEBUG - Importing QoiImagePlugin
2024-11-05 14:54:21,354 - DEBUG - Importing SgiImagePlugin
2024-11-05 14:54:21,354 - DEBUG - Importing SpiderImagePlugin
2024-11-05 14:54:21,354 - DEBUG - Importing SunImagePlugin
2024-11-05 14:54:21,355 - DEBUG - Importing TgaImagePlugin
2024-11-05 14:54:21,355 - DEBUG - Importing TiffImagePlugin
2024-11-05 14:54:21,355 - DEBUG - Importing WebPImagePlugin
2024-11-05 14:54:21,356 - DEBUG - Importing WmfImagePlugin
2024-11-05 14:54:21,356 - DEBUG - Importing XbmImagePlugin
2024-11-05 14:54:21,357 - DEBUG - Importing XpmImagePlugin
2024-11-05 14:54:21,357 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 14:54:26,358 - DEBUG - Buh-bye! Quitting application.
2024-11-05 14:54:26,359 - ERROR - An error occurred when calling message handler
Traceback (most recent call last):
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_win32.py", line 412, in _dispatcher
    return int(icon._message_handlers.get(
               ~~~~~~~~~~~~~~~~~~~~~~~~~~~
        uMsg, lambda w, l: 0)(wParam, lParam) or 0)
        ~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_win32.py", line 224, in _on_notify
    descriptors[index - 1](self)
    ~~~~~~~~~~~~~~~~~~~~~~^^^^^^
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_base.py", line 328, in inner
    callback(self)
    ~~~~~~~~^^^^^^
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_base.py", line 453, in __call__
    return self._action(icon, self)
           ~~~~~~~~~~~~^^^^^^^^^^^^
  File "C:\Users\Dell\Music\clipboard\main.py", line 74, in on_quit
    sys.exit()
    ~~~~~~~~^^
SystemExit
2024-11-05 14:55:15,911 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:55:15,911 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:55:15,911 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:55:15,911 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:55:15,939 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:55:15,939 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:55:15,939 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:55:15,939 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:55:29,234 - DEBUG - Broadcasted username 'mohit pc 1' to the network.
2024-11-05 14:55:33,669 - DEBUG - Listening for clipboard whispers on port 5000...
2024-11-05 14:55:33,669 - DEBUG - Listening for connection giggles on port 5001...
2024-11-05 14:55:33,669 - DEBUG - Listening for connection acceptance on port 5002...
2024-11-05 14:55:33,669 - DEBUG - Listening for username broadcasts on port 5003...
2024-11-05 14:55:51,200 - DEBUG - Discovered user 'mohit pc 2' at 192.168.1.26:5000.
2024-11-05 14:56:04,850 - DEBUG - Hiding main window and teleporting to system tray.
2024-11-05 14:56:04,869 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:56:04,869 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:56:04,869 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:56:04,869 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:56:04,878 - DEBUG - Importing BlpImagePlugin
2024-11-05 14:56:04,879 - DEBUG - Importing BmpImagePlugin
2024-11-05 14:56:04,879 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 14:56:04,879 - DEBUG - Importing CurImagePlugin
2024-11-05 14:56:04,880 - DEBUG - Importing DcxImagePlugin
2024-11-05 14:56:04,881 - DEBUG - Importing DdsImagePlugin
2024-11-05 14:56:04,883 - DEBUG - Importing EpsImagePlugin
2024-11-05 14:56:04,884 - DEBUG - Importing FitsImagePlugin
2024-11-05 14:56:04,885 - DEBUG - Importing FliImagePlugin
2024-11-05 14:56:04,886 - DEBUG - Importing FpxImagePlugin
2024-11-05 14:56:04,887 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 14:56:04,887 - DEBUG - Importing FtexImagePlugin
2024-11-05 14:56:04,887 - DEBUG - Importing GbrImagePlugin
2024-11-05 14:56:04,888 - DEBUG - Importing GifImagePlugin
2024-11-05 14:56:04,888 - DEBUG - Importing GribStubImagePlugin
2024-11-05 14:56:04,888 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 14:56:04,889 - DEBUG - Importing IcnsImagePlugin
2024-11-05 14:56:04,891 - DEBUG - Importing IcoImagePlugin
2024-11-05 14:56:04,892 - DEBUG - Importing ImImagePlugin
2024-11-05 14:56:04,893 - DEBUG - Importing ImtImagePlugin
2024-11-05 14:56:04,893 - DEBUG - Importing IptcImagePlugin
2024-11-05 14:56:04,894 - DEBUG - Importing JpegImagePlugin
2024-11-05 14:56:04,894 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 14:56:04,894 - DEBUG - Importing McIdasImagePlugin
2024-11-05 14:56:04,894 - DEBUG - Importing MicImagePlugin
2024-11-05 14:56:04,895 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 14:56:04,895 - DEBUG - Importing MpegImagePlugin
2024-11-05 14:56:04,895 - DEBUG - Importing MpoImagePlugin
2024-11-05 14:56:04,899 - DEBUG - Importing MspImagePlugin
2024-11-05 14:56:04,899 - DEBUG - Importing PalmImagePlugin
2024-11-05 14:56:04,900 - DEBUG - Importing PcdImagePlugin
2024-11-05 14:56:04,900 - DEBUG - Importing PcxImagePlugin
2024-11-05 14:56:04,900 - DEBUG - Importing PdfImagePlugin
2024-11-05 14:56:04,904 - DEBUG - Importing PixarImagePlugin
2024-11-05 14:56:04,905 - DEBUG - Importing PngImagePlugin
2024-11-05 14:56:04,905 - DEBUG - Importing PpmImagePlugin
2024-11-05 14:56:04,905 - DEBUG - Importing PsdImagePlugin
2024-11-05 14:56:04,905 - DEBUG - Importing QoiImagePlugin
2024-11-05 14:56:04,905 - DEBUG - Importing SgiImagePlugin
2024-11-05 14:56:04,906 - DEBUG - Importing SpiderImagePlugin
2024-11-05 14:56:04,906 - DEBUG - Importing SunImagePlugin
2024-11-05 14:56:04,906 - DEBUG - Importing TgaImagePlugin
2024-11-05 14:56:04,907 - DEBUG - Importing TiffImagePlugin
2024-11-05 14:56:04,907 - DEBUG - Importing WebPImagePlugin
2024-11-05 14:56:04,907 - DEBUG - Importing WmfImagePlugin
2024-11-05 14:56:04,908 - DEBUG - Importing XbmImagePlugin
2024-11-05 14:56:04,908 - DEBUG - Importing XpmImagePlugin
2024-11-05 14:56:04,909 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 14:56:15,163 - DEBUG - Buh-bye! Quitting application.
2024-11-05 14:56:15,164 - ERROR - An error occurred when calling message handler
Traceback (most recent call last):
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_win32.py", line 412, in _dispatcher
    return int(icon._message_handlers.get(
               ~~~~~~~~~~~~~~~~~~~~~~~~~~~
        uMsg, lambda w, l: 0)(wParam, lParam) or 0)
        ~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_win32.py", line 224, in _on_notify
    descriptors[index - 1](self)
    ~~~~~~~~~~~~~~~~~~~~~~^^^^^^
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_base.py", line 328, in inner
    callback(self)
    ~~~~~~~~^^^^^^
  File "C:\Users\Dell\AppData\Roaming\Python\Python313\site-packages\pystray\_base.py", line 453, in __call__
    return self._action(icon, self)
           ~~~~~~~~~~~~^^^^^^^^^^^^
  File "C:\Users\Dell\Music\clipboard\main.py", line 74, in on_quit
    sys.exit()
    ~~~~~~~~^^
SystemExit
2024-11-05 15:00:32,155 - DEBUG - Broadcasting clipboard magic: pip install pyperclip pillow

2024-11-05 15:02:30,365 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 15:02:30,366 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 15:02:30,366 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 15:02:30,366 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 15:02:30,393 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 15:02:30,393 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 15:02:30,393 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 15:02:30,393 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 15:02:36,782 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 15:02:36,783 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 15:02:36,783 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 15:02:36,783 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 15:02:36,810 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 15:02:36,810 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 15:02:36,810 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 15:02:36,810 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 15:02:51,738 - DEBUG - Automatically selected free port: 5000
2024-11-05 15:02:57,393 - DEBUG - Broadcasted username 'Mohit pc' to the network.
2024-11-05 15:03:37,481 - ERROR - Attempted to connect to unknown username 'Mohit laptop'.
2024-11-05 15:03:50,523 - ERROR - Attempted to connect to unknown username '192.168.1.16'.
2024-11-05 15:07:40,955 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 15:07:40,955 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 15:07:40,955 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 15:07:40,955 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 15:07:40,982 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 15:07:40,982 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 15:07:40,982 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 15:07:40,982 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 15:07:45,801 - DEBUG - Automatically selected free port: 5000
2024-11-05 15:10:06,902 - WARNING - User attempted to send connection request to themselves.
2024-11-05 15:16:17,372 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 15:16:17,372 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 15:16:17,372 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 15:16:17,372 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 15:16:17,398 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 15:16:17,398 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 15:16:17,398 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 15:16:17,399 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 15:17:44,228 - DEBUG - Listening for clipboard updates on port 5000...
2024-11-05 15:17:44,228 - DEBUG - Listening for connection requests on port 5001...
2024-11-05 15:17:44,229 - DEBUG - Listening for connection responses on port 5002...
2024-11-05 15:17:44,294 - DEBUG - Broadcasting clipboard content: #269144
2024-11-05 15:18:39,962 - DEBUG - Sent connection request to 192.168.1.26:5001
2024-11-05 15:18:49,960 - DEBUG - No response from '192.168.1.26:5001'. Connection request timed out.
2024-11-05 15:19:10,220 - DEBUG - Sent connection request to 192.168.1.16:5001
2024-11-05 15:19:20,215 - DEBUG - No response from '192.168.1.16:5001'. Connection request timed out.
2024-11-05 15:21:09,578 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 15:21:09,578 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 15:21:09,578 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 15:21:09,578 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 15:21:09,607 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 15:21:09,608 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 15:21:09,608 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 15:21:09,608 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 15:21:17,846 - DEBUG - Listening for clipboard updates on port 5000...
2024-11-05 15:21:17,847 - DEBUG - Listening for connection requests on port 5001...
2024-11-05 15:21:17,847 - DEBUG - Listening for connection responses on port 5002...
2024-11-05 15:22:38,464 - DEBUG - Sent connection request to 192.168.1.26:5001
2024-11-05 15:22:48,473 - DEBUG - No response from '192.168.1.26:5001'. Connection request timed out.
2024-11-05 15:23:00,905 - DEBUG - Sent connection request to 192.168.1.26:5001
2024-11-05 15:23:10,902 - DEBUG - No response from '192.168.1.26:5001'. Connection request timed out.
2024-11-05 15:23:23,729 - DEBUG - Broadcasting clipboard content: use enter to press button and all buttons are rounded by 16px or any unit you use 

2024-11-05 15:23:29,672 - DEBUG - Broadcasting clipboard content: button border color is still black use this #269144

2024-11-05 15:25:51,287 - DEBUG - Broadcasting clipboard content: specific
2024-11-05 15:26:32,915 - DEBUG - Broadcasting clipboard content: 1. cant varify of the other person has accepting the request like no connection is being made still its selding a connection request.

2. cant detect if the request is send to yourself

3. button border color is still black use this #269144

4. use enter to press button and all buttons are rounded by 16px or any unit you use 

5. use a list of funny usernames if none sets username by themselfs (let the set username be active so they can change at anytime and when they change the username send a packet showing the new username of the specific person and the other person to show the new username)


2024-11-05 15:26:46,622 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, REQUEST_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_sock.sendto(username.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected from {addr[0]}:{sender_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                responder_username = data.decode('utf-8')
                # Add the responder to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {responder_username} at {addr[0]}:{PORT}")
                messagebox.showinfo("Connection Made",
                                    f"You're now connected with '{responder_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if responder_username not in user_colors:
                    user_colors[responder_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")
    root.configure(bg="#70a9c8")  # Set body color

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=lambda: set_port(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=lambda: set_username(),
                                    bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                    bd=2, relief='solid', highlightbackground="#269144")
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled',
                              command=lambda: invite_buddy(),
                              bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                              bd=2, relief='solid', highlightbackground="#269144")
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)

        # Button to Send Connection Request
        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite",
                                command=lambda: send_request(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause,
                             bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                             bd=2, relief='solid', highlightbackground="#269144")
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            custom_error_popup("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        # Send username to connected users (if any)
        # No username broadcasting is required since connections are IP-based
        messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
        # Disable the username entry and button after setting
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:27:00,822 - DEBUG - Broadcasting clipboard content: 1. cant varify of the other person has accepting the request like no connection is being made still its selding a connection request.

2. cant detect if the request is send to yourself

3. button border color is still black use this #269144

4. use enter to press button and all buttons are rounded by 16px or any unit you use 

5. use a list of funny usernames if none sets username by themselfs (let the set username be active so they can change at anytime and when they change the username send a packet showing the new username of the specific person and the other person to show the new username)

import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, REQUEST_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_sock.sendto(username.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected from {addr[0]}:{sender_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                responder_username = data.decode('utf-8')
                # Add the responder to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {responder_username} at {addr[0]}:{PORT}")
                messagebox.showinfo("Connection Made",
                                    f"You're now connected with '{responder_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if responder_username not in user_colors:
                    user_colors[responder_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")
    root.configure(bg="#70a9c8")  # Set body color

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=lambda: set_port(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=lambda: set_username(),
                                    bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                    bd=2, relief='solid', highlightbackground="#269144")
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled',
                              command=lambda: invite_buddy(),
                              bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                              bd=2, relief='solid', highlightbackground="#269144")
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)

        # Button to Send Connection Request
        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite",
                                command=lambda: send_request(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause,
                             bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                             bd=2, relief='solid', highlightbackground="#269144")
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            custom_error_popup("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        # Send username to connected users (if any)
        # No username broadcasting is required since connections are IP-based
        messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
        # Disable the username entry and button after setting
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:28:13,948 - DEBUG - Broadcasting clipboard content: funny game usernames
2024-11-05 15:30:32,413 - DEBUG - Broadcasting clipboard content: TextualTornado
TypoTitan
ChatChomper
WordWhiskers
EmojiExplorer
LaughingLetter
TxtWizKid
SnappyScript
ByteBandit
PixelPunctuation
LOLLinguist
GrammarGator
BuzzingBeeps
GiggleGlitch
MemeMorsel
S'morePixels
ChuckleCharm
FableFrolic
ScribbleSprite
FontFunk
DizzyDialogue
JollyJabber
TickleTyper
PunctuationPirate
GigabyteGiggler
ChortleChimp
HappyTypo
ScrollSorcerer
LOLingLlama
TypoTreasure






2024-11-05 15:32:27,523 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_UPDATE_PORT = 5003  # Port for username updates
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, info['port']))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update copy count
                            if addr[0] in USER_STATS:
                                USER_STATS[addr[0]] += 1
                            else:
                                USER_STATS[addr[0]] = 1
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                    USER_STATS[addr[0]] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{PORT}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], PORT)
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def handle_username_updates():
    # Create a UDP socket for listening to incoming username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for username updates on USERNAME_UPDATE_PORT
            sock.bind(('', USERNAME_UPDATE_PORT))
            logging.debug(f"Listening for username updates on port {USERNAME_UPDATE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {USERNAME_UPDATE_PORT} for username updates: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME_UPDATE:"):
                    _, new_username = received_message.split(':', 1)
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling username update: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if (target_ip == local_ip and target_port == PORT) or (target_ip == local_ip and target_port == RESPONSE_PORT):
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_sock.bind(('', RESPONSE_PORT))
                    response_message, _ = response_sock.recvfrom(1024)
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        responder_username = response_message.split(':', 1)[1]
                        # Add the responder to TARGET_USERS
                        TARGET_USERS[target_ip] = {'port': PORT, 'copy_count': 0, 'username': responder_username}
                        USER_STATS[target_ip] = 0
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{PORT}")
                        messagebox.showinfo("Connection Success",
                                            f"Now sharing vibes with '{responder_username}' at {target_ip}:{PORT}!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(responder_username, f"Connected from {target_ip}:{PORT}")
                        # Send current username to the new connection
                        send_username_update(target_ip, PORT)
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, USERNAME_UPDATE_PORT))
            logging.debug(f"Sent username update to {target_ip}:{USERNAME_UPDATE_PORT}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to handle username updates
    threading.Thread(target=handle_username_updates, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text, pause_button

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = ttk.Button(settings_frame, text="\U0001f527 Set Port", style='Custom.TButton',
                                 command=lambda: set_port())
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    # Bind Enter key to Set Port and Set Username buttons
    root.bind('<Return>', lambda event: set_port() if port_entry.focus_get() else None)
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:32:31,445 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, REQUEST_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_sock.sendto(username.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected from {addr[0]}:{sender_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                responder_username = data.decode('utf-8')
                # Add the responder to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {responder_username} at {addr[0]}:{PORT}")
                messagebox.showinfo("Connection Made",
                                    f"You're now connected with '{responder_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if responder_username not in user_colors:
                    user_colors[responder_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")
    root.configure(bg="#70a9c8")  # Set body color

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=lambda: set_port(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=lambda: set_username(),
                                    bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                    bd=2, relief='solid', highlightbackground="#269144")
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled',
                              command=lambda: invite_buddy(),
                              bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                              bd=2, relief='solid', highlightbackground="#269144")
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)

        # Button to Send Connection Request
        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite",
                                command=lambda: send_request(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause,
                             bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                             bd=2, relief='solid', highlightbackground="#269144")
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            custom_error_popup("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        # Send username to connected users (if any)
        # No username broadcasting is required since connections are IP-based
        messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
        # Disable the username entry and button after setting
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:32:35,036 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_UPDATE_PORT = 5003  # Port for username updates
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, info['port']))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update copy count
                            if addr[0] in USER_STATS:
                                USER_STATS[addr[0]] += 1
                            else:
                                USER_STATS[addr[0]] = 1
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                    USER_STATS[addr[0]] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{PORT}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], PORT)
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def handle_username_updates():
    # Create a UDP socket for listening to incoming username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for username updates on USERNAME_UPDATE_PORT
            sock.bind(('', USERNAME_UPDATE_PORT))
            logging.debug(f"Listening for username updates on port {USERNAME_UPDATE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {USERNAME_UPDATE_PORT} for username updates: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME_UPDATE:"):
                    _, new_username = received_message.split(':', 1)
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling username update: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if (target_ip == local_ip and target_port == PORT) or (target_ip == local_ip and target_port == RESPONSE_PORT):
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_sock.bind(('', RESPONSE_PORT))
                    response_message, _ = response_sock.recvfrom(1024)
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        responder_username = response_message.split(':', 1)[1]
                        # Add the responder to TARGET_USERS
                        TARGET_USERS[target_ip] = {'port': PORT, 'copy_count': 0, 'username': responder_username}
                        USER_STATS[target_ip] = 0
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{PORT}")
                        messagebox.showinfo("Connection Success",
                                            f"Now sharing vibes with '{responder_username}' at {target_ip}:{PORT}!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(responder_username, f"Connected from {target_ip}:{PORT}")
                        # Send current username to the new connection
                        send_username_update(target_ip, PORT)
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, USERNAME_UPDATE_PORT))
            logging.debug(f"Sent username update to {target_ip}:{USERNAME_UPDATE_PORT}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to handle username updates
    threading.Thread(target=handle_username_updates, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text, pause_button

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = ttk.Button(settings_frame, text="\U0001f527 Set Port", style='Custom.TButton',
                                 command=lambda: set_port())
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    # Bind Enter key to Set Port and Set Username buttons
    root.bind('<Return>', lambda event: set_port() if port_entry.focus_get() else None)
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:32:38,653 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 15:32:38,653 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 15:32:38,654 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 15:32:38,654 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 15:32:49,740 - DEBUG - Listening for clipboard updates on port 5000...
2024-11-05 15:32:49,740 - DEBUG - Listening for connection requests on port 5001...
2024-11-05 15:32:49,741 - DEBUG - Listening for connection responses on port 5002...
2024-11-05 15:32:49,741 - DEBUG - Listening for username updates on port 5003...
2024-11-05 15:32:49,810 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_UPDATE_PORT = 5003  # Port for username updates
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, info['port']))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update copy count
                            if addr[0] in USER_STATS:
                                USER_STATS[addr[0]] += 1
                            else:
                                USER_STATS[addr[0]] = 1
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                    USER_STATS[addr[0]] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{PORT}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], PORT)
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def handle_username_updates():
    # Create a UDP socket for listening to incoming username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for username updates on USERNAME_UPDATE_PORT
            sock.bind(('', USERNAME_UPDATE_PORT))
            logging.debug(f"Listening for username updates on port {USERNAME_UPDATE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {USERNAME_UPDATE_PORT} for username updates: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME_UPDATE:"):
                    _, new_username = received_message.split(':', 1)
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling username update: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if (target_ip == local_ip and target_port == PORT) or (target_ip == local_ip and target_port == RESPONSE_PORT):
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_sock.bind(('', RESPONSE_PORT))
                    response_message, _ = response_sock.recvfrom(1024)
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        responder_username = response_message.split(':', 1)[1]
                        # Add the responder to TARGET_USERS
                        TARGET_USERS[target_ip] = {'port': PORT, 'copy_count': 0, 'username': responder_username}
                        USER_STATS[target_ip] = 0
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{PORT}")
                        messagebox.showinfo("Connection Success",
                                            f"Now sharing vibes with '{responder_username}' at {target_ip}:{PORT}!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(responder_username, f"Connected from {target_ip}:{PORT}")
                        # Send current username to the new connection
                        send_username_update(target_ip, PORT)
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, USERNAME_UPDATE_PORT))
            logging.debug(f"Sent username update to {target_ip}:{USERNAME_UPDATE_PORT}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to handle username updates
    threading.Thread(target=handle_username_updates, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text, pause_button

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = ttk.Button(settings_frame, text="\U0001f527 Set Port", style='Custom.TButton',
                                 command=lambda: set_port())
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    # Bind Enter key to Set Port and Set Username buttons
    root.bind('<Return>', lambda event: set_port() if port_entry.focus_get() else None)
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:33:47,602 - DEBUG - Sent connection request to 192.168.1.26:5001
2024-11-05 15:33:47,602 - ERROR - Error sending connection request: [WinError 10048] Only one usage of each socket address (protocol/network address/port) is normally permitted
2024-11-05 15:34:08,490 - DEBUG - Sent connection request to 192.168.1.26:5001
2024-11-05 15:34:08,490 - ERROR - Error sending connection request: [WinError 10048] Only one usage of each socket address (protocol/network address/port) is normally permitted
2024-11-05 15:35:39,878 - DEBUG - Sent connection request to 192.168.1.26:5001
2024-11-05 15:35:39,878 - ERROR - Error sending connection request: [WinError 10048] Only one usage of each socket address (protocol/network address/port) is normally permitted
2024-11-05 15:37:17,442 - DEBUG - Broadcasting clipboard content: pip install pystray Pillow

2024-11-05 15:37:48,602 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 15:37:48,602 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 15:37:48,602 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 15:37:48,602 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 15:38:45,670 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 15:38:45,670 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 15:38:45,670 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 15:38:45,670 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 15:38:46,149 - DEBUG - Importing BlpImagePlugin
2024-11-05 15:38:46,150 - DEBUG - Importing BmpImagePlugin
2024-11-05 15:38:46,150 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 15:38:46,151 - DEBUG - Importing CurImagePlugin
2024-11-05 15:38:46,151 - DEBUG - Importing DcxImagePlugin
2024-11-05 15:38:46,153 - DEBUG - Importing DdsImagePlugin
2024-11-05 15:38:46,156 - DEBUG - Importing EpsImagePlugin
2024-11-05 15:38:46,157 - DEBUG - Importing FitsImagePlugin
2024-11-05 15:38:46,158 - DEBUG - Importing FliImagePlugin
2024-11-05 15:38:46,158 - DEBUG - Importing FpxImagePlugin
2024-11-05 15:38:46,159 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 15:38:46,159 - DEBUG - Importing FtexImagePlugin
2024-11-05 15:38:46,160 - DEBUG - Importing GbrImagePlugin
2024-11-05 15:38:46,160 - DEBUG - Importing GifImagePlugin
2024-11-05 15:38:46,160 - DEBUG - Importing GribStubImagePlugin
2024-11-05 15:38:46,161 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 15:38:46,161 - DEBUG - Importing IcnsImagePlugin
2024-11-05 15:38:46,162 - DEBUG - Importing IcoImagePlugin
2024-11-05 15:38:46,163 - DEBUG - Importing ImImagePlugin
2024-11-05 15:38:46,164 - DEBUG - Importing ImtImagePlugin
2024-11-05 15:38:46,164 - DEBUG - Importing IptcImagePlugin
2024-11-05 15:38:46,164 - DEBUG - Importing JpegImagePlugin
2024-11-05 15:38:46,164 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 15:38:46,164 - DEBUG - Importing McIdasImagePlugin
2024-11-05 15:38:46,165 - DEBUG - Importing MicImagePlugin
2024-11-05 15:38:46,165 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 15:38:46,165 - DEBUG - Importing MpegImagePlugin
2024-11-05 15:38:46,166 - DEBUG - Importing MpoImagePlugin
2024-11-05 15:38:46,170 - DEBUG - Importing MspImagePlugin
2024-11-05 15:38:46,170 - DEBUG - Importing PalmImagePlugin
2024-11-05 15:38:46,171 - DEBUG - Importing PcdImagePlugin
2024-11-05 15:38:46,171 - DEBUG - Importing PcxImagePlugin
2024-11-05 15:38:46,171 - DEBUG - Importing PdfImagePlugin
2024-11-05 15:38:46,175 - DEBUG - Importing PixarImagePlugin
2024-11-05 15:38:46,176 - DEBUG - Importing PngImagePlugin
2024-11-05 15:38:46,176 - DEBUG - Importing PpmImagePlugin
2024-11-05 15:38:46,176 - DEBUG - Importing PsdImagePlugin
2024-11-05 15:38:46,176 - DEBUG - Importing QoiImagePlugin
2024-11-05 15:38:46,177 - DEBUG - Importing SgiImagePlugin
2024-11-05 15:38:46,177 - DEBUG - Importing SpiderImagePlugin
2024-11-05 15:38:46,178 - DEBUG - Importing SunImagePlugin
2024-11-05 15:38:46,178 - DEBUG - Importing TgaImagePlugin
2024-11-05 15:38:46,178 - DEBUG - Importing TiffImagePlugin
2024-11-05 15:38:46,178 - DEBUG - Importing WebPImagePlugin
2024-11-05 15:38:46,179 - DEBUG - Importing WmfImagePlugin
2024-11-05 15:38:46,180 - DEBUG - Importing XbmImagePlugin
2024-11-05 15:38:46,180 - DEBUG - Importing XpmImagePlugin
2024-11-05 15:38:46,181 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 15:38:49,148 - DEBUG - Listening for clipboard updates on port 5000...
2024-11-05 15:38:49,148 - DEBUG - Listening for connection requests on port 5001...
2024-11-05 15:38:49,149 - DEBUG - Listening for connection responses on port 5002...
2024-11-05 15:38:49,149 - DEBUG - Listening for username updates on port 5003...
2024-11-05 15:38:49,184 - DEBUG - Broadcasting clipboard content: from PIL import Image, ImageTk, ImageDraw
2024-11-05 15:38:58,077 - ERROR - Error sending connection request: [Errno 11001] getaddrinfo failed
2024-11-05 15:39:29,921 - DEBUG - Sent connection request to 192.168.1.26:5001
2024-11-05 15:39:29,921 - ERROR - Error sending connection request: [WinError 10048] Only one usage of each socket address (protocol/network address/port) is normally permitted
2024-11-05 15:40:25,855 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 15:40:25,855 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 15:40:25,855 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 15:40:25,855 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 15:40:26,337 - DEBUG - Importing BlpImagePlugin
2024-11-05 15:40:26,337 - DEBUG - Importing BmpImagePlugin
2024-11-05 15:40:26,337 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 15:40:26,338 - DEBUG - Importing CurImagePlugin
2024-11-05 15:40:26,339 - DEBUG - Importing DcxImagePlugin
2024-11-05 15:40:26,340 - DEBUG - Importing DdsImagePlugin
2024-11-05 15:40:26,343 - DEBUG - Importing EpsImagePlugin
2024-11-05 15:40:26,343 - DEBUG - Importing FitsImagePlugin
2024-11-05 15:40:26,345 - DEBUG - Importing FliImagePlugin
2024-11-05 15:40:26,345 - DEBUG - Importing FpxImagePlugin
2024-11-05 15:40:26,346 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 15:40:26,346 - DEBUG - Importing FtexImagePlugin
2024-11-05 15:40:26,347 - DEBUG - Importing GbrImagePlugin
2024-11-05 15:40:26,347 - DEBUG - Importing GifImagePlugin
2024-11-05 15:40:26,347 - DEBUG - Importing GribStubImagePlugin
2024-11-05 15:40:26,348 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 15:40:26,348 - DEBUG - Importing IcnsImagePlugin
2024-11-05 15:40:26,350 - DEBUG - Importing IcoImagePlugin
2024-11-05 15:40:26,351 - DEBUG - Importing ImImagePlugin
2024-11-05 15:40:26,351 - DEBUG - Importing ImtImagePlugin
2024-11-05 15:40:26,352 - DEBUG - Importing IptcImagePlugin
2024-11-05 15:40:26,352 - DEBUG - Importing JpegImagePlugin
2024-11-05 15:40:26,352 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 15:40:26,352 - DEBUG - Importing McIdasImagePlugin
2024-11-05 15:40:26,353 - DEBUG - Importing MicImagePlugin
2024-11-05 15:40:26,353 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 15:40:26,354 - DEBUG - Importing MpegImagePlugin
2024-11-05 15:40:26,354 - DEBUG - Importing MpoImagePlugin
2024-11-05 15:40:26,360 - DEBUG - Importing MspImagePlugin
2024-11-05 15:40:26,360 - DEBUG - Importing PalmImagePlugin
2024-11-05 15:40:26,361 - DEBUG - Importing PcdImagePlugin
2024-11-05 15:40:26,361 - DEBUG - Importing PcxImagePlugin
2024-11-05 15:40:26,361 - DEBUG - Importing PdfImagePlugin
2024-11-05 15:40:26,365 - DEBUG - Importing PixarImagePlugin
2024-11-05 15:40:26,366 - DEBUG - Importing PngImagePlugin
2024-11-05 15:40:26,366 - DEBUG - Importing PpmImagePlugin
2024-11-05 15:40:26,366 - DEBUG - Importing PsdImagePlugin
2024-11-05 15:40:26,366 - DEBUG - Importing QoiImagePlugin
2024-11-05 15:40:26,367 - DEBUG - Importing SgiImagePlugin
2024-11-05 15:40:26,367 - DEBUG - Importing SpiderImagePlugin
2024-11-05 15:40:26,367 - DEBUG - Importing SunImagePlugin
2024-11-05 15:40:26,368 - DEBUG - Importing TgaImagePlugin
2024-11-05 15:40:26,368 - DEBUG - Importing TiffImagePlugin
2024-11-05 15:40:26,368 - DEBUG - Importing WebPImagePlugin
2024-11-05 15:40:26,369 - DEBUG - Importing WmfImagePlugin
2024-11-05 15:40:26,369 - DEBUG - Importing XbmImagePlugin
2024-11-05 15:40:26,370 - DEBUG - Importing XpmImagePlugin
2024-11-05 15:40:26,370 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 15:40:33,172 - DEBUG - Listening for clipboard updates on port 5000...
2024-11-05 15:40:33,173 - DEBUG - Listening for connection requests on port 6001...
2024-11-05 15:40:33,173 - DEBUG - Listening for connection responses on port 6002...
2024-11-05 15:40:33,173 - DEBUG - Listening for username updates on port 5003...
2024-11-05 15:40:33,237 - DEBUG - Broadcasting clipboard content: from PIL import Image, ImageTk, ImageDraw
2024-11-05 15:40:41,640 - DEBUG - Sent connection request to 192.168.1.26:6001
2024-11-05 15:40:41,640 - ERROR - Error sending connection request: [WinError 10048] Only one usage of each socket address (protocol/network address/port) is normally permitted
2024-11-05 15:42:01,922 - DEBUG - Broadcasting clipboard content: netstat -ano
2024-11-05 15:42:30,041 - DEBUG - Broadcasting clipboard content: lsof -i :5000
2024-11-05 15:43:01,744 - DEBUG - Broadcasting clipboard content: netstat -ano | findstr :5000
2024-11-05 15:43:24,613 - DEBUG - Broadcasting clipboard content: command to check the process running on a port 5000 on windows using cmd
2024-11-05 15:43:55,443 - DEBUG - Broadcasting clipboard content: taskkill /PID <PID> /F

2024-11-05 15:43:57,185 - DEBUG - Broadcasting clipboard content: UDP    0.0.0.0:5000           *:*                                    20356
  UDP    0.0.0.0:50001          *:*                                    4724
2024-11-05 15:44:05,889 - DEBUG - Broadcasting clipboard content: taskkill /PID <PID> /F

2024-11-05 15:44:39,445 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 15:44:39,445 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 15:44:39,445 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 15:44:39,445 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 15:44:39,904 - DEBUG - Importing BlpImagePlugin
2024-11-05 15:44:39,905 - DEBUG - Importing BmpImagePlugin
2024-11-05 15:44:39,905 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 15:44:39,906 - DEBUG - Importing CurImagePlugin
2024-11-05 15:44:39,906 - DEBUG - Importing DcxImagePlugin
2024-11-05 15:44:39,907 - DEBUG - Importing DdsImagePlugin
2024-11-05 15:44:39,910 - DEBUG - Importing EpsImagePlugin
2024-11-05 15:44:39,911 - DEBUG - Importing FitsImagePlugin
2024-11-05 15:44:39,913 - DEBUG - Importing FliImagePlugin
2024-11-05 15:44:39,913 - DEBUG - Importing FpxImagePlugin
2024-11-05 15:44:39,914 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 15:44:39,914 - DEBUG - Importing FtexImagePlugin
2024-11-05 15:44:39,915 - DEBUG - Importing GbrImagePlugin
2024-11-05 15:44:39,916 - DEBUG - Importing GifImagePlugin
2024-11-05 15:44:39,916 - DEBUG - Importing GribStubImagePlugin
2024-11-05 15:44:39,916 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 15:44:39,917 - DEBUG - Importing IcnsImagePlugin
2024-11-05 15:44:39,918 - DEBUG - Importing IcoImagePlugin
2024-11-05 15:44:39,919 - DEBUG - Importing ImImagePlugin
2024-11-05 15:44:39,919 - DEBUG - Importing ImtImagePlugin
2024-11-05 15:44:39,920 - DEBUG - Importing IptcImagePlugin
2024-11-05 15:44:39,921 - DEBUG - Importing JpegImagePlugin
2024-11-05 15:44:39,921 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 15:44:39,921 - DEBUG - Importing McIdasImagePlugin
2024-11-05 15:44:39,921 - DEBUG - Importing MicImagePlugin
2024-11-05 15:44:39,922 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 15:44:39,922 - DEBUG - Importing MpegImagePlugin
2024-11-05 15:44:39,923 - DEBUG - Importing MpoImagePlugin
2024-11-05 15:44:39,928 - DEBUG - Importing MspImagePlugin
2024-11-05 15:44:39,928 - DEBUG - Importing PalmImagePlugin
2024-11-05 15:44:39,929 - DEBUG - Importing PcdImagePlugin
2024-11-05 15:44:39,929 - DEBUG - Importing PcxImagePlugin
2024-11-05 15:44:39,929 - DEBUG - Importing PdfImagePlugin
2024-11-05 15:44:39,933 - DEBUG - Importing PixarImagePlugin
2024-11-05 15:44:39,934 - DEBUG - Importing PngImagePlugin
2024-11-05 15:44:39,934 - DEBUG - Importing PpmImagePlugin
2024-11-05 15:44:39,934 - DEBUG - Importing PsdImagePlugin
2024-11-05 15:44:39,934 - DEBUG - Importing QoiImagePlugin
2024-11-05 15:44:39,934 - DEBUG - Importing SgiImagePlugin
2024-11-05 15:44:39,935 - DEBUG - Importing SpiderImagePlugin
2024-11-05 15:44:39,935 - DEBUG - Importing SunImagePlugin
2024-11-05 15:44:39,936 - DEBUG - Importing TgaImagePlugin
2024-11-05 15:44:39,936 - DEBUG - Importing TiffImagePlugin
2024-11-05 15:44:39,936 - DEBUG - Importing WebPImagePlugin
2024-11-05 15:44:39,937 - DEBUG - Importing WmfImagePlugin
2024-11-05 15:44:39,937 - DEBUG - Importing XbmImagePlugin
2024-11-05 15:44:39,938 - DEBUG - Importing XpmImagePlugin
2024-11-05 15:44:39,938 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 15:45:32,393 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 15:45:32,393 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 15:45:32,393 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 15:45:32,393 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 15:45:32,849 - DEBUG - Importing BlpImagePlugin
2024-11-05 15:45:32,850 - DEBUG - Importing BmpImagePlugin
2024-11-05 15:45:32,850 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 15:45:32,851 - DEBUG - Importing CurImagePlugin
2024-11-05 15:45:32,851 - DEBUG - Importing DcxImagePlugin
2024-11-05 15:45:32,852 - DEBUG - Importing DdsImagePlugin
2024-11-05 15:45:32,855 - DEBUG - Importing EpsImagePlugin
2024-11-05 15:45:32,856 - DEBUG - Importing FitsImagePlugin
2024-11-05 15:45:32,857 - DEBUG - Importing FliImagePlugin
2024-11-05 15:45:32,858 - DEBUG - Importing FpxImagePlugin
2024-11-05 15:45:32,859 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 15:45:32,859 - DEBUG - Importing FtexImagePlugin
2024-11-05 15:45:32,859 - DEBUG - Importing GbrImagePlugin
2024-11-05 15:45:32,860 - DEBUG - Importing GifImagePlugin
2024-11-05 15:45:32,860 - DEBUG - Importing GribStubImagePlugin
2024-11-05 15:45:32,860 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 15:45:32,861 - DEBUG - Importing IcnsImagePlugin
2024-11-05 15:45:32,862 - DEBUG - Importing IcoImagePlugin
2024-11-05 15:45:32,862 - DEBUG - Importing ImImagePlugin
2024-11-05 15:45:32,863 - DEBUG - Importing ImtImagePlugin
2024-11-05 15:45:32,864 - DEBUG - Importing IptcImagePlugin
2024-11-05 15:45:32,864 - DEBUG - Importing JpegImagePlugin
2024-11-05 15:45:32,864 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 15:45:32,864 - DEBUG - Importing McIdasImagePlugin
2024-11-05 15:45:32,864 - DEBUG - Importing MicImagePlugin
2024-11-05 15:45:32,865 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 15:45:32,865 - DEBUG - Importing MpegImagePlugin
2024-11-05 15:45:32,865 - DEBUG - Importing MpoImagePlugin
2024-11-05 15:45:32,870 - DEBUG - Importing MspImagePlugin
2024-11-05 15:45:32,870 - DEBUG - Importing PalmImagePlugin
2024-11-05 15:45:32,871 - DEBUG - Importing PcdImagePlugin
2024-11-05 15:45:32,871 - DEBUG - Importing PcxImagePlugin
2024-11-05 15:45:32,871 - DEBUG - Importing PdfImagePlugin
2024-11-05 15:45:32,875 - DEBUG - Importing PixarImagePlugin
2024-11-05 15:45:32,876 - DEBUG - Importing PngImagePlugin
2024-11-05 15:45:32,876 - DEBUG - Importing PpmImagePlugin
2024-11-05 15:45:32,876 - DEBUG - Importing PsdImagePlugin
2024-11-05 15:45:32,877 - DEBUG - Importing QoiImagePlugin
2024-11-05 15:45:32,877 - DEBUG - Importing SgiImagePlugin
2024-11-05 15:45:32,878 - DEBUG - Importing SpiderImagePlugin
2024-11-05 15:45:32,878 - DEBUG - Importing SunImagePlugin
2024-11-05 15:45:32,878 - DEBUG - Importing TgaImagePlugin
2024-11-05 15:45:32,879 - DEBUG - Importing TiffImagePlugin
2024-11-05 15:45:32,879 - DEBUG - Importing WebPImagePlugin
2024-11-05 15:45:32,880 - DEBUG - Importing WmfImagePlugin
2024-11-05 15:45:32,880 - DEBUG - Importing XbmImagePlugin
2024-11-05 15:45:32,881 - DEBUG - Importing XpmImagePlugin
2024-11-05 15:45:32,881 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 15:45:35,395 - DEBUG - Listening for clipboard updates on port 5000...
2024-11-05 15:45:35,395 - DEBUG - Listening for connection requests on port 6001...
2024-11-05 15:45:35,396 - DEBUG - Listening for connection responses on port 6002...
2024-11-05 15:45:35,396 - DEBUG - Listening for username updates on port 5003...
2024-11-05 15:45:35,442 - DEBUG - Broadcasting clipboard content: netstat -ano | findstr :5000

2024-11-05 15:45:48,986 - DEBUG - Sent connection request to 192.168.1.26:6001
2024-11-05 15:45:48,986 - ERROR - Error sending connection request: [WinError 10048] Only one usage of each socket address (protocol/network address/port) is normally permitted
2024-11-05 15:46:25,341 - DEBUG - Broadcasting clipboard content: netstat -ano | findstr:5000
2024-11-05 15:46:44,347 - DEBUG - Sent connection request to 192.168.1.26:6001
2024-11-05 15:46:44,347 - ERROR - Error sending connection request: [WinError 10048] Only one usage of each socket address (protocol/network address/port) is normally permitted
2024-11-05 15:46:53,071 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 15:46:53,071 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 15:46:53,071 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 15:46:53,071 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 15:46:53,528 - DEBUG - Importing BlpImagePlugin
2024-11-05 15:46:53,528 - DEBUG - Importing BmpImagePlugin
2024-11-05 15:46:53,528 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 15:46:53,529 - DEBUG - Importing CurImagePlugin
2024-11-05 15:46:53,529 - DEBUG - Importing DcxImagePlugin
2024-11-05 15:46:53,530 - DEBUG - Importing DdsImagePlugin
2024-11-05 15:46:53,533 - DEBUG - Importing EpsImagePlugin
2024-11-05 15:46:53,534 - DEBUG - Importing FitsImagePlugin
2024-11-05 15:46:53,535 - DEBUG - Importing FliImagePlugin
2024-11-05 15:46:53,536 - DEBUG - Importing FpxImagePlugin
2024-11-05 15:46:53,536 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 15:46:53,537 - DEBUG - Importing FtexImagePlugin
2024-11-05 15:46:53,537 - DEBUG - Importing GbrImagePlugin
2024-11-05 15:46:53,537 - DEBUG - Importing GifImagePlugin
2024-11-05 15:46:53,538 - DEBUG - Importing GribStubImagePlugin
2024-11-05 15:46:53,538 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 15:46:53,539 - DEBUG - Importing IcnsImagePlugin
2024-11-05 15:46:53,540 - DEBUG - Importing IcoImagePlugin
2024-11-05 15:46:53,541 - DEBUG - Importing ImImagePlugin
2024-11-05 15:46:53,542 - DEBUG - Importing ImtImagePlugin
2024-11-05 15:46:53,542 - DEBUG - Importing IptcImagePlugin
2024-11-05 15:46:53,543 - DEBUG - Importing JpegImagePlugin
2024-11-05 15:46:53,543 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 15:46:53,543 - DEBUG - Importing McIdasImagePlugin
2024-11-05 15:46:53,544 - DEBUG - Importing MicImagePlugin
2024-11-05 15:46:53,545 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 15:46:53,545 - DEBUG - Importing MpegImagePlugin
2024-11-05 15:46:53,546 - DEBUG - Importing MpoImagePlugin
2024-11-05 15:46:53,551 - DEBUG - Importing MspImagePlugin
2024-11-05 15:46:53,551 - DEBUG - Importing PalmImagePlugin
2024-11-05 15:46:53,552 - DEBUG - Importing PcdImagePlugin
2024-11-05 15:46:53,552 - DEBUG - Importing PcxImagePlugin
2024-11-05 15:46:53,553 - DEBUG - Importing PdfImagePlugin
2024-11-05 15:46:53,557 - DEBUG - Importing PixarImagePlugin
2024-11-05 15:46:53,557 - DEBUG - Importing PngImagePlugin
2024-11-05 15:46:53,557 - DEBUG - Importing PpmImagePlugin
2024-11-05 15:46:53,557 - DEBUG - Importing PsdImagePlugin
2024-11-05 15:46:53,558 - DEBUG - Importing QoiImagePlugin
2024-11-05 15:46:53,558 - DEBUG - Importing SgiImagePlugin
2024-11-05 15:46:53,559 - DEBUG - Importing SpiderImagePlugin
2024-11-05 15:46:53,559 - DEBUG - Importing SunImagePlugin
2024-11-05 15:46:53,560 - DEBUG - Importing TgaImagePlugin
2024-11-05 15:46:53,560 - DEBUG - Importing TiffImagePlugin
2024-11-05 15:46:53,560 - DEBUG - Importing WebPImagePlugin
2024-11-05 15:46:53,561 - DEBUG - Importing WmfImagePlugin
2024-11-05 15:46:53,562 - DEBUG - Importing XbmImagePlugin
2024-11-05 15:46:53,562 - DEBUG - Importing XpmImagePlugin
2024-11-05 15:46:53,563 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 15:47:01,707 - DEBUG - Listening for clipboard updates on port 5002...
2024-11-05 15:47:01,707 - DEBUG - Listening for connection requests on port 6001...
2024-11-05 15:47:01,708 - DEBUG - Listening for connection responses on port 6002...
2024-11-05 15:47:01,708 - DEBUG - Listening for username updates on port 5003...
2024-11-05 15:47:01,781 - DEBUG - Broadcasting clipboard content: netstat -ano | findstr:5000
2024-11-05 15:47:17,209 - DEBUG - Sent connection request to 192.168.1.26:6001
2024-11-05 15:47:17,210 - ERROR - Error sending connection request: [WinError 10048] Only one usage of each socket address (protocol/network address/port) is normally permitted
2024-11-05 16:16:32,682 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 16:16:32,682 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 16:16:32,682 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 16:16:32,682 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 16:16:55,677 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 16:16:55,677 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 16:16:55,677 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 16:16:55,677 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 16:16:56,137 - DEBUG - Importing BlpImagePlugin
2024-11-05 16:16:56,138 - DEBUG - Importing BmpImagePlugin
2024-11-05 16:16:56,138 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 16:16:56,139 - DEBUG - Importing CurImagePlugin
2024-11-05 16:16:56,139 - DEBUG - Importing DcxImagePlugin
2024-11-05 16:16:56,140 - DEBUG - Importing DdsImagePlugin
2024-11-05 16:16:56,143 - DEBUG - Importing EpsImagePlugin
2024-11-05 16:16:56,144 - DEBUG - Importing FitsImagePlugin
2024-11-05 16:16:56,145 - DEBUG - Importing FliImagePlugin
2024-11-05 16:16:56,146 - DEBUG - Importing FpxImagePlugin
2024-11-05 16:16:56,146 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 16:16:56,147 - DEBUG - Importing FtexImagePlugin
2024-11-05 16:16:56,147 - DEBUG - Importing GbrImagePlugin
2024-11-05 16:16:56,148 - DEBUG - Importing GifImagePlugin
2024-11-05 16:16:56,148 - DEBUG - Importing GribStubImagePlugin
2024-11-05 16:16:56,148 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 16:16:56,149 - DEBUG - Importing IcnsImagePlugin
2024-11-05 16:16:56,149 - DEBUG - Importing IcoImagePlugin
2024-11-05 16:16:56,150 - DEBUG - Importing ImImagePlugin
2024-11-05 16:16:56,151 - DEBUG - Importing ImtImagePlugin
2024-11-05 16:16:56,151 - DEBUG - Importing IptcImagePlugin
2024-11-05 16:16:56,152 - DEBUG - Importing JpegImagePlugin
2024-11-05 16:16:56,152 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 16:16:56,152 - DEBUG - Importing McIdasImagePlugin
2024-11-05 16:16:56,152 - DEBUG - Importing MicImagePlugin
2024-11-05 16:16:56,153 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 16:16:56,153 - DEBUG - Importing MpegImagePlugin
2024-11-05 16:16:56,153 - DEBUG - Importing MpoImagePlugin
2024-11-05 16:16:56,158 - DEBUG - Importing MspImagePlugin
2024-11-05 16:16:56,158 - DEBUG - Importing PalmImagePlugin
2024-11-05 16:16:56,159 - DEBUG - Importing PcdImagePlugin
2024-11-05 16:16:56,159 - DEBUG - Importing PcxImagePlugin
2024-11-05 16:16:56,159 - DEBUG - Importing PdfImagePlugin
2024-11-05 16:16:56,164 - DEBUG - Importing PixarImagePlugin
2024-11-05 16:16:56,164 - DEBUG - Importing PngImagePlugin
2024-11-05 16:16:56,164 - DEBUG - Importing PpmImagePlugin
2024-11-05 16:16:56,164 - DEBUG - Importing PsdImagePlugin
2024-11-05 16:16:56,165 - DEBUG - Importing QoiImagePlugin
2024-11-05 16:16:56,165 - DEBUG - Importing SgiImagePlugin
2024-11-05 16:16:56,166 - DEBUG - Importing SpiderImagePlugin
2024-11-05 16:16:56,166 - DEBUG - Importing SunImagePlugin
2024-11-05 16:16:56,166 - DEBUG - Importing TgaImagePlugin
2024-11-05 16:16:56,167 - DEBUG - Importing TiffImagePlugin
2024-11-05 16:16:56,167 - DEBUG - Importing WebPImagePlugin
2024-11-05 16:16:56,167 - DEBUG - Importing WmfImagePlugin
2024-11-05 16:16:56,168 - DEBUG - Importing XbmImagePlugin
2024-11-05 16:16:56,168 - DEBUG - Importing XpmImagePlugin
2024-11-05 16:16:56,169 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 16:17:01,417 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 16:17:01,417 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 16:17:01,417 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 16:17:01,417 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 16:17:01,866 - DEBUG - Importing BlpImagePlugin
2024-11-05 16:17:01,867 - DEBUG - Importing BmpImagePlugin
2024-11-05 16:17:01,867 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 16:17:01,867 - DEBUG - Importing CurImagePlugin
2024-11-05 16:17:01,868 - DEBUG - Importing DcxImagePlugin
2024-11-05 16:17:01,869 - DEBUG - Importing DdsImagePlugin
2024-11-05 16:17:01,871 - DEBUG - Importing EpsImagePlugin
2024-11-05 16:17:01,872 - DEBUG - Importing FitsImagePlugin
2024-11-05 16:17:01,874 - DEBUG - Importing FliImagePlugin
2024-11-05 16:17:01,874 - DEBUG - Importing FpxImagePlugin
2024-11-05 16:17:01,875 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 16:17:01,875 - DEBUG - Importing FtexImagePlugin
2024-11-05 16:17:01,875 - DEBUG - Importing GbrImagePlugin
2024-11-05 16:17:01,876 - DEBUG - Importing GifImagePlugin
2024-11-05 16:17:01,876 - DEBUG - Importing GribStubImagePlugin
2024-11-05 16:17:01,876 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 16:17:01,877 - DEBUG - Importing IcnsImagePlugin
2024-11-05 16:17:01,878 - DEBUG - Importing IcoImagePlugin
2024-11-05 16:17:01,879 - DEBUG - Importing ImImagePlugin
2024-11-05 16:17:01,879 - DEBUG - Importing ImtImagePlugin
2024-11-05 16:17:01,880 - DEBUG - Importing IptcImagePlugin
2024-11-05 16:17:01,880 - DEBUG - Importing JpegImagePlugin
2024-11-05 16:17:01,880 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 16:17:01,880 - DEBUG - Importing McIdasImagePlugin
2024-11-05 16:17:01,881 - DEBUG - Importing MicImagePlugin
2024-11-05 16:17:01,881 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 16:17:01,881 - DEBUG - Importing MpegImagePlugin
2024-11-05 16:17:01,882 - DEBUG - Importing MpoImagePlugin
2024-11-05 16:17:01,886 - DEBUG - Importing MspImagePlugin
2024-11-05 16:17:01,886 - DEBUG - Importing PalmImagePlugin
2024-11-05 16:17:01,887 - DEBUG - Importing PcdImagePlugin
2024-11-05 16:17:01,887 - DEBUG - Importing PcxImagePlugin
2024-11-05 16:17:01,887 - DEBUG - Importing PdfImagePlugin
2024-11-05 16:17:01,892 - DEBUG - Importing PixarImagePlugin
2024-11-05 16:17:01,892 - DEBUG - Importing PngImagePlugin
2024-11-05 16:17:01,892 - DEBUG - Importing PpmImagePlugin
2024-11-05 16:17:01,892 - DEBUG - Importing PsdImagePlugin
2024-11-05 16:17:01,893 - DEBUG - Importing QoiImagePlugin
2024-11-05 16:17:01,893 - DEBUG - Importing SgiImagePlugin
2024-11-05 16:17:01,893 - DEBUG - Importing SpiderImagePlugin
2024-11-05 16:17:01,894 - DEBUG - Importing SunImagePlugin
2024-11-05 16:17:01,894 - DEBUG - Importing TgaImagePlugin
2024-11-05 16:17:01,895 - DEBUG - Importing TiffImagePlugin
2024-11-05 16:17:01,895 - DEBUG - Importing WebPImagePlugin
2024-11-05 16:17:01,896 - DEBUG - Importing WmfImagePlugin
2024-11-05 16:17:01,896 - DEBUG - Importing XbmImagePlugin
2024-11-05 16:17:01,897 - DEBUG - Importing XpmImagePlugin
2024-11-05 16:17:01,897 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 16:17:03,587 - DEBUG - Listening for clipboard updates on port 5000...
2024-11-05 16:17:03,587 - DEBUG - Listening for connection requests on port 6001...
2024-11-05 16:17:03,588 - DEBUG - Listening for connection responses on port 6002...
2024-11-05 16:17:03,588 - DEBUG - Listening for username updates on port 5003...
2024-11-05 16:17:03,638 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes
import pystray  # For system tray integration
from pystray import MenuItem as item
import PIL.Image  # For creating tray icon images

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_UPDATE_PORT = 5003  # Port for username updates
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except socket.error as e:
                if e.errno == socket.errno.EADDRINUSE:
                    continue  # Port is in use, check the next one
    raise Exception("No free ports available in the specified range.")

def set_port():
    global PORT
    if PORT is None:
        PORT = find_free_port()
    else:
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', port_num))
                        PORT = port_num
                    except socket.error as e:
                        if e.errno == 10048:
                            # Handle Error 10048: Only one usage per socket address
                            custom_error_popup("Port In Use",
                                               f"Port {port_num} is already in use. Please choose another port.")
                            logging.error(f"Port {port_num} is already in use.")
                            PORT = None
                            return
                        else:
                            raise
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
            except Exception as e:
                custom_error_popup("Port Error", f"An unexpected error occurred: {e}")
                logging.error(f"Unexpected error when setting port: {e}")
                PORT = None
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
    # Update the IP label
    ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
    # Disable the port entry and button after setting
    port_entry.config(state='disabled')
    set_port_button.config(state='disabled')
    # Start threads after setting port
    start_threads()
    # Enable the Set Username button
    set_username_button.config(state='normal')

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, info['port']))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if (target_ip == local_ip and target_port == PORT) or (target_ip == local_ip and target_port == RESPONSE_PORT):
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_sock.bind(('', RESPONSE_PORT))
                    response_message, _ = response_sock.recvfrom(1024)
                    if response_message.startswith(b"CONNECTION_ACCEPTED:"):
                        responder_username = response_message.decode('utf-8').split(':', 1)[1]
                        # Add the responder to TARGET_USERS
                        TARGET_USERS[target_ip] = {'port': PORT, 'copy_count': 0, 'username': responder_username}
                        USER_STATS[target_ip] = 0
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{PORT}")
                        messagebox.showinfo("Connection Success",
                                            f"Now sharing vibes with '{responder_username}' at {target_ip}:{PORT}!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(responder_username, f"Connected from {target_ip}:{PORT}")
                        # Send current username to the new connection
                        send_username_update(target_ip, PORT)
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            if isinstance(e, socket.error) and e.errno == 10048:
                # Handle Error 10048: Only one usage per socket address
                custom_error_popup("Port In Use",
                                   f"Port {PORT} is already in use. Please set a different port.")
            else:
                custom_error_popup("Error", f"Failed to send connection request: {e}")

# The rest of the functions are identical in purpose and can be continued in the same way.

2024-11-05 16:17:13,838 - DEBUG - Sent connection request to 192.168.1.26:6001
2024-11-05 16:17:13,838 - ERROR - Error sending connection request: [WinError 10048] Only one usage of each socket address (protocol/network address/port) is normally permitted
2024-11-05 16:30:11,957 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 16:30:11,957 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 16:30:11,957 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 16:30:11,957 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 16:30:12,409 - DEBUG - Importing BlpImagePlugin
2024-11-05 16:30:12,410 - DEBUG - Importing BmpImagePlugin
2024-11-05 16:30:12,410 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 16:30:12,411 - DEBUG - Importing CurImagePlugin
2024-11-05 16:30:12,411 - DEBUG - Importing DcxImagePlugin
2024-11-05 16:30:12,413 - DEBUG - Importing DdsImagePlugin
2024-11-05 16:30:12,416 - DEBUG - Importing EpsImagePlugin
2024-11-05 16:30:12,416 - DEBUG - Importing FitsImagePlugin
2024-11-05 16:30:12,418 - DEBUG - Importing FliImagePlugin
2024-11-05 16:30:12,418 - DEBUG - Importing FpxImagePlugin
2024-11-05 16:30:12,419 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 16:30:12,419 - DEBUG - Importing FtexImagePlugin
2024-11-05 16:30:12,420 - DEBUG - Importing GbrImagePlugin
2024-11-05 16:30:12,420 - DEBUG - Importing GifImagePlugin
2024-11-05 16:30:12,420 - DEBUG - Importing GribStubImagePlugin
2024-11-05 16:30:12,421 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 16:30:12,421 - DEBUG - Importing IcnsImagePlugin
2024-11-05 16:30:12,422 - DEBUG - Importing IcoImagePlugin
2024-11-05 16:30:12,423 - DEBUG - Importing ImImagePlugin
2024-11-05 16:30:12,424 - DEBUG - Importing ImtImagePlugin
2024-11-05 16:30:12,424 - DEBUG - Importing IptcImagePlugin
2024-11-05 16:30:12,425 - DEBUG - Importing JpegImagePlugin
2024-11-05 16:30:12,425 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 16:30:12,425 - DEBUG - Importing McIdasImagePlugin
2024-11-05 16:30:12,426 - DEBUG - Importing MicImagePlugin
2024-11-05 16:30:12,426 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 16:30:12,427 - DEBUG - Importing MpegImagePlugin
2024-11-05 16:30:12,427 - DEBUG - Importing MpoImagePlugin
2024-11-05 16:30:12,433 - DEBUG - Importing MspImagePlugin
2024-11-05 16:30:12,433 - DEBUG - Importing PalmImagePlugin
2024-11-05 16:30:12,434 - DEBUG - Importing PcdImagePlugin
2024-11-05 16:30:12,434 - DEBUG - Importing PcxImagePlugin
2024-11-05 16:30:12,434 - DEBUG - Importing PdfImagePlugin
2024-11-05 16:30:12,439 - DEBUG - Importing PixarImagePlugin
2024-11-05 16:30:12,439 - DEBUG - Importing PngImagePlugin
2024-11-05 16:30:12,439 - DEBUG - Importing PpmImagePlugin
2024-11-05 16:30:12,439 - DEBUG - Importing PsdImagePlugin
2024-11-05 16:30:12,440 - DEBUG - Importing QoiImagePlugin
2024-11-05 16:30:12,440 - DEBUG - Importing SgiImagePlugin
2024-11-05 16:30:12,440 - DEBUG - Importing SpiderImagePlugin
2024-11-05 16:30:12,441 - DEBUG - Importing SunImagePlugin
2024-11-05 16:30:12,441 - DEBUG - Importing TgaImagePlugin
2024-11-05 16:30:12,441 - DEBUG - Importing TiffImagePlugin
2024-11-05 16:30:12,442 - DEBUG - Importing WebPImagePlugin
2024-11-05 16:30:12,442 - DEBUG - Importing WmfImagePlugin
2024-11-05 16:30:12,443 - DEBUG - Importing XbmImagePlugin
2024-11-05 16:30:12,443 - DEBUG - Importing XpmImagePlugin
2024-11-05 16:30:12,444 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 16:30:15,650 - DEBUG - Listening for clipboard updates on port 5000...
2024-11-05 16:30:15,650 - DEBUG - Listening for connection requests on port 6001...
2024-11-05 16:30:15,651 - DEBUG - Listening for connection responses on port 6002...
2024-11-05 16:30:15,651 - DEBUG - Listening for username updates on port 5003...
2024-11-05 16:34:03,720 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 16:34:03,720 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 16:34:03,721 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 16:34:03,721 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 16:34:04,179 - DEBUG - Importing BlpImagePlugin
2024-11-05 16:34:04,180 - DEBUG - Importing BmpImagePlugin
2024-11-05 16:34:04,180 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 16:34:04,181 - DEBUG - Importing CurImagePlugin
2024-11-05 16:34:04,181 - DEBUG - Importing DcxImagePlugin
2024-11-05 16:34:04,182 - DEBUG - Importing DdsImagePlugin
2024-11-05 16:34:04,185 - DEBUG - Importing EpsImagePlugin
2024-11-05 16:34:04,185 - DEBUG - Importing FitsImagePlugin
2024-11-05 16:34:04,187 - DEBUG - Importing FliImagePlugin
2024-11-05 16:34:04,187 - DEBUG - Importing FpxImagePlugin
2024-11-05 16:34:04,188 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 16:34:04,188 - DEBUG - Importing FtexImagePlugin
2024-11-05 16:34:04,188 - DEBUG - Importing GbrImagePlugin
2024-11-05 16:34:04,189 - DEBUG - Importing GifImagePlugin
2024-11-05 16:34:04,189 - DEBUG - Importing GribStubImagePlugin
2024-11-05 16:34:04,189 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 16:34:04,190 - DEBUG - Importing IcnsImagePlugin
2024-11-05 16:34:04,191 - DEBUG - Importing IcoImagePlugin
2024-11-05 16:34:04,192 - DEBUG - Importing ImImagePlugin
2024-11-05 16:34:04,193 - DEBUG - Importing ImtImagePlugin
2024-11-05 16:34:04,193 - DEBUG - Importing IptcImagePlugin
2024-11-05 16:34:04,193 - DEBUG - Importing JpegImagePlugin
2024-11-05 16:34:04,193 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 16:34:04,194 - DEBUG - Importing McIdasImagePlugin
2024-11-05 16:34:04,194 - DEBUG - Importing MicImagePlugin
2024-11-05 16:34:04,194 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 16:34:04,194 - DEBUG - Importing MpegImagePlugin
2024-11-05 16:34:04,195 - DEBUG - Importing MpoImagePlugin
2024-11-05 16:34:04,199 - DEBUG - Importing MspImagePlugin
2024-11-05 16:34:04,200 - DEBUG - Importing PalmImagePlugin
2024-11-05 16:34:04,200 - DEBUG - Importing PcdImagePlugin
2024-11-05 16:34:04,200 - DEBUG - Importing PcxImagePlugin
2024-11-05 16:34:04,201 - DEBUG - Importing PdfImagePlugin
2024-11-05 16:34:04,204 - DEBUG - Importing PixarImagePlugin
2024-11-05 16:34:04,205 - DEBUG - Importing PngImagePlugin
2024-11-05 16:34:04,205 - DEBUG - Importing PpmImagePlugin
2024-11-05 16:34:04,205 - DEBUG - Importing PsdImagePlugin
2024-11-05 16:34:04,205 - DEBUG - Importing QoiImagePlugin
2024-11-05 16:34:04,206 - DEBUG - Importing SgiImagePlugin
2024-11-05 16:34:04,206 - DEBUG - Importing SpiderImagePlugin
2024-11-05 16:34:04,206 - DEBUG - Importing SunImagePlugin
2024-11-05 16:34:04,207 - DEBUG - Importing TgaImagePlugin
2024-11-05 16:34:04,207 - DEBUG - Importing TiffImagePlugin
2024-11-05 16:34:04,207 - DEBUG - Importing WebPImagePlugin
2024-11-05 16:34:04,208 - DEBUG - Importing WmfImagePlugin
2024-11-05 16:34:04,209 - DEBUG - Importing XbmImagePlugin
2024-11-05 16:34:04,209 - DEBUG - Importing XpmImagePlugin
2024-11-05 16:34:04,209 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 16:34:11,491 - DEBUG - Listening for clipboard updates on port 5000...
2024-11-05 16:34:11,492 - DEBUG - Listening for connection requests on port 15412...
2024-11-05 16:34:11,492 - DEBUG - Listening for connection responses on port 15413...
2024-11-05 16:34:11,493 - DEBUG - Listening for username updates on port 5003...
2024-11-05 16:34:23,261 - DEBUG - Received connection request from 192.168.1.26:65426: REQUEST_CONNECTION:15411
2024-11-05 16:34:25,836 - DEBUG - Accepted connection from 192.168.1.26:15411
2024-11-05 16:34:25,839 - ERROR - Error handling connection request: name 'log_activity' is not defined
2024-11-05 16:35:50,389 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 16:35:50,389 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 16:35:50,389 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 16:35:50,390 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 16:35:50,868 - DEBUG - Importing BlpImagePlugin
2024-11-05 16:35:50,869 - DEBUG - Importing BmpImagePlugin
2024-11-05 16:35:50,869 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 16:35:50,869 - DEBUG - Importing CurImagePlugin
2024-11-05 16:35:50,870 - DEBUG - Importing DcxImagePlugin
2024-11-05 16:35:50,871 - DEBUG - Importing DdsImagePlugin
2024-11-05 16:35:50,873 - DEBUG - Importing EpsImagePlugin
2024-11-05 16:35:50,874 - DEBUG - Importing FitsImagePlugin
2024-11-05 16:35:50,875 - DEBUG - Importing FliImagePlugin
2024-11-05 16:35:50,875 - DEBUG - Importing FpxImagePlugin
2024-11-05 16:35:50,876 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 16:35:50,876 - DEBUG - Importing FtexImagePlugin
2024-11-05 16:35:50,877 - DEBUG - Importing GbrImagePlugin
2024-11-05 16:35:50,877 - DEBUG - Importing GifImagePlugin
2024-11-05 16:35:50,877 - DEBUG - Importing GribStubImagePlugin
2024-11-05 16:35:50,878 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 16:35:50,878 - DEBUG - Importing IcnsImagePlugin
2024-11-05 16:35:50,879 - DEBUG - Importing IcoImagePlugin
2024-11-05 16:35:50,880 - DEBUG - Importing ImImagePlugin
2024-11-05 16:35:50,880 - DEBUG - Importing ImtImagePlugin
2024-11-05 16:35:50,881 - DEBUG - Importing IptcImagePlugin
2024-11-05 16:35:50,881 - DEBUG - Importing JpegImagePlugin
2024-11-05 16:35:50,881 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 16:35:50,881 - DEBUG - Importing McIdasImagePlugin
2024-11-05 16:35:50,882 - DEBUG - Importing MicImagePlugin
2024-11-05 16:35:50,883 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 16:35:50,883 - DEBUG - Importing MpegImagePlugin
2024-11-05 16:35:50,883 - DEBUG - Importing MpoImagePlugin
2024-11-05 16:35:50,887 - DEBUG - Importing MspImagePlugin
2024-11-05 16:35:50,888 - DEBUG - Importing PalmImagePlugin
2024-11-05 16:35:50,888 - DEBUG - Importing PcdImagePlugin
2024-11-05 16:35:50,889 - DEBUG - Importing PcxImagePlugin
2024-11-05 16:35:50,889 - DEBUG - Importing PdfImagePlugin
2024-11-05 16:35:50,893 - DEBUG - Importing PixarImagePlugin
2024-11-05 16:35:50,894 - DEBUG - Importing PngImagePlugin
2024-11-05 16:35:50,894 - DEBUG - Importing PpmImagePlugin
2024-11-05 16:35:50,894 - DEBUG - Importing PsdImagePlugin
2024-11-05 16:35:50,895 - DEBUG - Importing QoiImagePlugin
2024-11-05 16:35:50,895 - DEBUG - Importing SgiImagePlugin
2024-11-05 16:35:50,896 - DEBUG - Importing SpiderImagePlugin
2024-11-05 16:35:50,896 - DEBUG - Importing SunImagePlugin
2024-11-05 16:35:50,897 - DEBUG - Importing TgaImagePlugin
2024-11-05 16:35:50,897 - DEBUG - Importing TiffImagePlugin
2024-11-05 16:35:50,897 - DEBUG - Importing WebPImagePlugin
2024-11-05 16:35:50,898 - DEBUG - Importing WmfImagePlugin
2024-11-05 16:35:50,898 - DEBUG - Importing XbmImagePlugin
2024-11-05 16:35:50,899 - DEBUG - Importing XpmImagePlugin
2024-11-05 16:35:50,899 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 16:37:49,774 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 16:37:49,774 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 16:37:49,774 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 16:37:49,775 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 16:37:50,244 - DEBUG - Importing BlpImagePlugin
2024-11-05 16:37:50,245 - DEBUG - Importing BmpImagePlugin
2024-11-05 16:37:50,245 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 16:37:50,246 - DEBUG - Importing CurImagePlugin
2024-11-05 16:37:50,246 - DEBUG - Importing DcxImagePlugin
2024-11-05 16:37:50,247 - DEBUG - Importing DdsImagePlugin
2024-11-05 16:37:50,250 - DEBUG - Importing EpsImagePlugin
2024-11-05 16:37:50,251 - DEBUG - Importing FitsImagePlugin
2024-11-05 16:37:50,252 - DEBUG - Importing FliImagePlugin
2024-11-05 16:37:50,252 - DEBUG - Importing FpxImagePlugin
2024-11-05 16:37:50,253 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 16:37:50,253 - DEBUG - Importing FtexImagePlugin
2024-11-05 16:37:50,254 - DEBUG - Importing GbrImagePlugin
2024-11-05 16:37:50,254 - DEBUG - Importing GifImagePlugin
2024-11-05 16:37:50,254 - DEBUG - Importing GribStubImagePlugin
2024-11-05 16:37:50,255 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 16:37:50,255 - DEBUG - Importing IcnsImagePlugin
2024-11-05 16:37:50,257 - DEBUG - Importing IcoImagePlugin
2024-11-05 16:37:50,257 - DEBUG - Importing ImImagePlugin
2024-11-05 16:37:50,258 - DEBUG - Importing ImtImagePlugin
2024-11-05 16:37:50,259 - DEBUG - Importing IptcImagePlugin
2024-11-05 16:37:50,259 - DEBUG - Importing JpegImagePlugin
2024-11-05 16:37:50,259 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 16:37:50,259 - DEBUG - Importing McIdasImagePlugin
2024-11-05 16:37:50,260 - DEBUG - Importing MicImagePlugin
2024-11-05 16:37:50,261 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 16:37:50,261 - DEBUG - Importing MpegImagePlugin
2024-11-05 16:37:50,261 - DEBUG - Importing MpoImagePlugin
2024-11-05 16:37:50,266 - DEBUG - Importing MspImagePlugin
2024-11-05 16:37:50,266 - DEBUG - Importing PalmImagePlugin
2024-11-05 16:37:50,267 - DEBUG - Importing PcdImagePlugin
2024-11-05 16:37:50,267 - DEBUG - Importing PcxImagePlugin
2024-11-05 16:37:50,267 - DEBUG - Importing PdfImagePlugin
2024-11-05 16:37:50,271 - DEBUG - Importing PixarImagePlugin
2024-11-05 16:37:50,272 - DEBUG - Importing PngImagePlugin
2024-11-05 16:37:50,272 - DEBUG - Importing PpmImagePlugin
2024-11-05 16:37:50,272 - DEBUG - Importing PsdImagePlugin
2024-11-05 16:37:50,272 - DEBUG - Importing QoiImagePlugin
2024-11-05 16:37:50,273 - DEBUG - Importing SgiImagePlugin
2024-11-05 16:37:50,273 - DEBUG - Importing SpiderImagePlugin
2024-11-05 16:37:50,273 - DEBUG - Importing SunImagePlugin
2024-11-05 16:37:50,274 - DEBUG - Importing TgaImagePlugin
2024-11-05 16:37:50,274 - DEBUG - Importing TiffImagePlugin
2024-11-05 16:37:50,274 - DEBUG - Importing WebPImagePlugin
2024-11-05 16:37:50,275 - DEBUG - Importing WmfImagePlugin
2024-11-05 16:37:50,275 - DEBUG - Importing XbmImagePlugin
2024-11-05 16:37:50,276 - DEBUG - Importing XpmImagePlugin
2024-11-05 16:37:50,276 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 16:59:49,368 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 16:59:49,369 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 16:59:49,369 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 16:59:49,369 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 16:59:49,834 - DEBUG - Importing BlpImagePlugin
2024-11-05 16:59:49,835 - DEBUG - Importing BmpImagePlugin
2024-11-05 16:59:49,836 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 16:59:49,836 - DEBUG - Importing CurImagePlugin
2024-11-05 16:59:49,837 - DEBUG - Importing DcxImagePlugin
2024-11-05 16:59:49,838 - DEBUG - Importing DdsImagePlugin
2024-11-05 16:59:49,840 - DEBUG - Importing EpsImagePlugin
2024-11-05 16:59:49,841 - DEBUG - Importing FitsImagePlugin
2024-11-05 16:59:49,843 - DEBUG - Importing FliImagePlugin
2024-11-05 16:59:49,843 - DEBUG - Importing FpxImagePlugin
2024-11-05 16:59:49,844 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 16:59:49,844 - DEBUG - Importing FtexImagePlugin
2024-11-05 16:59:49,845 - DEBUG - Importing GbrImagePlugin
2024-11-05 16:59:49,845 - DEBUG - Importing GifImagePlugin
2024-11-05 16:59:49,846 - DEBUG - Importing GribStubImagePlugin
2024-11-05 16:59:49,846 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 16:59:49,847 - DEBUG - Importing IcnsImagePlugin
2024-11-05 16:59:49,848 - DEBUG - Importing IcoImagePlugin
2024-11-05 16:59:49,848 - DEBUG - Importing ImImagePlugin
2024-11-05 16:59:49,849 - DEBUG - Importing ImtImagePlugin
2024-11-05 16:59:49,850 - DEBUG - Importing IptcImagePlugin
2024-11-05 16:59:49,850 - DEBUG - Importing JpegImagePlugin
2024-11-05 16:59:49,850 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 16:59:49,850 - DEBUG - Importing McIdasImagePlugin
2024-11-05 16:59:49,850 - DEBUG - Importing MicImagePlugin
2024-11-05 16:59:49,851 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 16:59:49,851 - DEBUG - Importing MpegImagePlugin
2024-11-05 16:59:49,851 - DEBUG - Importing MpoImagePlugin
2024-11-05 16:59:49,855 - DEBUG - Importing MspImagePlugin
2024-11-05 16:59:49,856 - DEBUG - Importing PalmImagePlugin
2024-11-05 16:59:49,856 - DEBUG - Importing PcdImagePlugin
2024-11-05 16:59:49,857 - DEBUG - Importing PcxImagePlugin
2024-11-05 16:59:49,857 - DEBUG - Importing PdfImagePlugin
2024-11-05 16:59:49,861 - DEBUG - Importing PixarImagePlugin
2024-11-05 16:59:49,862 - DEBUG - Importing PngImagePlugin
2024-11-05 16:59:49,862 - DEBUG - Importing PpmImagePlugin
2024-11-05 16:59:49,862 - DEBUG - Importing PsdImagePlugin
2024-11-05 16:59:49,862 - DEBUG - Importing QoiImagePlugin
2024-11-05 16:59:49,863 - DEBUG - Importing SgiImagePlugin
2024-11-05 16:59:49,863 - DEBUG - Importing SpiderImagePlugin
2024-11-05 16:59:49,864 - DEBUG - Importing SunImagePlugin
2024-11-05 16:59:49,864 - DEBUG - Importing TgaImagePlugin
2024-11-05 16:59:49,864 - DEBUG - Importing TiffImagePlugin
2024-11-05 16:59:49,864 - DEBUG - Importing WebPImagePlugin
2024-11-05 16:59:49,865 - DEBUG - Importing WmfImagePlugin
2024-11-05 16:59:49,865 - DEBUG - Importing XbmImagePlugin
2024-11-05 16:59:49,866 - DEBUG - Importing XpmImagePlugin
2024-11-05 16:59:49,866 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 17:00:23,003 - WARNING - User attempted to send connection request to themselves.
2024-11-05 17:00:34,761 - DEBUG - Sent connection request to 192.168.1.26:15411
2024-11-05 17:00:44,768 - DEBUG - No response from '192.168.1.26:15411'. Connection request timed out.
2024-11-05 17:05:53,950 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 17:05:53,950 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 17:05:53,950 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 17:05:53,950 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 17:05:54,426 - DEBUG - Listening for connection requests on port 15411...
2024-11-05 17:05:54,426 - DEBUG - Listening for clipboard updates on port 15412...
2024-11-05 17:05:54,426 - DEBUG - Listening for connection responses on port 15411...
2024-11-05 17:05:54,426 - DEBUG - Listening for username updates on port 15411...
2024-11-05 17:05:54,429 - DEBUG - Importing BlpImagePlugin
2024-11-05 17:05:54,430 - DEBUG - Importing BmpImagePlugin
2024-11-05 17:05:54,431 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 17:05:54,431 - DEBUG - Importing CurImagePlugin
2024-11-05 17:05:54,431 - DEBUG - Importing DcxImagePlugin
2024-11-05 17:05:54,433 - DEBUG - Importing DdsImagePlugin
2024-11-05 17:05:54,435 - DEBUG - Importing EpsImagePlugin
2024-11-05 17:05:54,436 - DEBUG - Importing FitsImagePlugin
2024-11-05 17:05:54,438 - DEBUG - Importing FliImagePlugin
2024-11-05 17:05:54,438 - DEBUG - Importing FpxImagePlugin
2024-11-05 17:05:54,439 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 17:05:54,439 - DEBUG - Importing FtexImagePlugin
2024-11-05 17:05:54,440 - DEBUG - Importing GbrImagePlugin
2024-11-05 17:05:54,440 - DEBUG - Importing GifImagePlugin
2024-11-05 17:05:54,440 - DEBUG - Importing GribStubImagePlugin
2024-11-05 17:05:54,441 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 17:05:54,441 - DEBUG - Importing IcnsImagePlugin
2024-11-05 17:05:54,442 - DEBUG - Importing IcoImagePlugin
2024-11-05 17:05:54,443 - DEBUG - Importing ImImagePlugin
2024-11-05 17:05:54,444 - DEBUG - Importing ImtImagePlugin
2024-11-05 17:05:54,444 - DEBUG - Importing IptcImagePlugin
2024-11-05 17:05:54,444 - DEBUG - Importing JpegImagePlugin
2024-11-05 17:05:54,445 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 17:05:54,445 - DEBUG - Importing McIdasImagePlugin
2024-11-05 17:05:54,445 - DEBUG - Importing MicImagePlugin
2024-11-05 17:05:54,446 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 17:05:54,446 - DEBUG - Importing MpegImagePlugin
2024-11-05 17:05:54,446 - DEBUG - Importing MpoImagePlugin
2024-11-05 17:05:54,451 - DEBUG - Importing MspImagePlugin
2024-11-05 17:05:54,451 - DEBUG - Importing PalmImagePlugin
2024-11-05 17:05:54,452 - DEBUG - Importing PcdImagePlugin
2024-11-05 17:05:54,452 - DEBUG - Importing PcxImagePlugin
2024-11-05 17:05:54,452 - DEBUG - Importing PdfImagePlugin
2024-11-05 17:05:54,456 - DEBUG - Importing PixarImagePlugin
2024-11-05 17:05:54,457 - DEBUG - Importing PngImagePlugin
2024-11-05 17:05:54,457 - DEBUG - Importing PpmImagePlugin
2024-11-05 17:05:54,457 - DEBUG - Importing PsdImagePlugin
2024-11-05 17:05:54,457 - DEBUG - Importing QoiImagePlugin
2024-11-05 17:05:54,458 - DEBUG - Importing SgiImagePlugin
2024-11-05 17:05:54,458 - DEBUG - Importing SpiderImagePlugin
2024-11-05 17:05:54,459 - DEBUG - Importing SunImagePlugin
2024-11-05 17:05:54,459 - DEBUG - Importing TgaImagePlugin
2024-11-05 17:05:54,459 - DEBUG - Importing TiffImagePlugin
2024-11-05 17:05:54,459 - DEBUG - Importing WebPImagePlugin
2024-11-05 17:05:54,460 - DEBUG - Importing WmfImagePlugin
2024-11-05 17:05:54,461 - DEBUG - Importing XbmImagePlugin
2024-11-05 17:05:54,461 - DEBUG - Importing XpmImagePlugin
2024-11-05 17:05:54,462 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 17:05:54,478 - DEBUG - Broadcasting clipboard content: start_threads()
2024-11-05 17:06:14,407 - DEBUG - Received connection request from 192.168.1.26:55584: REQUEST_CONNECTION:15411
2024-11-05 17:06:19,748 - DEBUG - Accepted connection from 192.168.1.26:15411
2024-11-05 17:06:19,749 - ERROR - Error handling connection request: name 'log_activity' is not defined
2024-11-05 17:10:46,007 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 17:10:46,007 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 17:10:46,007 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 17:10:46,007 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 17:10:46,453 - DEBUG - Listening for connection requests on port 15411...
2024-11-05 17:10:46,453 - DEBUG - Listening for clipboard updates on port 15412...
2024-11-05 17:10:46,453 - DEBUG - Listening for connection responses on port 15411...
2024-11-05 17:10:46,453 - DEBUG - Listening for username updates on port 15411...
2024-11-05 17:10:46,455 - DEBUG - Importing BlpImagePlugin
2024-11-05 17:10:46,456 - DEBUG - Importing BmpImagePlugin
2024-11-05 17:10:46,456 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 17:10:46,457 - DEBUG - Importing CurImagePlugin
2024-11-05 17:10:46,457 - DEBUG - Importing DcxImagePlugin
2024-11-05 17:10:46,459 - DEBUG - Importing DdsImagePlugin
2024-11-05 17:10:46,461 - DEBUG - Importing EpsImagePlugin
2024-11-05 17:10:46,462 - DEBUG - Importing FitsImagePlugin
2024-11-05 17:10:46,464 - DEBUG - Importing FliImagePlugin
2024-11-05 17:10:46,464 - DEBUG - Importing FpxImagePlugin
2024-11-05 17:10:46,465 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 17:10:46,465 - DEBUG - Importing FtexImagePlugin
2024-11-05 17:10:46,465 - DEBUG - Importing GbrImagePlugin
2024-11-05 17:10:46,466 - DEBUG - Importing GifImagePlugin
2024-11-05 17:10:46,466 - DEBUG - Importing GribStubImagePlugin
2024-11-05 17:10:46,466 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 17:10:46,467 - DEBUG - Importing IcnsImagePlugin
2024-11-05 17:10:46,468 - DEBUG - Importing IcoImagePlugin
2024-11-05 17:10:46,469 - DEBUG - Importing ImImagePlugin
2024-11-05 17:10:46,469 - DEBUG - Importing ImtImagePlugin
2024-11-05 17:10:46,470 - DEBUG - Importing IptcImagePlugin
2024-11-05 17:10:46,470 - DEBUG - Importing JpegImagePlugin
2024-11-05 17:10:46,470 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 17:10:46,470 - DEBUG - Importing McIdasImagePlugin
2024-11-05 17:10:46,471 - DEBUG - Importing MicImagePlugin
2024-11-05 17:10:46,471 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 17:10:46,471 - DEBUG - Importing MpegImagePlugin
2024-11-05 17:10:46,471 - DEBUG - Importing MpoImagePlugin
2024-11-05 17:10:46,476 - DEBUG - Importing MspImagePlugin
2024-11-05 17:10:46,476 - DEBUG - Importing PalmImagePlugin
2024-11-05 17:10:46,477 - DEBUG - Importing PcdImagePlugin
2024-11-05 17:10:46,477 - DEBUG - Importing PcxImagePlugin
2024-11-05 17:10:46,477 - DEBUG - Importing PdfImagePlugin
2024-11-05 17:10:46,481 - DEBUG - Importing PixarImagePlugin
2024-11-05 17:10:46,482 - DEBUG - Importing PngImagePlugin
2024-11-05 17:10:46,482 - DEBUG - Importing PpmImagePlugin
2024-11-05 17:10:46,482 - DEBUG - Importing PsdImagePlugin
2024-11-05 17:10:46,483 - DEBUG - Importing QoiImagePlugin
2024-11-05 17:10:46,483 - DEBUG - Importing SgiImagePlugin
2024-11-05 17:10:46,484 - DEBUG - Importing SpiderImagePlugin
2024-11-05 17:10:46,484 - DEBUG - Importing SunImagePlugin
2024-11-05 17:10:46,485 - DEBUG - Importing TgaImagePlugin
2024-11-05 17:10:46,485 - DEBUG - Importing TiffImagePlugin
2024-11-05 17:10:46,485 - DEBUG - Importing WebPImagePlugin
2024-11-05 17:10:46,486 - DEBUG - Importing WmfImagePlugin
2024-11-05 17:10:46,486 - DEBUG - Importing XbmImagePlugin
2024-11-05 17:10:46,487 - DEBUG - Importing XpmImagePlugin
2024-11-05 17:10:46,488 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 17:10:46,502 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import ImageDraw
from PIL import Image, ImageTk, ImageDraw
import ctypes
import logging  # For debugging purposes
import pystray  # For system tray integration
from pystray import MenuItem as item
import PIL.Image  # For creating tray icon images

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
CONNECTION_PORT = 15411  # Unified port for all connection-related tasks
CLIPBOARD_PORT = 15412   # Port for clipboard data transfer
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet


TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_USERS:
                            sock.sendto(message.encode('utf-8'), (ip, CLIPBOARD_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', CLIPBOARD_PORT))
            logging.debug(f"Listening for clipboard updates on port {CLIPBOARD_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CLIPBOARD_PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update copy count
                            if addr[0] in USER_STATS:
                                USER_STATS[addr[0]] += 1
                            else:
                                USER_STATS[addr[0]] = 1
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static CONNECTION_PORT
            sock.bind(('', CONNECTION_PORT))
            logging.debug(f"Listening for connection requests on port {CONNECTION_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CONNECTION_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == CONNECTION_PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), (addr[0], sender_response_port))
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_response_port, 'copy_count': 0, 'username': 'Unknown'}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_response_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_response_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_response_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on the static CONNECTION_PORT
            sock.bind(('', CONNECTION_PORT))
            logging.debug(f"Listening for connection responses on port {CONNECTION_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CONNECTION_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': CONNECTION_PORT, 'copy_count': 0, 'username': responder_username}
                    USER_STATS[addr[0]] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{CONNECTION_PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{CONNECTION_PORT}! ")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{CONNECTION_PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], CONNECTION_PORT)
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def handle_username_updates():
    # Create a UDP socket for listening to incoming username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for username updates on CONNECTION_PORT
            sock.bind(('', CONNECTION_PORT))
            logging.debug(f"Listening for username updates on port {CONNECTION_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CONNECTION_PORT} for username updates: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME_UPDATE:"):
                    _, new_username = received_message.split(':', 1)
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling username update: {e}")

def send_connection_request(target_ip):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{CONNECTION_PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, CONNECTION_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{CONNECTION_PORT}")
            # Wait for a response on the CONNECTION_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_sock.bind(('', CONNECTION_PORT))
                    response_message, _ = response_sock.recvfrom(1024)
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        responder_username = response_message.split(':', 1)[1]
                        # Add the responder to TARGET_USERS
                        TARGET_USERS[target_ip] = {'port': CONNECTION_PORT, 'copy_count': 0, 'username': responder_username}
                        USER_STATS[target_ip] = 0
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{CONNECTION_PORT}")
                        messagebox.showinfo("Connection Success",
                                            f"Now sharing vibes with '{responder_username}' at {target_ip}:{CONNECTION_PORT}!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(responder_username, f"Connected from {target_ip}:{CONNECTION_PORT}")
                        # Send current username to the new connection
                        send_username_update(target_ip, CONNECTION_PORT)
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{CONNECTION_PORT}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{CONNECTION_PORT}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            if isinstance(e, socket.error) and e.errno == 10048:
                # Handle Error 10048: Only one usage per socket address
                custom_error_popup("Port In Use",
                                   f"Port {CONNECTION_PORT} is already in use. Please set a different port.")
            else:
                custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, CONNECTION_PORT))
            logging.debug(f"Sent username update to {target_ip}:{CONNECTION_PORT}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to handle username updates
    threading.Thread(target=handle_username_updates, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, connected_users_tree, log_text, pause_button, tray_icon

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry (disabled since now using static ports)
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144", state='disabled')  # Disable port entry
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{CONNECTION_PORT}", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 15412
            invite_window.destroy()
            send_connection_request(target_ip)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip)

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            tray_icon.stop()  # Ensure tray icon is removed
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username is set."""
        if username:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username is set
    root.after(1000, check_ready)

    # Bind Enter key to Set Username button
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    # **Enhancement 3: Add a button to minimize to system tray**
    def minimize_to_tray():
        root.withdraw()
        tray_icon.visible = True

    # Create tray icon
    def create_tray_icon():
        image = PIL.Image.new('RGB', (64, 64), color='blue')
        draw = PIL.ImageDraw.Draw(image)
        draw.rectangle((0, 0, 64, 64), fill='blue')
        draw.text((10, 25), "CT", fill='white')  # Example text
        menu = (
            item('Restore', restore_window),
            item('Exit', exit_application)
        )
        tray = pystray.Icon("ClipHilarity Sync", image, "ClipHilarity Sync", menu)
        return tray

    def restore_window(icon, item):
        icon.visible = False
        root.deiconify()

    def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 17:11:02,858 - DEBUG - Received connection request from 192.168.1.26:52154: REQUEST_CONNECTION:15411
2024-11-05 17:11:10,380 - ERROR - Error handling connection request: name 'sender_response_port' is not defined
2024-11-05 17:11:37,673 - DEBUG - Sent connection request to 192.168.1.26:15411
2024-11-05 17:11:37,673 - ERROR - Error sending connection request: [WinError 10048] Only one usage of each socket address (protocol/network address/port) is normally permitted
2024-11-05 17:11:57,750 - DEBUG - Sent connection request to 192.168.1.26:15411
2024-11-05 17:11:57,750 - ERROR - Error sending connection request: [WinError 10048] Only one usage of each socket address (protocol/network address/port) is normally permitted
2024-11-05 17:23:21,432 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 17:23:21,432 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 17:23:21,432 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 17:23:21,432 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 17:23:21,886 - DEBUG - Listening for connection requests on port 15411...
2024-11-05 17:23:21,886 - DEBUG - Listening for clipboard updates on port 15412...
2024-11-05 17:23:21,887 - DEBUG - Listening for connection responses on port 15413...
2024-11-05 17:23:21,887 - DEBUG - Listening for username updates on port 15413...
2024-11-05 17:23:21,889 - DEBUG - Importing BlpImagePlugin
2024-11-05 17:23:21,890 - DEBUG - Importing BmpImagePlugin
2024-11-05 17:23:21,890 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 17:23:21,891 - DEBUG - Importing CurImagePlugin
2024-11-05 17:23:21,891 - DEBUG - Importing DcxImagePlugin
2024-11-05 17:23:21,892 - DEBUG - Importing DdsImagePlugin
2024-11-05 17:23:21,895 - DEBUG - Importing EpsImagePlugin
2024-11-05 17:23:21,895 - DEBUG - Importing FitsImagePlugin
2024-11-05 17:23:21,897 - DEBUG - Importing FliImagePlugin
2024-11-05 17:23:21,897 - DEBUG - Importing FpxImagePlugin
2024-11-05 17:23:21,898 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 17:23:21,898 - DEBUG - Importing FtexImagePlugin
2024-11-05 17:23:21,899 - DEBUG - Importing GbrImagePlugin
2024-11-05 17:23:21,899 - DEBUG - Importing GifImagePlugin
2024-11-05 17:23:21,899 - DEBUG - Importing GribStubImagePlugin
2024-11-05 17:23:21,900 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 17:23:21,900 - DEBUG - Importing IcnsImagePlugin
2024-11-05 17:23:21,901 - DEBUG - Importing IcoImagePlugin
2024-11-05 17:23:21,902 - DEBUG - Importing ImImagePlugin
2024-11-05 17:23:21,903 - DEBUG - Importing ImtImagePlugin
2024-11-05 17:23:21,903 - DEBUG - Importing IptcImagePlugin
2024-11-05 17:23:21,904 - DEBUG - Importing JpegImagePlugin
2024-11-05 17:23:21,904 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 17:23:21,904 - DEBUG - Importing McIdasImagePlugin
2024-11-05 17:23:21,904 - DEBUG - Importing MicImagePlugin
2024-11-05 17:23:21,905 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 17:23:21,905 - DEBUG - Importing MpegImagePlugin
2024-11-05 17:23:21,905 - DEBUG - Importing MpoImagePlugin
2024-11-05 17:23:21,910 - DEBUG - Importing MspImagePlugin
2024-11-05 17:23:21,910 - DEBUG - Importing PalmImagePlugin
2024-11-05 17:23:21,911 - DEBUG - Importing PcdImagePlugin
2024-11-05 17:23:21,911 - DEBUG - Importing PcxImagePlugin
2024-11-05 17:23:21,911 - DEBUG - Importing PdfImagePlugin
2024-11-05 17:23:21,916 - DEBUG - Importing PixarImagePlugin
2024-11-05 17:23:21,916 - DEBUG - Importing PngImagePlugin
2024-11-05 17:23:21,916 - DEBUG - Importing PpmImagePlugin
2024-11-05 17:23:21,916 - DEBUG - Importing PsdImagePlugin
2024-11-05 17:23:21,917 - DEBUG - Importing QoiImagePlugin
2024-11-05 17:23:21,917 - DEBUG - Importing SgiImagePlugin
2024-11-05 17:23:21,918 - DEBUG - Importing SpiderImagePlugin
2024-11-05 17:23:21,918 - DEBUG - Importing SunImagePlugin
2024-11-05 17:23:21,919 - DEBUG - Importing TgaImagePlugin
2024-11-05 17:23:21,919 - DEBUG - Importing TiffImagePlugin
2024-11-05 17:23:21,919 - DEBUG - Importing WebPImagePlugin
2024-11-05 17:23:21,920 - DEBUG - Importing WmfImagePlugin
2024-11-05 17:23:21,920 - DEBUG - Importing XbmImagePlugin
2024-11-05 17:23:21,921 - DEBUG - Importing XpmImagePlugin
2024-11-05 17:23:21,921 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 17:23:21,937 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import ImageDraw
from PIL import Image, ImageTk, ImageDraw
import ctypes
import logging  # For debugging purposes
import pystray  # For system tray integration
from pystray import MenuItem as item
import PIL.Image  # For creating tray icon images

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
LISTENING_PORT = 15411   # Port for continuously listening to incoming requests
SENDING_PORT = 15413     # Port for sending requests and receiving acknowledgments
CLIPBOARD_PORT = 15412   # Port for clipboard data transfer
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet


TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_USERS:
                            sock.sendto(message.encode('utf-8'), (ip, CLIPBOARD_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', CLIPBOARD_PORT))
            logging.debug(f"Listening for clipboard updates on port {CLIPBOARD_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CLIPBOARD_PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update copy count
                            if addr[0] in USER_STATS:
                                USER_STATS[addr[0]] += 1
                            else:
                                USER_STATS[addr[0]] = 1
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static LISTENING_PORT
            sock.bind(('', LISTENING_PORT))
            logging.debug(f"Listening for connection requests on port {LISTENING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {LISTENING_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == LISTENING_PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), (addr[0], sender_response_port))
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_response_port, 'copy_count': 0, 'username': 'Unknown'}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_response_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_response_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_response_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on the static SENDING_PORT
            sock.bind(('', SENDING_PORT))
            logging.debug(f"Listening for connection responses on port {SENDING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {SENDING_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': SENDING_PORT, 'copy_count': 0, 'username': responder_username}
                    USER_STATS[addr[0]] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{SENDING_PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{SENDING_PORT}! ")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{SENDING_PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], SENDING_PORT)
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def handle_username_updates():
    # Create a UDP socket for listening to incoming username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for username updates on SENDING_PORT
            sock.bind(('', SENDING_PORT))
            logging.debug(f"Listening for username updates on port {SENDING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {SENDING_PORT} for username updates: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME_UPDATE:"):
                    _, new_username = received_message.split(':', 1)
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling username update: {e}")

def send_connection_request(target_ip):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{SENDING_PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, LISTENING_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{LISTENING_PORT}")
            # Wait for a response on the SENDING_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_sock.bind(('', SENDING_PORT))
                    response_message, _ = response_sock.recvfrom(1024)
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        responder_username = response_message.split(':', 1)[1]
                        # Add the responder to TARGET_USERS
                        TARGET_USERS[target_ip] = {'port': SENDING_PORT, 'copy_count': 0, 'username': responder_username}
                        USER_STATS[target_ip] = 0
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{SENDING_PORT}")
                        messagebox.showinfo("Connection Success",
                                            f"Now sharing vibes with '{responder_username}' at {target_ip}:{SENDING_PORT}!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(responder_username, f"Connected from {target_ip}:{SENDING_PORT}")
                        # Send current username to the new connection
                        send_username_update(target_ip, SENDING_PORT)
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{SENDING_PORT}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{SENDING_PORT}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            if isinstance(e, socket.error) and e.errno == 10048:
                # Handle Error 10048: Only one usage per socket address
                custom_error_popup("Port In Use",
                                   f"Port {SENDING_PORT} is already in use. Please set a different port.")
            else:
                custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, LISTENING_PORT))
            logging.debug(f"Sent username update to {target_ip}:{LISTENING_PORT}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to handle username updates
    threading.Thread(target=handle_username_updates, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, connected_users_tree, log_text, pause_button, tray_icon

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry (disabled since now using static ports)
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144", state='disabled')  # Disable port entry
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{LISTENING_PORT}", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 15412
            invite_window.destroy()
            send_connection_request(target_ip)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip)

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            tray_icon.stop()  # Ensure tray icon is removed
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username is set."""
        if username:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username is set
    root.after(1000, check_ready)

    # Bind Enter key to Set Username button
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    # **Enhancement 3: Add a button to minimize to system tray**
    def minimize_to_tray():
        root.withdraw()
        tray_icon.visible = True

    # Create tray icon
    def create_tray_icon():
        image = PIL.Image.new('RGB', (64, 64), color='blue')
        draw = PIL.ImageDraw.Draw(image)
        draw.rectangle((0, 0, 64, 64), fill='blue')
        draw.text((10, 25), "CT", fill='white')  # Example text
        menu = (
            item('Restore', restore_window),
            item('Exit', exit_application)
        )
        tray = pystray.Icon("ClipHilarity Sync", image, "ClipHilarity Sync", menu)
        return tray

    def restore_window(icon, item):
        icon.visible = False
        root.deiconify()

    def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 17:23:39,119 - DEBUG - Received connection request from 192.168.1.26:58597: REQUEST_CONNECTION:15413
2024-11-05 17:23:49,391 - ERROR - Error handling connection request: name 'sender_response_port' is not defined
2024-11-05 17:28:44,958 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 17:28:44,958 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 17:28:44,958 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 17:28:44,958 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 17:28:45,437 - DEBUG - Listening for clipboard updates on port 15412...
2024-11-05 17:28:45,437 - DEBUG - Listening for connection requests on port 15411...
2024-11-05 17:28:45,437 - DEBUG - Listening for connection responses and username updates on port 15413...
2024-11-05 17:28:45,439 - DEBUG - Importing BlpImagePlugin
2024-11-05 17:28:45,440 - DEBUG - Importing BmpImagePlugin
2024-11-05 17:28:45,440 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 17:28:45,440 - DEBUG - Importing CurImagePlugin
2024-11-05 17:28:45,441 - DEBUG - Importing DcxImagePlugin
2024-11-05 17:28:45,442 - DEBUG - Importing DdsImagePlugin
2024-11-05 17:28:45,445 - DEBUG - Importing EpsImagePlugin
2024-11-05 17:28:45,445 - DEBUG - Importing FitsImagePlugin
2024-11-05 17:28:45,447 - DEBUG - Importing FliImagePlugin
2024-11-05 17:28:45,447 - DEBUG - Importing FpxImagePlugin
2024-11-05 17:28:45,448 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 17:28:45,448 - DEBUG - Importing FtexImagePlugin
2024-11-05 17:28:45,449 - DEBUG - Importing GbrImagePlugin
2024-11-05 17:28:45,449 - DEBUG - Importing GifImagePlugin
2024-11-05 17:28:45,449 - DEBUG - Importing GribStubImagePlugin
2024-11-05 17:28:45,450 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 17:28:45,450 - DEBUG - Importing IcnsImagePlugin
2024-11-05 17:28:45,451 - DEBUG - Importing IcoImagePlugin
2024-11-05 17:28:45,452 - DEBUG - Importing ImImagePlugin
2024-11-05 17:28:45,453 - DEBUG - Importing ImtImagePlugin
2024-11-05 17:28:45,453 - DEBUG - Importing IptcImagePlugin
2024-11-05 17:28:45,454 - DEBUG - Importing JpegImagePlugin
2024-11-05 17:28:45,454 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 17:28:45,454 - DEBUG - Importing McIdasImagePlugin
2024-11-05 17:28:45,454 - DEBUG - Importing MicImagePlugin
2024-11-05 17:28:45,455 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 17:28:45,455 - DEBUG - Importing MpegImagePlugin
2024-11-05 17:28:45,455 - DEBUG - Importing MpoImagePlugin
2024-11-05 17:28:45,460 - DEBUG - Importing MspImagePlugin
2024-11-05 17:28:45,460 - DEBUG - Importing PalmImagePlugin
2024-11-05 17:28:45,461 - DEBUG - Importing PcdImagePlugin
2024-11-05 17:28:45,461 - DEBUG - Importing PcxImagePlugin
2024-11-05 17:28:45,461 - DEBUG - Importing PdfImagePlugin
2024-11-05 17:28:45,466 - DEBUG - Importing PixarImagePlugin
2024-11-05 17:28:45,466 - DEBUG - Importing PngImagePlugin
2024-11-05 17:28:45,466 - DEBUG - Importing PpmImagePlugin
2024-11-05 17:28:45,466 - DEBUG - Importing PsdImagePlugin
2024-11-05 17:28:45,467 - DEBUG - Importing QoiImagePlugin
2024-11-05 17:28:45,467 - DEBUG - Importing SgiImagePlugin
2024-11-05 17:28:45,468 - DEBUG - Importing SpiderImagePlugin
2024-11-05 17:28:45,468 - DEBUG - Importing SunImagePlugin
2024-11-05 17:28:45,469 - DEBUG - Importing TgaImagePlugin
2024-11-05 17:28:45,469 - DEBUG - Importing TiffImagePlugin
2024-11-05 17:28:45,469 - DEBUG - Importing WebPImagePlugin
2024-11-05 17:28:45,470 - DEBUG - Importing WmfImagePlugin
2024-11-05 17:28:45,470 - DEBUG - Importing XbmImagePlugin
2024-11-05 17:28:45,471 - DEBUG - Importing XpmImagePlugin
2024-11-05 17:28:45,471 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 17:28:45,490 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import ImageDraw
from PIL import Image, ImageTk, ImageDraw
import ctypes
import logging  # For debugging purposes
import pystray  # For system tray integration
from pystray import MenuItem as item
import PIL.Image  # For creating tray icon images

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
LISTENING_PORT = 15411   # Port for continuously listening to incoming requests
SENDING_PORT = 15413     # Port for sending requests and receiving acknowledgments
CLIPBOARD_PORT = 15412   # Port for clipboard data transfer
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet


TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_USERS:
                            sock.sendto(message.encode('utf-8'), (ip, CLIPBOARD_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', CLIPBOARD_PORT))
            logging.debug(f"Listening for clipboard updates on port {CLIPBOARD_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CLIPBOARD_PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update copy count
                            if addr[0] in USER_STATS:
                                USER_STATS[addr[0]] += 1
                            else:
                                USER_STATS[addr[0]] = 1
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static LISTENING_PORT
            sock.bind(('', LISTENING_PORT))
            logging.debug(f"Listening for connection requests on port {LISTENING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {LISTENING_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == LISTENING_PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), (addr[0], sender_port))
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_response_port, 'copy_count': 0, 'username': 'Unknown'}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_response_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_response_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_response_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses and username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on the static SENDING_PORT
            sock.bind(('', SENDING_PORT))
            logging.debug(f"Listening for connection responses and username updates on port {SENDING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {SENDING_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': SENDING_PORT, 'copy_count': 0, 'username': responder_username}
                    USER_STATS[addr[0]] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{SENDING_PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{SENDING_PORT}! ")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{SENDING_PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], SENDING_PORT)
                elif received_message.startswith("USERNAME_UPDATE:"):
                    new_username = received_message.split(':', 1)[1]
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling incoming messages: {e}")

def send_connection_request(target_ip):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{SENDING_PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, LISTENING_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{LISTENING_PORT}")
            # Removed binding to SENDING_PORT and waiting for response
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            if isinstance(e, socket.error) and e.errno == 10048:
                custom_error_popup("Port In Use",
                                   f"Port {SENDING_PORT} is already in use. Please set a different port.")
            else:
                custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, SENDING_PORT))
            logging.debug(f"Sent username update to {target_ip}:{SENDING_PORT}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses and username updates
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, connected_users_tree, log_text, pause_button, tray_icon

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry (disabled since now using static ports)
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144", state='disabled')  # Disable port entry
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{LISTENING_PORT}", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 15412
            invite_window.destroy()
            send_connection_request(target_ip)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip)

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            tray_icon.stop()  # Ensure tray icon is removed
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username is set."""
        if username:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username is set
    root.after(1000, check_ready)

    # Bind Enter key to Set Username button
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    # **Enhancement 3: Add a button to minimize to system tray**
    def minimize_to_tray():
        root.withdraw()
        tray_icon.visible = True

    # Create tray icon
    def create_tray_icon():
        image = PIL.Image.new('RGB', (64, 64), color='blue')
        draw = PIL.ImageDraw.Draw(image)
        draw.rectangle((0, 0, 64, 64), fill='blue')
        draw.text((10, 25), "CT", fill='white')  # Example text
        menu = (
            item('Restore', restore_window),
            item('Exit', exit_application)
        )
        tray = pystray.Icon("ClipHilarity Sync", image, "ClipHilarity Sync", menu)
        return tray

    def restore_window(icon, item):
        icon.visible = False
        root.deiconify()

    def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 17:29:03,829 - DEBUG - Received connection request from 192.168.1.26:59065: REQUEST_CONNECTION:15413
2024-11-05 17:29:06,630 - ERROR - Error handling connection request: name 'sender_response_port' is not defined
2024-11-05 17:29:26,080 - DEBUG - Broadcasting clipboard content:     while True:

2024-11-05 17:31:13,101 - DEBUG - Received connection request from 192.168.1.26:52703: REQUEST_CONNECTION:15413
2024-11-05 17:31:16,475 - ERROR - Error handling connection request: name 'sender_response_port' is not defined
2024-11-05 17:31:26,524 - DEBUG - Broadcasting clipboard content: Telegram Desktop
2024-11-05 17:31:30,477 - DEBUG - Received clipboard content from 192.168.1.26:54787:     while True:

2024-11-05 17:31:30,478 - DEBUG - Updating local clipboard with received content...
2024-11-05 17:31:30,486 - DEBUG - Clipboard updated from network:     while True:

2024-11-05 17:31:30,486 - ERROR - Error receiving clipboard content: name 'log_activity' is not defined
2024-11-05 17:31:36,712 - DEBUG - Broadcasting clipboard content:     while True

2024-11-05 17:31:41,600 - DEBUG - Received clipboard content from 192.168.1.26:56925:         time.sleep(1)

2024-11-05 17:31:41,601 - DEBUG - Updating local clipboard with received content...
2024-11-05 17:31:41,609 - DEBUG - Clipboard updated from network:         time.sleep(1)

2024-11-05 17:31:41,609 - ERROR - Error receiving clipboard content: name 'log_activity' is not defined
2024-11-05 17:31:45,184 - DEBUG - Broadcasting clipboard content: Telegram Desktop
2024-11-05 17:33:54,285 - DEBUG - Received clipboard content from 192.168.1.26:62623: now i can send request and recive request on another pc then the pc one achnolages the connection 
2024-11-05 17:33:54,285 - DEBUG - Updating local clipboard with received content...
2024-11-05 17:33:54,295 - DEBUG - Clipboard updated from network: now i can send request and recive request on another pc then the pc one achnolages the connection 
2024-11-05 17:33:54,295 - ERROR - Error receiving clipboard content: name 'log_activity' is not defined
2024-11-05 17:34:11,646 - DEBUG - Received clipboard content from 192.168.1.26:57801: acknowledges
2024-11-05 17:34:11,646 - DEBUG - Updating local clipboard with received content...
2024-11-05 17:34:11,652 - DEBUG - Clipboard updated from network: acknowledges
2024-11-05 17:34:11,652 - ERROR - Error receiving clipboard content: name 'log_activity' is not defined
2024-11-05 17:35:29,486 - DEBUG - Received clipboard content from 192.168.1.26:56483: now i can send request and receive request on another pc then the pc one acknowledges the connection and show it in connected users but the pc i sent the request to dosent recorgnise it dost show any connected user and didnt broadcast any copyed text but it recives the text send by host pc
2024-11-05 17:35:29,486 - DEBUG - Updating local clipboard with received content...
2024-11-05 17:35:29,492 - DEBUG - Clipboard updated from network: now i can send request and receive request on another pc then the pc one acknowledges the connection and show it in connected users but the pc i sent the request to dosent recorgnise it dost show any connected user and didnt broadcast any copyed text but it recives the text send by host pc
2024-11-05 17:35:29,492 - ERROR - Error receiving clipboard content: name 'log_activity' is not defined
2024-11-05 17:37:40,176 - DEBUG - Received clipboard content from 192.168.1.26:56437: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import ImageDraw
from PIL import Image, ImageTk, ImageDraw
import ctypes
import logging  # For debugging purposes
import pystray  # For system tray integration
from pystray import MenuItem as item
import PIL.Image  # For creating tray icon images

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
LISTENING_PORT = 15411   # Port for continuously listening to incoming requests
SENDING_PORT = 15413     # Port for sending requests and receiving acknowledgments
CLIPBOARD_PORT = 15412   # Port for clipboard data transfer
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet


TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_USERS:
                            sock.sendto(message.encode('utf-8'), (ip, CLIPBOARD_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', CLIPBOARD_PORT))
            logging.debug(f"Listening for clipboard updates on port {CLIPBOARD_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CLIPBOARD_PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update copy count
                            if addr[0] in USER_STATS:
                                USER_STATS[addr[0]] += 1
                            else:
                                USER_STATS[addr[0]] = 1
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static LISTENING_PORT
            sock.bind(('', LISTENING_PORT))
            logging.debug(f"Listening for connection requests on port {LISTENING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {LISTENING_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == LISTENING_PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), (addr[0], sender_port))
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0, 'username': 'Unknown'}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], sender_port)
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses and username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on the static SENDING_PORT
            sock.bind(('', SENDING_PORT))
            logging.debug(f"Listening for connection responses and username updates on port {SENDING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {SENDING_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': SENDING_PORT, 'copy_count': 0, 'username': responder_username}
                    USER_STATS[addr[0]] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{SENDING_PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{SENDING_PORT}! ")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{SENDING_PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                elif received_message.startswith("USERNAME_UPDATE:"):
                    new_username = received_message.split(':', 1)[1]
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling incoming messages: {e}")

def send_connection_request(target_ip):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{SENDING_PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, LISTENING_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{LISTENING_PORT}")
            # Removed binding to SENDING_PORT and waiting for response
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            if isinstance(e, socket.error) and e.errno == 10048:
                custom_error_popup("Port In Use",
                                   f"Port {SENDING_PORT} is already in use. Please set a different port.")
            else:
                custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, target_port))
            logging.debug(f"Sent username update to {target_ip}:{target_port}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses and username updates
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, connected_users_tree, log_text, pause_button, tray_icon

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry (disabled since now using static ports)
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144", state='disabled')  # Disable port entry
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{LISTENING_PORT}", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 15412
            invite_window.destroy()
            send_connection_request(target_ip)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            tray_icon.stop()  # Ensure tray icon is removed
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username is set."""
        if username:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username is set
    root.after(1000, check_ready)

    # Bind Enter key to Set Username button
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    # **Enhancement 3: Add a button to minimize to system tray**
    def minimize_to_tray():
        root.withdraw()
        tray_icon.visible = True

    # Create tray icon
    def create_tray_icon():
        image = PIL.Image.new('RGB', (64, 64), color='blue')
        draw = PIL.ImageDraw.Draw(image)
        draw.rectangle((0, 0, 64, 64), fill='blue')
        draw.text((10, 25), "CT", fill='white')  # Example text
        menu = (
            item('Restore', restore_window),
            item('Exit', exit_application)
        )
        tray = pystray.Icon("ClipHilarity Sync", image, "ClipHilarity Sync", menu)
        return tray

    def restore_window(icon, item):
        icon.visible = False
        root.deiconify()

    def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 17:37:40,177 - DEBUG - Updating local clipboard with received content...
2024-11-05 17:37:40,183 - DEBUG - Clipboard updated from network: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import ImageDraw
from PIL import Image, ImageTk, ImageDraw
import ctypes
import logging  # For debugging purposes
import pystray  # For system tray integration
from pystray import MenuItem as item
import PIL.Image  # For creating tray icon images

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
LISTENING_PORT = 15411   # Port for continuously listening to incoming requests
SENDING_PORT = 15413     # Port for sending requests and receiving acknowledgments
CLIPBOARD_PORT = 15412   # Port for clipboard data transfer
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet


TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_USERS:
                            sock.sendto(message.encode('utf-8'), (ip, CLIPBOARD_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', CLIPBOARD_PORT))
            logging.debug(f"Listening for clipboard updates on port {CLIPBOARD_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CLIPBOARD_PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update copy count
                            if addr[0] in USER_STATS:
                                USER_STATS[addr[0]] += 1
                            else:
                                USER_STATS[addr[0]] = 1
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static LISTENING_PORT
            sock.bind(('', LISTENING_PORT))
            logging.debug(f"Listening for connection requests on port {LISTENING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {LISTENING_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == LISTENING_PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), (addr[0], sender_port))
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0, 'username': 'Unknown'}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], sender_port)
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses and username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on the static SENDING_PORT
            sock.bind(('', SENDING_PORT))
            logging.debug(f"Listening for connection responses and username updates on port {SENDING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {SENDING_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': SENDING_PORT, 'copy_count': 0, 'username': responder_username}
                    USER_STATS[addr[0]] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{SENDING_PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{SENDING_PORT}! ")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{SENDING_PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                elif received_message.startswith("USERNAME_UPDATE:"):
                    new_username = received_message.split(':', 1)[1]
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling incoming messages: {e}")

def send_connection_request(target_ip):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{SENDING_PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, LISTENING_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{LISTENING_PORT}")
            # Removed binding to SENDING_PORT and waiting for response
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            if isinstance(e, socket.error) and e.errno == 10048:
                custom_error_popup("Port In Use",
                                   f"Port {SENDING_PORT} is already in use. Please set a different port.")
            else:
                custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, target_port))
            logging.debug(f"Sent username update to {target_ip}:{target_port}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses and username updates
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, connected_users_tree, log_text, pause_button, tray_icon

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry (disabled since now using static ports)
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144", state='disabled')  # Disable port entry
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{LISTENING_PORT}", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 15412
            invite_window.destroy()
            send_connection_request(target_ip)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            tray_icon.stop()  # Ensure tray icon is removed
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username is set."""
        if username:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username is set
    root.after(1000, check_ready)

    # Bind Enter key to Set Username button
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    # **Enhancement 3: Add a button to minimize to system tray**
    def minimize_to_tray():
        root.withdraw()
        tray_icon.visible = True

    # Create tray icon
    def create_tray_icon():
        image = PIL.Image.new('RGB', (64, 64), color='blue')
        draw = PIL.ImageDraw.Draw(image)
        draw.rectangle((0, 0, 64, 64), fill='blue')
        draw.text((10, 25), "CT", fill='white')  # Example text
        menu = (
            item('Restore', restore_window),
            item('Exit', exit_application)
        )
        tray = pystray.Icon("ClipHilarity Sync", image, "ClipHilarity Sync", menu)
        return tray

    def restore_window(icon, item):
        icon.visible = False
        root.deiconify()

    def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 17:37:40,184 - ERROR - Error receiving clipboard content: name 'log_activity' is not defined
2024-11-05 17:38:03,864 - DEBUG - Received clipboard content from 192.168.1.26:54626: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import ImageDraw
from PIL import Image, ImageTk, ImageDraw
import ctypes
import logging  # For debugging purposes
import pystray  # For system tray integration
from pystray import MenuItem as item
import PIL.Image  # For creating tray icon images

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
LISTENING_PORT = 15411   # Port for continuously listening to incoming requests
SENDING_PORT = 15413     # Port for sending requests and receiving acknowledgments
CLIPBOARD_PORT = 15412   # Port for clipboard data transfer
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet


TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_USERS:
                            sock.sendto(message.encode('utf-8'), (ip, CLIPBOARD_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', CLIPBOARD_PORT))
            logging.debug(f"Listening for clipboard updates on port {CLIPBOARD_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CLIPBOARD_PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update copy count
                            if addr[0] in USER_STATS:
                                USER_STATS[addr[0]] += 1
                            else:
                                USER_STATS[addr[0]] = 1
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static LISTENING_PORT
            sock.bind(('', LISTENING_PORT))
            logging.debug(f"Listening for connection requests on port {LISTENING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {LISTENING_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == LISTENING_PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), (addr[0], sender_port))
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0, 'username': 'Unknown'}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], sender_port)
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses and username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on the static SENDING_PORT
            sock.bind(('', SENDING_PORT))
            logging.debug(f"Listening for connection responses and username updates on port {SENDING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {SENDING_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': SENDING_PORT, 'copy_count': 0, 'username': responder_username}
                    USER_STATS[addr[0]] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{SENDING_PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{SENDING_PORT}! ")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{SENDING_PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                elif received_message.startswith("USERNAME_UPDATE:"):
                    new_username = received_message.split(':', 1)[1]
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling incoming messages: {e}")

def send_connection_request(target_ip):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{SENDING_PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, LISTENING_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{LISTENING_PORT}")
            # Removed binding to SENDING_PORT and waiting for response
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            if isinstance(e, socket.error) and e.errno == 10048:
                custom_error_popup("Port In Use",
                                   f"Port {SENDING_PORT} is already in use. Please set a different port.")
            else:
                custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, target_port))
            logging.debug(f"Sent username update to {target_ip}:{target_port}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses and username updates
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, connected_users_tree, log_text, pause_button, tray_icon

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry (disabled since now using static ports)
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144", state='disabled')  # Disable port entry
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{LISTENING_PORT}", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 15412
            invite_window.destroy()
            send_connection_request(target_ip)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            tray_icon.stop()  # Ensure tray icon is removed
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username is set."""
        if username:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username is set
    root.after(1000, check_ready)

    # Bind Enter key to Set Username button
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    # **Enhancement 3: Add a button to minimize to system tray**
    def minimize_to_tray():
        root.withdraw()
        tray_icon.visible = True

    # Create tray icon
    def create_tray_icon():
        image = PIL.Image.new('RGB', (64, 64), color='blue')
        draw = PIL.ImageDraw.Draw(image)
        draw.rectangle((0, 0, 64, 64), fill='blue')
        draw.text((10, 25), "CT", fill='white')  # Example text
        menu = (
            item('Restore', restore_window),
            item('Exit', exit_application)
        )
        tray = pystray.Icon("ClipHilarity Sync", image, "ClipHilarity Sync", menu)
        return tray

    def restore_window(icon, item):
        icon.visible = False
        root.deiconify()

    def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)
123
2024-11-05 17:38:03,865 - DEBUG - Updating local clipboard with received content...
2024-11-05 17:38:03,873 - DEBUG - Clipboard updated from network: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import ImageDraw
from PIL import Image, ImageTk, ImageDraw
import ctypes
import logging  # For debugging purposes
import pystray  # For system tray integration
from pystray import MenuItem as item
import PIL.Image  # For creating tray icon images

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
LISTENING_PORT = 15411   # Port for continuously listening to incoming requests
SENDING_PORT = 15413     # Port for sending requests and receiving acknowledgments
CLIPBOARD_PORT = 15412   # Port for clipboard data transfer
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet


TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_USERS:
                            sock.sendto(message.encode('utf-8'), (ip, CLIPBOARD_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', CLIPBOARD_PORT))
            logging.debug(f"Listening for clipboard updates on port {CLIPBOARD_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CLIPBOARD_PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update copy count
                            if addr[0] in USER_STATS:
                                USER_STATS[addr[0]] += 1
                            else:
                                USER_STATS[addr[0]] = 1
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static LISTENING_PORT
            sock.bind(('', LISTENING_PORT))
            logging.debug(f"Listening for connection requests on port {LISTENING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {LISTENING_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == LISTENING_PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), (addr[0], sender_port))
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0, 'username': 'Unknown'}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], sender_port)
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses and username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on the static SENDING_PORT
            sock.bind(('', SENDING_PORT))
            logging.debug(f"Listening for connection responses and username updates on port {SENDING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {SENDING_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': SENDING_PORT, 'copy_count': 0, 'username': responder_username}
                    USER_STATS[addr[0]] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{SENDING_PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{SENDING_PORT}! ")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{SENDING_PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                elif received_message.startswith("USERNAME_UPDATE:"):
                    new_username = received_message.split(':', 1)[1]
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling incoming messages: {e}")

def send_connection_request(target_ip):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{SENDING_PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, LISTENING_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{LISTENING_PORT}")
            # Removed binding to SENDING_PORT and waiting for response
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            if isinstance(e, socket.error) and e.errno == 10048:
                custom_error_popup("Port In Use",
                                   f"Port {SENDING_PORT} is already in use. Please set a different port.")
            else:
                custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, target_port))
            logging.debug(f"Sent username update to {target_ip}:{target_port}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses and username updates
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, connected_users_tree, log_text, pause_button, tray_icon

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry (disabled since now using static ports)
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144", state='disabled')  # Disable port entry
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{LISTENING_PORT}", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 15412
            invite_window.destroy()
            send_connection_request(target_ip)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            tray_icon.stop()  # Ensure tray icon is removed
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username is set."""
        if username:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username is set
    root.after(1000, check_ready)

    # Bind Enter key to Set Username button
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    # **Enhancement 3: Add a button to minimize to system tray**
    def minimize_to_tray():
        root.withdraw()
        tray_icon.visible = True

    # Create tray icon
    def create_tray_icon():
        image = PIL.Image.new('RGB', (64, 64), color='blue')
        draw = PIL.ImageDraw.Draw(image)
        draw.rectangle((0, 0, 64, 64), fill='blue')
        draw.text((10, 25), "CT", fill='white')  # Example text
        menu = (
            item('Restore', restore_window),
            item('Exit', exit_application)
        )
        tray = pystray.Icon("ClipHilarity Sync", image, "ClipHilarity Sync", menu)
        return tray

    def restore_window(icon, item):
        icon.visible = False
        root.deiconify()

    def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)
123
2024-11-05 17:38:03,873 - ERROR - Error receiving clipboard content: name 'log_activity' is not defined
2024-11-05 17:38:24,262 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 17:38:24,263 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 17:38:24,263 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 17:38:24,263 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 17:38:24,710 - DEBUG - Listening for clipboard updates on port 15412...
2024-11-05 17:38:24,711 - DEBUG - Listening for connection responses and username updates on port 15413...
2024-11-05 17:38:24,711 - DEBUG - Listening for connection requests on port 15411...
2024-11-05 17:38:24,713 - DEBUG - Importing BlpImagePlugin
2024-11-05 17:38:24,715 - DEBUG - Importing BmpImagePlugin
2024-11-05 17:38:24,715 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 17:38:24,715 - DEBUG - Importing CurImagePlugin
2024-11-05 17:38:24,715 - DEBUG - Importing DcxImagePlugin
2024-11-05 17:38:24,716 - DEBUG - Importing DdsImagePlugin
2024-11-05 17:38:24,719 - DEBUG - Importing EpsImagePlugin
2024-11-05 17:38:24,719 - DEBUG - Importing FitsImagePlugin
2024-11-05 17:38:24,721 - DEBUG - Importing FliImagePlugin
2024-11-05 17:38:24,722 - DEBUG - Importing FpxImagePlugin
2024-11-05 17:38:24,723 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 17:38:24,723 - DEBUG - Importing FtexImagePlugin
2024-11-05 17:38:24,723 - DEBUG - Importing GbrImagePlugin
2024-11-05 17:38:24,724 - DEBUG - Importing GifImagePlugin
2024-11-05 17:38:24,724 - DEBUG - Importing GribStubImagePlugin
2024-11-05 17:38:24,724 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 17:38:24,725 - DEBUG - Importing IcnsImagePlugin
2024-11-05 17:38:24,726 - DEBUG - Importing IcoImagePlugin
2024-11-05 17:38:24,727 - DEBUG - Importing ImImagePlugin
2024-11-05 17:38:24,727 - DEBUG - Importing ImtImagePlugin
2024-11-05 17:38:24,728 - DEBUG - Importing IptcImagePlugin
2024-11-05 17:38:24,728 - DEBUG - Importing JpegImagePlugin
2024-11-05 17:38:24,728 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 17:38:24,728 - DEBUG - Importing McIdasImagePlugin
2024-11-05 17:38:24,729 - DEBUG - Importing MicImagePlugin
2024-11-05 17:38:24,730 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 17:38:24,730 - DEBUG - Importing MpegImagePlugin
2024-11-05 17:38:24,730 - DEBUG - Importing MpoImagePlugin
2024-11-05 17:38:24,735 - DEBUG - Importing MspImagePlugin
2024-11-05 17:38:24,736 - DEBUG - Importing PalmImagePlugin
2024-11-05 17:38:24,736 - DEBUG - Importing PcdImagePlugin
2024-11-05 17:38:24,737 - DEBUG - Importing PcxImagePlugin
2024-11-05 17:38:24,737 - DEBUG - Importing PdfImagePlugin
2024-11-05 17:38:24,741 - DEBUG - Importing PixarImagePlugin
2024-11-05 17:38:24,741 - DEBUG - Importing PngImagePlugin
2024-11-05 17:38:24,741 - DEBUG - Importing PpmImagePlugin
2024-11-05 17:38:24,741 - DEBUG - Importing PsdImagePlugin
2024-11-05 17:38:24,742 - DEBUG - Importing QoiImagePlugin
2024-11-05 17:38:24,742 - DEBUG - Importing SgiImagePlugin
2024-11-05 17:38:24,742 - DEBUG - Importing SpiderImagePlugin
2024-11-05 17:38:24,743 - DEBUG - Importing SunImagePlugin
2024-11-05 17:38:24,743 - DEBUG - Importing TgaImagePlugin
2024-11-05 17:38:24,744 - DEBUG - Importing TiffImagePlugin
2024-11-05 17:38:24,744 - DEBUG - Importing WebPImagePlugin
2024-11-05 17:38:24,744 - DEBUG - Importing WmfImagePlugin
2024-11-05 17:38:24,745 - DEBUG - Importing XbmImagePlugin
2024-11-05 17:38:24,745 - DEBUG - Importing XpmImagePlugin
2024-11-05 17:38:24,746 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 17:38:24,761 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import ImageDraw
from PIL import Image, ImageTk, ImageDraw
import ctypes
import logging  # For debugging purposes
import pystray  # For system tray integration
from pystray import MenuItem as item
import PIL.Image  # For creating tray icon images

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
LISTENING_PORT = 15411   # Port for continuously listening to incoming requests
SENDING_PORT = 15413     # Port for sending requests and receiving acknowledgments
CLIPBOARD_PORT = 15412   # Port for clipboard data transfer
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet


TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_USERS:
                            sock.sendto(message.encode('utf-8'), (ip, CLIPBOARD_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', CLIPBOARD_PORT))
            logging.debug(f"Listening for clipboard updates on port {CLIPBOARD_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CLIPBOARD_PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update copy count
                            if addr[0] in USER_STATS:
                                USER_STATS[addr[0]] += 1
                            else:
                                USER_STATS[addr[0]] = 1
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static LISTENING_PORT
            sock.bind(('', LISTENING_PORT))
            logging.debug(f"Listening for connection requests on port {LISTENING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {LISTENING_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == LISTENING_PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), (addr[0], sender_port))
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0, 'username': 'Unknown'}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], sender_port)
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses and username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on the static SENDING_PORT
            sock.bind(('', SENDING_PORT))
            logging.debug(f"Listening for connection responses and username updates on port {SENDING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {SENDING_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': SENDING_PORT, 'copy_count': 0, 'username': responder_username}
                    USER_STATS[addr[0]] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{SENDING_PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{SENDING_PORT}! ")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{SENDING_PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                elif received_message.startswith("USERNAME_UPDATE:"):
                    new_username = received_message.split(':', 1)[1]
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling incoming messages: {e}")

def send_connection_request(target_ip):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{SENDING_PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, LISTENING_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{LISTENING_PORT}")
            # Removed binding to SENDING_PORT and waiting for response
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            if isinstance(e, socket.error) and e.errno == 10048:
                custom_error_popup("Port In Use",
                                   f"Port {SENDING_PORT} is already in use. Please set a different port.")
            else:
                custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, target_port))
            logging.debug(f"Sent username update to {target_ip}:{target_port}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses and username updates
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, connected_users_tree, log_text, pause_button, tray_icon

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry (disabled since now using static ports)
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144", state='disabled')  # Disable port entry
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{LISTENING_PORT}", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 15412
            invite_window.destroy()
            send_connection_request(target_ip)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            tray_icon.stop()  # Ensure tray icon is removed
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username is set."""
        if username:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username is set
    root.after(1000, check_ready)

    # Bind Enter key to Set Username button
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    # **Enhancement 3: Add a button to minimize to system tray**
    def minimize_to_tray():
        root.withdraw()
        tray_icon.visible = True

    # Create tray icon
    def create_tray_icon():
        image = PIL.Image.new('RGB', (64, 64), color='blue')
        draw = PIL.ImageDraw.Draw(image)
        draw.rectangle((0, 0, 64, 64), fill='blue')
        draw.text((10, 25), "CT", fill='white')  # Example text
        menu = (
            item('Restore', restore_window),
            item('Exit', exit_application)
        )
        tray = pystray.Icon("ClipHilarity Sync", image, "ClipHilarity Sync", menu)
        return tray

    def restore_window(icon, item):
        icon.visible = False
        root.deiconify()

    def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)
123
2024-11-05 17:38:39,487 - DEBUG - Received connection request from 192.168.1.26:61349: REQUEST_CONNECTION:15413
2024-11-05 17:38:40,945 - DEBUG - Accepted connection from 192.168.1.26:15413
2024-11-05 17:38:40,947 - ERROR - Error handling connection request: name 'log_activity' is not defined
2024-11-05 17:38:47,549 - DEBUG - Received clipboard content from 192.168.1.26:61350:     # Keep the threads running in the background even after closing the GUI

2024-11-05 17:38:47,549 - DEBUG - Updating local clipboard with received content...
2024-11-05 17:38:47,554 - DEBUG - Clipboard updated from network:     # Keep the threads running in the background even after closing the GUI

2024-11-05 17:38:47,554 - ERROR - Error receiving clipboard content: name 'log_activity' is not defined
2024-11-05 17:39:13,110 - DEBUG - Broadcasting clipboard content:         time.sleep(1)

2024-11-05 17:40:00,751 - DEBUG - Received clipboard content from 192.168.1.26:56783: CLIPBOARD_PORT
2024-11-05 17:40:00,751 - DEBUG - Updating local clipboard with received content...
2024-11-05 17:40:00,760 - DEBUG - Clipboard updated from network: CLIPBOARD_PORT
2024-11-05 17:40:00,760 - ERROR - Error receiving clipboard content: name 'log_activity' is not defined
2024-11-05 17:50:12,361 - DEBUG - Broadcasting clipboard content: git pull origin develop
2024-11-05 18:01:03,709 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 18:01:03,709 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 18:01:03,709 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 18:01:03,709 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 18:01:04,164 - DEBUG - Listening for connection responses and username updates on port 15413...
2024-11-05 18:01:04,164 - DEBUG - Listening for connection requests on port 15411...
2024-11-05 18:01:04,167 - DEBUG - Importing BlpImagePlugin
2024-11-05 18:01:04,168 - DEBUG - Importing BmpImagePlugin
2024-11-05 18:01:04,168 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 18:01:04,168 - DEBUG - Importing CurImagePlugin
2024-11-05 18:01:04,169 - DEBUG - Importing DcxImagePlugin
2024-11-05 18:01:04,170 - DEBUG - Importing DdsImagePlugin
2024-11-05 18:01:04,172 - DEBUG - Importing EpsImagePlugin
2024-11-05 18:01:04,173 - DEBUG - Importing FitsImagePlugin
2024-11-05 18:01:04,174 - DEBUG - Importing FliImagePlugin
2024-11-05 18:01:04,175 - DEBUG - Importing FpxImagePlugin
2024-11-05 18:01:04,176 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 18:01:04,176 - DEBUG - Importing FtexImagePlugin
2024-11-05 18:01:04,176 - DEBUG - Importing GbrImagePlugin
2024-11-05 18:01:04,177 - DEBUG - Importing GifImagePlugin
2024-11-05 18:01:04,177 - DEBUG - Importing GribStubImagePlugin
2024-11-05 18:01:04,177 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 18:01:04,178 - DEBUG - Importing IcnsImagePlugin
2024-11-05 18:01:04,179 - DEBUG - Importing IcoImagePlugin
2024-11-05 18:01:04,180 - DEBUG - Importing ImImagePlugin
2024-11-05 18:01:04,180 - DEBUG - Importing ImtImagePlugin
2024-11-05 18:01:04,181 - DEBUG - Importing IptcImagePlugin
2024-11-05 18:01:04,181 - DEBUG - Importing JpegImagePlugin
2024-11-05 18:01:04,181 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 18:01:04,181 - DEBUG - Importing McIdasImagePlugin
2024-11-05 18:01:04,182 - DEBUG - Importing MicImagePlugin
2024-11-05 18:01:04,182 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 18:01:04,182 - DEBUG - Importing MpegImagePlugin
2024-11-05 18:01:04,183 - DEBUG - Importing MpoImagePlugin
2024-11-05 18:01:04,187 - DEBUG - Importing MspImagePlugin
2024-11-05 18:01:04,188 - DEBUG - Importing PalmImagePlugin
2024-11-05 18:01:04,189 - DEBUG - Importing PcdImagePlugin
2024-11-05 18:01:04,189 - DEBUG - Importing PcxImagePlugin
2024-11-05 18:01:04,189 - DEBUG - Importing PdfImagePlugin
2024-11-05 18:01:04,193 - DEBUG - Importing PixarImagePlugin
2024-11-05 18:01:04,194 - DEBUG - Importing PngImagePlugin
2024-11-05 18:01:04,194 - DEBUG - Importing PpmImagePlugin
2024-11-05 18:01:04,194 - DEBUG - Importing PsdImagePlugin
2024-11-05 18:01:04,194 - DEBUG - Importing QoiImagePlugin
2024-11-05 18:01:04,194 - DEBUG - Importing SgiImagePlugin
2024-11-05 18:01:04,195 - DEBUG - Importing SpiderImagePlugin
2024-11-05 18:01:04,195 - DEBUG - Importing SunImagePlugin
2024-11-05 18:01:04,196 - DEBUG - Importing TgaImagePlugin
2024-11-05 18:01:04,196 - DEBUG - Importing TiffImagePlugin
2024-11-05 18:01:04,196 - DEBUG - Importing WebPImagePlugin
2024-11-05 18:01:04,197 - DEBUG - Importing WmfImagePlugin
2024-11-05 18:01:04,197 - DEBUG - Importing XbmImagePlugin
2024-11-05 18:01:04,198 - DEBUG - Importing XpmImagePlugin
2024-11-05 18:01:04,198 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 18:01:04,214 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import ImageDraw
from PIL import Image, ImageTk, ImageDraw
import ctypes
import logging  # For debugging purposes
import pystray  # For system tray integration
from pystray import MenuItem as item
import PIL.Image  # For creating tray icon images

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
LISTENING_PORT = 15411   # Port for continuously listening to incoming requests
SENDING_PORT = 15413     # Port for sending requests and receiving acknowledgments
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet


TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            current_text = pyperclip.paste()
            with clipboard_lock:
                if current_text != last_text:
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send to each connected user's CLIPBOARD_PORT
                        for ip, info in TARGET_USERS.items():
                            target_port = info.get('clipboard_port')
                            if target_port:
                                sock.sendto(message.encode('utf-8'), (ip, target_port))
        except Exception as e:
            logging.error(f"Error broadcasting clipboard content: {e}")
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Use user's chosen CLIPBOARD_PORT
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            sock.bind(('', CLIPBOARD_PORT))
            logging.debug(f"Listening for clipboard updates on port {CLIPBOARD_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CLIPBOARD_PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)
                    if received_id == instance_id:
                        continue
                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    with clipboard_lock:
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            if addr[0] in USER_STATS:
                                USER_STATS[addr[0]] += 1
                            else:
                                USER_STATS[addr[0]] = 1
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            sock.bind(('', LISTENING_PORT))
            logging.debug(f"Listening for connection requests on port {LISTENING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {LISTENING_PORT} for connection requests: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    parts = received_message.split(':')
                    if len(parts) == 3:
                        _, sender_port, sender_clipboard_port = parts
                        sender_port = int(sender_port)
                        sender_clipboard_port = int(sender_clipboard_port)
                        # Prevent accepting connection from self
                        if addr[0] == local_ip and sender_port == LISTENING_PORT:
                            logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                            continue
                        result = messagebox.askyesno("Connection Request",
                                                     f"Do you want to connect with user at {addr[0]}?")
                        if result:
                            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                                # Include own CLIPBOARD_PORT in the response
                                response_message = f"CONNECTION_ACCEPTED:{username}:{CLIPBOARD_PORT}"
                                response_sock.sendto(response_message.encode('utf-8'), (addr[0], sender_port))
                            # Add the user to TARGET_USERS
                            TARGET_USERS[addr[0]] = {
                                'port': sender_port,
                                'clipboard_port': sender_clipboard_port,
                                'copy_count': 0,
                                'username': 'Unknown'
                            }
                            USER_STATS[addr[0]] = 0
                            logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                            is_connected.set()
                            update_connected_users_display()
                            log_activity(addr[0], f"Connected with {addr[0]}:{sender_port}")
                            # Send current username to the new connection
                            send_username_update(addr[0], sender_port)
                        else:
                            logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            sock.bind(('', SENDING_PORT))
            logging.debug(f"Listening for connection responses and username updates on port {SENDING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {SENDING_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    parts = received_message.split(':', 2)
                    if len(parts) == 3:
                        _, responder_username, responder_clipboard_port = parts
                        responder_clipboard_port = int(responder_clipboard_port)
                        # Add the responder to TARGET_USERS
                        TARGET_USERS[addr[0]] = {
                            'port': SENDING_PORT,
                            'clipboard_port': responder_clipboard_port,
                            'copy_count': 0,
                            'username': responder_username
                        }
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{SENDING_PORT}")
                        messagebox.showinfo("Connection Success",
                                            f"Now sharing vibes with '{responder_username}' at {addr[0]}!")
                        is_connected.set()
                        update_connected_users_display()
                        log_activity(responder_username, f"Connected from {addr[0]}:{SENDING_PORT}")
                        # Send own username to the new connection
                        send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                elif received_message.startswith("USERNAME_UPDATE:"):
                    new_username = received_message.split(':', 1)[1]
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling incoming messages: {e}")

def send_connection_request(target_ip):
    if not username or not CLIPBOARD_PORT:
        custom_error_popup("Oops!", "Please set your username and clipboard port first!")
        return
    if target_ip == local_ip:
        custom_error_popup("Oops!", "You cannot connect to yourself!")
        logging.warning("User attempted to send connection request to themselves.")
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Include CLIPBOARD_PORT in the request
            message = f"REQUEST_CONNECTION:{SENDING_PORT}:{CLIPBOARD_PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, LISTENING_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{LISTENING_PORT}")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, target_port))
            logging.debug(f"Sent username update to {target_ip}:{target_port}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def start_threads():
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Remove starting listen_for_clipboard_updates() here
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, connected_users_tree, log_text, pause_button, tray_icon, CLIPBOARD_PORT

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry (enable it for user input)
    port_label = tk.Label(settings_frame, text="\U0001f527 Clipboard Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")  # Enable port entry
    port_entry.grid(row=0, column=1, padx=5, pady=5)
    port_entry.insert(0, "15412")  # Default value

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{LISTENING_PORT}", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 15412
            invite_window.destroy()
            send_connection_request(target_ip)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_username():
        global username, CLIPBOARD_PORT
        entered_username = username_entry.get().strip()
        entered_port = port_entry.get().strip()
        if not entered_port.isdigit():
            custom_error_popup("Invalid Port", "Please enter a valid clipboard port number.")
            return
        CLIPBOARD_PORT = int(entered_port)
        if not entered_username:
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        port_entry.config(state='disabled')
        # Update GUI labels
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{LISTENING_PORT}, Clipboard Port: {CLIPBOARD_PORT}")
        invite_button.config(state='normal')
        # Start listening on the specified CLIPBOARD_PORT
        threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
        # Send username update to existing connections
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            tray_icon.stop()  # Ensure tray icon is removed
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username is set."""
        if username:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username is set
    root.after(1000, check_ready)

    # Bind Enter key to Set Username button
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    # **Enhancement 3: Add a button to minimize to system tray**
    def minimize_to_tray():
        root.withdraw()
        tray_icon.visible = True

    # Create tray icon
    def create_tray_icon():
        image = PIL.Image.new('RGB', (64, 64), color='blue')
        draw = PIL.ImageDraw.Draw(image)
        draw.rectangle((0, 0, 64, 64), fill='blue')
        draw.text((10, 25), "CT", fill='white')  # Example text
        menu = (
            item('Restore', restore_window),
            item('Exit', exit_application)
        )
        tray = pystray.Icon("ClipHilarity Sync", image, "ClipHilarity Sync", menu)
        return tray

    def restore_window(icon, item):
        icon.visible = False
        root.deiconify()

    def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)



2024-11-05 18:01:15,993 - DEBUG - Listening for clipboard updates on port 15412...
2024-11-05 18:02:09,028 - DEBUG - Received connection request from 192.168.1.26:51693: REQUEST_CONNECTION:15413:15412
2024-11-05 18:02:10,369 - DEBUG - Accepted connection from 192.168.1.26:15413
2024-11-05 18:02:10,370 - ERROR - Error handling connection request: name 'log_activity' is not defined
2024-11-05 18:02:15,570 - DEBUG - Received clipboard content from 192.168.1.26:61515:     "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",

2024-11-05 18:02:15,571 - DEBUG - Updating local clipboard with received content...
2024-11-05 18:02:15,578 - DEBUG - Clipboard updated from network:     "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",

2024-11-05 18:02:15,579 - ERROR - Error receiving clipboard content: name 'log_activity' is not defined
2024-11-05 18:02:26,096 - DEBUG - Broadcasting clipboard content: Agar abhi na lein website ka domain and hosting...ye sab discontinue kr dein
2024-11-05 18:05:00,946 - DEBUG - Sent connection request to 192.168.1.26:15411
2024-11-05 18:05:02,727 - DEBUG - Connection established with 'PixelPunctuation' at 192.168.1.26:15413
2024-11-05 18:05:04,545 - ERROR - Error handling incoming messages: name 'log_activity' is not defined
2024-11-05 18:05:54,899 - DEBUG - Broadcasting clipboard content: Chilling and waiting for buddies to join...
2024-11-05 18:06:41,846 - DEBUG - Received clipboard content from 192.168.1.26:56588: great its working, now check why connection log isnt working, and copy count also isnt updateing check that 

and change the text Chilling and waiting for buddies to join... to Chilling with my buddies anyone else woona join...
2024-11-05 18:06:41,846 - DEBUG - Updating local clipboard with received content...
2024-11-05 18:06:41,855 - DEBUG - Clipboard updated from network: great its working, now check why connection log isnt working, and copy count also isnt updateing check that 

and change the text Chilling and waiting for buddies to join... to Chilling with my buddies anyone else woona join...
2024-11-05 18:06:41,855 - ERROR - Error receiving clipboard content: name 'log_activity' is not defined
2024-11-05 18:10:36,945 - DEBUG - Received clipboard content from 192.168.1.26:54764: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import ImageDraw
from PIL import Image, ImageTk, ImageDraw
import ctypes
import logging  # For debugging purposes
import pystray  # For system tray integration
from pystray import MenuItem as item
import PIL.Image  # For creating tray icon images

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
LISTENING_PORT = 15411   # Port for continuously listening to incoming requests
SENDING_PORT = 15413     # Port for sending requests and receiving acknowledgments
CLIPBOARD_PORT = 15412   # Port for clipboard data transfer
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet


TARGET_USERS = {}  # Dictionary to store target IPs and their details

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_USERS:
                            sock.sendto(message.encode('utf-8'), (ip, CLIPBOARD_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', CLIPBOARD_PORT))
            logging.debug(f"Listening for clipboard updates on port {CLIPBOARD_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CLIPBOARD_PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update TARGET_USERS with username and copy count
                            if addr[0] in TARGET_USERS:
                                TARGET_USERS[addr[0]]['username'] = received_username
                                TARGET_USERS[addr[0]]['copy_count'] += 1
                            else:
                                TARGET_USERS[addr[0]] = {'port': addr[1], 'copy_count': 1, 'username': received_username}
                                # Assign color to new user
                                if received_username not in user_colors:
                                    user_colors[received_username] = get_next_color()
                                update_connected_users_display()
                            # Log the activity
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static LISTENING_PORT
            sock.bind(('', LISTENING_PORT))
            logging.debug(f"Listening for connection requests on port {LISTENING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {LISTENING_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == LISTENING_PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), (addr[0], sender_port))
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0, 'username': 'Unknown'}
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], sender_port)
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses and username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on the static SENDING_PORT
            sock.bind(('', SENDING_PORT))
            logging.debug(f"Listening for connection responses and username updates on port {SENDING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {SENDING_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': SENDING_PORT, 'copy_count': 0, 'username': responder_username}
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{SENDING_PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{SENDING_PORT}! ")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{SENDING_PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                elif received_message.startswith("USERNAME_UPDATE:"):
                    new_username = received_message.split(':', 1)[1]
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling incoming messages: {e}")

def send_connection_request(target_ip):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{SENDING_PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, LISTENING_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{LISTENING_PORT}")
            # Removed binding to SENDING_PORT and waiting for response
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            if isinstance(e, socket.error) and e.errno == 10048:
                custom_error_popup("Port In Use",
                                   f"Port {SENDING_PORT} is already in use. Please set a different port.")
            else:
                custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, target_port))
            logging.debug(f"Sent username update to {target_ip}:{target_port}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses and username updates
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info.get('copy_count', 0)))

# GUI Setup
def main():
    global root, username, connected_users_tree, log_text, pause_button, tray_icon

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry (disabled since now using static ports)
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144", state='disabled')  # Disable port entry
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{LISTENING_PORT}", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 15412
            invite_window.destroy()
            send_connection_request(target_ip)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling with my buddies anyone else wanna join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            tray_icon.stop()  # Ensure tray icon is removed
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username is set."""
        if username:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username is set
    root.after(1000, check_ready)

    # Bind Enter key to Set Username button
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    # **Enhancement 3: Add a button to minimize to system tray**
    def minimize_to_tray():
        root.withdraw()
        tray_icon.visible = True

    # Create tray icon
    def create_tray_icon():
        image = PIL.Image.new('RGB', (64, 64), color='blue')
        draw = PIL.ImageDraw.Draw(image)
        draw.rectangle((0, 0, 64, 64), fill='blue')
        draw.text((10, 25), "CT", fill='white')  # Example text
        menu = (
            item('Restore', restore_window),
            item('Exit', exit_application)
        )
        tray = pystray.Icon("ClipHilarity Sync", image, "ClipHilarity Sync", menu)
        return tray

    def restore_window(icon, item):
        icon.visible = False
        root.deiconify()

    def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)



2024-11-05 18:10:36,947 - DEBUG - Updating local clipboard with received content...
2024-11-05 18:10:36,956 - DEBUG - Clipboard updated from network: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import ImageDraw
from PIL import Image, ImageTk, ImageDraw
import ctypes
import logging  # For debugging purposes
import pystray  # For system tray integration
from pystray import MenuItem as item
import PIL.Image  # For creating tray icon images

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
LISTENING_PORT = 15411   # Port for continuously listening to incoming requests
SENDING_PORT = 15413     # Port for sending requests and receiving acknowledgments
CLIPBOARD_PORT = 15412   # Port for clipboard data transfer
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet


TARGET_USERS = {}  # Dictionary to store target IPs and their details

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_USERS:
                            sock.sendto(message.encode('utf-8'), (ip, CLIPBOARD_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', CLIPBOARD_PORT))
            logging.debug(f"Listening for clipboard updates on port {CLIPBOARD_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CLIPBOARD_PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update TARGET_USERS with username and copy count
                            if addr[0] in TARGET_USERS:
                                TARGET_USERS[addr[0]]['username'] = received_username
                                TARGET_USERS[addr[0]]['copy_count'] += 1
                            else:
                                TARGET_USERS[addr[0]] = {'port': addr[1], 'copy_count': 1, 'username': received_username}
                                # Assign color to new user
                                if received_username not in user_colors:
                                    user_colors[received_username] = get_next_color()
                                update_connected_users_display()
                            # Log the activity
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static LISTENING_PORT
            sock.bind(('', LISTENING_PORT))
            logging.debug(f"Listening for connection requests on port {LISTENING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {LISTENING_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == LISTENING_PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), (addr[0], sender_port))
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0, 'username': 'Unknown'}
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], sender_port)
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses and username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on the static SENDING_PORT
            sock.bind(('', SENDING_PORT))
            logging.debug(f"Listening for connection responses and username updates on port {SENDING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {SENDING_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': SENDING_PORT, 'copy_count': 0, 'username': responder_username}
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{SENDING_PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{SENDING_PORT}! ")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{SENDING_PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                elif received_message.startswith("USERNAME_UPDATE:"):
                    new_username = received_message.split(':', 1)[1]
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling incoming messages: {e}")

def send_connection_request(target_ip):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{SENDING_PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, LISTENING_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{LISTENING_PORT}")
            # Removed binding to SENDING_PORT and waiting for response
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            if isinstance(e, socket.error) and e.errno == 10048:
                custom_error_popup("Port In Use",
                                   f"Port {SENDING_PORT} is already in use. Please set a different port.")
            else:
                custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, target_port))
            logging.debug(f"Sent username update to {target_ip}:{target_port}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses and username updates
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info.get('copy_count', 0)))

# GUI Setup
def main():
    global root, username, connected_users_tree, log_text, pause_button, tray_icon

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry (disabled since now using static ports)
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144", state='disabled')  # Disable port entry
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{LISTENING_PORT}", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 15412
            invite_window.destroy()
            send_connection_request(target_ip)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling with my buddies anyone else wanna join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            tray_icon.stop()  # Ensure tray icon is removed
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username is set."""
        if username:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username is set
    root.after(1000, check_ready)

    # Bind Enter key to Set Username button
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    # **Enhancement 3: Add a button to minimize to system tray**
    def minimize_to_tray():
        root.withdraw()
        tray_icon.visible = True

    # Create tray icon
    def create_tray_icon():
        image = PIL.Image.new('RGB', (64, 64), color='blue')
        draw = PIL.ImageDraw.Draw(image)
        draw.rectangle((0, 0, 64, 64), fill='blue')
        draw.text((10, 25), "CT", fill='white')  # Example text
        menu = (
            item('Restore', restore_window),
            item('Exit', exit_application)
        )
        tray = pystray.Icon("ClipHilarity Sync", image, "ClipHilarity Sync", menu)
        return tray

    def restore_window(icon, item):
        icon.visible = False
        root.deiconify()

    def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)



2024-11-05 18:10:36,957 - ERROR - Error receiving clipboard content: name 'log_activity' is not defined
2024-11-05 18:11:05,543 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 18:11:05,543 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 18:11:05,543 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 18:11:05,543 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 18:11:05,979 - DEBUG - Listening for clipboard updates on port 15412...
2024-11-05 18:11:05,979 - DEBUG - Listening for connection requests on port 15411...
2024-11-05 18:11:05,979 - DEBUG - Listening for connection responses and username updates on port 15413...
2024-11-05 18:11:05,982 - DEBUG - Importing BlpImagePlugin
2024-11-05 18:11:05,983 - DEBUG - Importing BmpImagePlugin
2024-11-05 18:11:05,983 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 18:11:05,984 - DEBUG - Importing CurImagePlugin
2024-11-05 18:11:05,984 - DEBUG - Importing DcxImagePlugin
2024-11-05 18:11:05,985 - DEBUG - Importing DdsImagePlugin
2024-11-05 18:11:05,988 - DEBUG - Importing EpsImagePlugin
2024-11-05 18:11:05,989 - DEBUG - Importing FitsImagePlugin
2024-11-05 18:11:05,990 - DEBUG - Importing FliImagePlugin
2024-11-05 18:11:05,991 - DEBUG - Importing FpxImagePlugin
2024-11-05 18:11:05,992 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 18:11:05,992 - DEBUG - Importing FtexImagePlugin
2024-11-05 18:11:05,992 - DEBUG - Importing GbrImagePlugin
2024-11-05 18:11:05,993 - DEBUG - Importing GifImagePlugin
2024-11-05 18:11:05,993 - DEBUG - Importing GribStubImagePlugin
2024-11-05 18:11:05,993 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 18:11:05,994 - DEBUG - Importing IcnsImagePlugin
2024-11-05 18:11:05,995 - DEBUG - Importing IcoImagePlugin
2024-11-05 18:11:05,996 - DEBUG - Importing ImImagePlugin
2024-11-05 18:11:05,997 - DEBUG - Importing ImtImagePlugin
2024-11-05 18:11:05,997 - DEBUG - Importing IptcImagePlugin
2024-11-05 18:11:05,998 - DEBUG - Importing JpegImagePlugin
2024-11-05 18:11:05,998 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 18:11:05,998 - DEBUG - Importing McIdasImagePlugin
2024-11-05 18:11:05,998 - DEBUG - Importing MicImagePlugin
2024-11-05 18:11:05,999 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 18:11:05,999 - DEBUG - Importing MpegImagePlugin
2024-11-05 18:11:05,999 - DEBUG - Importing MpoImagePlugin
2024-11-05 18:11:06,004 - DEBUG - Importing MspImagePlugin
2024-11-05 18:11:06,004 - DEBUG - Importing PalmImagePlugin
2024-11-05 18:11:06,005 - DEBUG - Importing PcdImagePlugin
2024-11-05 18:11:06,005 - DEBUG - Importing PcxImagePlugin
2024-11-05 18:11:06,005 - DEBUG - Importing PdfImagePlugin
2024-11-05 18:11:06,009 - DEBUG - Importing PixarImagePlugin
2024-11-05 18:11:06,010 - DEBUG - Importing PngImagePlugin
2024-11-05 18:11:06,010 - DEBUG - Importing PpmImagePlugin
2024-11-05 18:11:06,010 - DEBUG - Importing PsdImagePlugin
2024-11-05 18:11:06,010 - DEBUG - Importing QoiImagePlugin
2024-11-05 18:11:06,011 - DEBUG - Importing SgiImagePlugin
2024-11-05 18:11:06,011 - DEBUG - Importing SpiderImagePlugin
2024-11-05 18:11:06,011 - DEBUG - Importing SunImagePlugin
2024-11-05 18:11:06,012 - DEBUG - Importing TgaImagePlugin
2024-11-05 18:11:06,012 - DEBUG - Importing TiffImagePlugin
2024-11-05 18:11:06,012 - DEBUG - Importing WebPImagePlugin
2024-11-05 18:11:06,013 - DEBUG - Importing WmfImagePlugin
2024-11-05 18:11:06,013 - DEBUG - Importing XbmImagePlugin
2024-11-05 18:11:06,014 - DEBUG - Importing XpmImagePlugin
2024-11-05 18:11:06,014 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 18:11:06,032 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import ImageDraw
from PIL import Image, ImageTk, ImageDraw
import ctypes
import logging  # For debugging purposes
import pystray  # For system tray integration
from pystray import MenuItem as item
import PIL.Image  # For creating tray icon images

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
LISTENING_PORT = 15411   # Port for continuously listening to incoming requests
SENDING_PORT = 15413     # Port for sending requests and receiving acknowledgments
CLIPBOARD_PORT = 15412   # Port for clipboard data transfer
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet


TARGET_USERS = {}  # Dictionary to store target IPs and their details

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_USERS:
                            sock.sendto(message.encode('utf-8'), (ip, CLIPBOARD_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', CLIPBOARD_PORT))
            logging.debug(f"Listening for clipboard updates on port {CLIPBOARD_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CLIPBOARD_PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update TARGET_USERS with username and copy count
                            if addr[0] in TARGET_USERS:
                                TARGET_USERS[addr[0]]['username'] = received_username
                                TARGET_USERS[addr[0]]['copy_count'] += 1
                            else:
                                TARGET_USERS[addr[0]] = {'port': addr[1], 'copy_count': 1, 'username': received_username}
                                # Assign color to new user
                                if received_username not in user_colors:
                                    user_colors[received_username] = get_next_color()
                                update_connected_users_display()
                            # Log the activity
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static LISTENING_PORT
            sock.bind(('', LISTENING_PORT))
            logging.debug(f"Listening for connection requests on port {LISTENING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {LISTENING_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == LISTENING_PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), (addr[0], sender_port))
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0, 'username': 'Unknown'}
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], sender_port)
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses and username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on the static SENDING_PORT
            sock.bind(('', SENDING_PORT))
            logging.debug(f"Listening for connection responses and username updates on port {SENDING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {SENDING_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': SENDING_PORT, 'copy_count': 0, 'username': responder_username}
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{SENDING_PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{SENDING_PORT}! ")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{SENDING_PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                elif received_message.startswith("USERNAME_UPDATE:"):
                    new_username = received_message.split(':', 1)[1]
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling incoming messages: {e}")

def send_connection_request(target_ip):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{SENDING_PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, LISTENING_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{LISTENING_PORT}")
            # Removed binding to SENDING_PORT and waiting for response
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            if isinstance(e, socket.error) and e.errno == 10048:
                custom_error_popup("Port In Use",
                                   f"Port {SENDING_PORT} is already in use. Please set a different port.")
            else:
                custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, target_port))
            logging.debug(f"Sent username update to {target_ip}:{target_port}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses and username updates
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info.get('copy_count', 0)))

# GUI Setup
def main():
    global root, username, connected_users_tree, log_text, pause_button, tray_icon

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry (disabled since now using static ports)
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144", state='disabled')  # Disable port entry
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{LISTENING_PORT}", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 15412
            invite_window.destroy()
            send_connection_request(target_ip)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling with my buddies anyone else wanna join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            tray_icon.stop()  # Ensure tray icon is removed
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username is set."""
        if username:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username is set
    root.after(1000, check_ready)

    # Bind Enter key to Set Username button
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    # **Enhancement 3: Add a button to minimize to system tray**
    def minimize_to_tray():
        root.withdraw()
        tray_icon.visible = True

    # Create tray icon
    def create_tray_icon():
        image = PIL.Image.new('RGB', (64, 64), color='blue')
        draw = PIL.ImageDraw.Draw(image)
        draw.rectangle((0, 0, 64, 64), fill='blue')
        draw.text((10, 25), "CT", fill='white')  # Example text
        menu = (
            item('Restore', restore_window),
            item('Exit', exit_application)
        )
        tray = pystray.Icon("ClipHilarity Sync", image, "ClipHilarity Sync", menu)
        return tray

    def restore_window(icon, item):
        icon.visible = False
        root.deiconify()

    def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)



2024-11-05 18:11:36,989 - DEBUG - Received connection request from 192.168.1.26:57931: REQUEST_CONNECTION:15413
2024-11-05 18:11:38,391 - DEBUG - Accepted connection from 192.168.1.26:15413
2024-11-05 18:11:38,392 - ERROR - Error handling connection request: name 'log_activity' is not defined
2024-11-05 18:11:44,144 - DEBUG - Received clipboard content from 192.168.1.26:60152:     # Keep the threads running in the background even after closing the GUI

2024-11-05 18:11:44,144 - DEBUG - Updating local clipboard with received content...
2024-11-05 18:11:44,154 - DEBUG - Clipboard updated from network:     # Keep the threads running in the background even after closing the GUI

2024-11-05 18:11:44,155 - ERROR - Error receiving clipboard content: name 'log_activity' is not defined
2024-11-05 18:11:55,538 - DEBUG - Broadcasting clipboard content:     # Start the threads for clipboard sync and connection handling

2024-11-05 18:11:58,480 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import ImageDraw
from PIL import Image, ImageTk, ImageDraw
import ctypes
import logging  # For debugging purposes
import pystray  # For system tray integration
from pystray import MenuItem as item
import PIL.Image  # For creating tray icon images

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
LISTENING_PORT = 15411   # Port for continuously listening to incoming requests
SENDING_PORT = 15413     # Port for sending requests and receiving acknowledgments
CLIPBOARD_PORT = 15412   # Port for clipboard data transfer
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet


TARGET_USERS = {}  # Dictionary to store target IPs and their details

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_USERS:
                            sock.sendto(message.encode('utf-8'), (ip, CLIPBOARD_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', CLIPBOARD_PORT))
            logging.debug(f"Listening for clipboard updates on port {CLIPBOARD_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CLIPBOARD_PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update TARGET_USERS with username and copy count
                            if addr[0] in TARGET_USERS:
                                TARGET_USERS[addr[0]]['username'] = received_username
                                TARGET_USERS[addr[0]]['copy_count'] += 1
                            else:
                                TARGET_USERS[addr[0]] = {'port': addr[1], 'copy_count': 1, 'username': received_username}
                                # Assign color to new user
                                if received_username not in user_colors:
                                    user_colors[received_username] = get_next_color()
                                update_connected_users_display()
                            # Log the activity
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static LISTENING_PORT
            sock.bind(('', LISTENING_PORT))
            logging.debug(f"Listening for connection requests on port {LISTENING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {LISTENING_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == LISTENING_PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), (addr[0], sender_port))
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0, 'username': 'Unknown'}
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], sender_port)
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses and username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on the static SENDING_PORT
            sock.bind(('', SENDING_PORT))
            logging.debug(f"Listening for connection responses and username updates on port {SENDING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {SENDING_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': SENDING_PORT, 'copy_count': 0, 'username': responder_username}
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{SENDING_PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{SENDING_PORT}! ")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{SENDING_PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                elif received_message.startswith("USERNAME_UPDATE:"):
                    new_username = received_message.split(':', 1)[1]
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling incoming messages: {e}")

def send_connection_request(target_ip):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{SENDING_PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, LISTENING_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{LISTENING_PORT}")
            # Removed binding to SENDING_PORT and waiting for response
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            if isinstance(e, socket.error) and e.errno == 10048:
                custom_error_popup("Port In Use",
                                   f"Port {SENDING_PORT} is already in use. Please set a different port.")
            else:
                custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, target_port))
            logging.debug(f"Sent username update to {target_ip}:{target_port}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses and username updates
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info.get('copy_count', 0)))

# GUI Setup
def main():
    global root, username, connected_users_tree, log_text, pause_button, tray_icon

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry (disabled since now using static ports)
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144", state='disabled')  # Disable port entry
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{LISTENING_PORT}", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 15412
            invite_window.destroy()
            send_connection_request(target_ip)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling with my buddies anyone else wanna join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            tray_icon.stop()  # Ensure tray icon is removed
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username is set."""
        if username:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username is set
    root.after(1000, check_ready)

    # Bind Enter key to Set Username button
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    # **Enhancement 3: Add a button to minimize to system tray**
    def minimize_to_tray():
        root.withdraw()
        tray_icon.visible = True

    # Create tray icon
    def create_tray_icon():
        image = PIL.Image.new('RGB', (64, 64), color='blue')
        draw = PIL.ImageDraw.Draw(image)
        draw.rectangle((0, 0, 64, 64), fill='blue')
        draw.text((10, 25), "CT", fill='white')  # Example text
        menu = (
            item('Restore', restore_window),
            item('Exit', exit_application)
        )
        tray = pystray.Icon("ClipHilarity Sync", image, "ClipHilarity Sync", menu)
        return tray

    def restore_window(icon, item):
        icon.visible = False
        root.deiconify()

    def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)



2024-11-05 18:15:13,691 - DEBUG - Received clipboard content from 192.168.1.26:54143: both of then still not working and the dynamic port is now gone


2024-11-05 18:15:13,691 - DEBUG - Updating local clipboard with received content...
2024-11-05 18:15:13,702 - DEBUG - Clipboard updated from network: both of then still not working and the dynamic port is now gone


2024-11-05 18:15:13,702 - ERROR - Error receiving clipboard content: name 'log_activity' is not defined
2024-11-05 18:17:11,028 - DEBUG - Received clipboard content from 192.168.1.26:54648: both of them connection log (it should show the logs with username of the person then the text they copyed) and copy cound still not working and the dynamic port is now gone


2024-11-05 18:17:11,028 - DEBUG - Updating local clipboard with received content...
2024-11-05 18:17:11,037 - DEBUG - Clipboard updated from network: both of them connection log (it should show the logs with username of the person then the text they copyed) and copy cound still not working and the dynamic port is now gone


2024-11-05 18:17:11,037 - ERROR - Error receiving clipboard content: name 'log_activity' is not defined
2024-11-05 18:17:48,308 - DEBUG - Received clipboard content from 192.168.1.26:50884: 

2024-11-05 18:17:48,309 - DEBUG - Updating local clipboard with received content...
2024-11-05 18:17:48,315 - DEBUG - Clipboard updated from network: 

2024-11-05 18:17:48,315 - ERROR - Error receiving clipboard content: name 'log_activity' is not defined
2024-11-05 18:17:52,594 - DEBUG - Received clipboard content from 192.168.1.26:56282: both of them connection log (it should show the logs with username of the person then the text they copyed) and copy cound still not working and the dynamic port is now gone


2024-11-05 18:17:52,594 - DEBUG - Updating local clipboard with received content...
2024-11-05 18:17:52,602 - DEBUG - Clipboard updated from network: both of them connection log (it should show the logs with username of the person then the text they copyed) and copy cound still not working and the dynamic port is now gone


2024-11-05 18:17:52,603 - ERROR - Error receiving clipboard content: name 'log_activity' is not defined
2024-11-05 18:19:15,779 - DEBUG - Received clipboard content from 192.168.1.26:58598: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import ImageDraw
from PIL import Image, ImageTk, ImageDraw
import ctypes
import logging  # For debugging purposes
import pystray  # For system tray integration
from pystray import MenuItem as item
import PIL.Image  # For creating tray icon images

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
LISTENING_PORT = 15411   # Port for continuously listening to incoming requests
SENDING_PORT = 15413     # Port for sending requests and receiving acknowledgments
CLIPBOARD_PORT = 15412   # Port for clipboard data transfer
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet


TARGET_USERS = {}  # Dictionary to store target IPs and their details

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_USERS:
                            sock.sendto(message.encode('utf-8'), (ip, CLIPBOARD_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', CLIPBOARD_PORT))
            logging.debug(f"Listening for clipboard updates on port {CLIPBOARD_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CLIPBOARD_PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update TARGET_USERS with username and copy count
                            if addr[0] in TARGET_USERS:
                                TARGET_USERS[addr[0]]['username'] = received_username
                                TARGET_USERS[addr[0]]['copy_count'] += 1
                                update_connected_users_display()  # Update display after incrementing copy_count
                            else:
                                TARGET_USERS[addr[0]] = {'port': addr[1], 'copy_count': 1, 'username': received_username}
                                # Assign color to new user
                                if received_username not in user_colors:
                                    user_colors[received_username] = get_next_color()
                                update_connected_users_display()
                            # Log the activity with username and copied text
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static LISTENING_PORT
            sock.bind(('', LISTENING_PORT))
            logging.debug(f"Listening for connection requests on port {LISTENING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {LISTENING_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == LISTENING_PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), (addr[0], sender_port))
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0, 'username': 'Unknown'}
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], sender_port)
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses and username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on the static SENDING_PORT
            sock.bind(('', SENDING_PORT))
            logging.debug(f"Listening for connection responses and username updates on port {SENDING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {SENDING_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': SENDING_PORT, 'copy_count': 0, 'username': responder_username}
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{SENDING_PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{SENDING_PORT}! ")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{SENDING_PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                elif received_message.startswith("USERNAME_UPDATE:"):
                    new_username = received_message.split(':', 1)[1]
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling incoming messages: {e}")

def send_connection_request(target_ip):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{SENDING_PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, LISTENING_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{LISTENING_PORT}")
            # Removed binding to SENDING_PORT and waiting for response
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            if isinstance(e, socket.error) and e.errno == 10048:
                custom_error_popup("Port In Use",
                                   f"Port {SENDING_PORT} is already in use. Please set a different port.")
            else:
                custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, target_port))
            logging.debug(f"Sent username update to {target_ip}:{target_port}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses and username updates
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info.get('copy_count', 0)))

# GUI Setup
def main():
    global root, username, connected_users_tree, log_text, pause_button, tray_icon

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry (disabled since now using static ports)
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144", state='disabled')  # Disable port entry
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{LISTENING_PORT}", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 15412
            invite_window.destroy()
            send_connection_request(target_ip)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling with my buddies anyone else wanna join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        """Logs activities in the GUI with the user's color."""
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)
        logging.info(log_entry.strip())  # Add this line to log to the file

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            tray_icon.stop()  # Ensure tray icon is removed
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username is set."""
        if username:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username is set
    root.after(1000, check_ready)

    # Bind Enter key to Set Username button
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    # **Enhancement 3: Add a button to minimize to system tray**
    def minimize_to_tray():
        root.withdraw()
        tray_icon.visible = True

    # Create tray icon
    def create_tray_icon():
        image = PIL.Image.new('RGB', (64, 64), color='blue')
        draw = PIL.ImageDraw.Draw(image)
        draw.rectangle((0, 0, 64, 64), fill='blue')
        draw.text((10, 25), "CT", fill='white')  # Example text
        menu = (
            item('Restore', restore_window),
            item('Exit', exit_application)
        )
        tray = pystray.Icon("ClipHilarity Sync", image, "ClipHilarity Sync", menu)
        return tray

    def restore_window(icon, item):
        icon.visible = False
        root.deiconify()

    def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)



2024-11-05 18:19:15,780 - DEBUG - Updating local clipboard with received content...
2024-11-05 18:19:15,788 - DEBUG - Clipboard updated from network: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import ImageDraw
from PIL import Image, ImageTk, ImageDraw
import ctypes
import logging  # For debugging purposes
import pystray  # For system tray integration
from pystray import MenuItem as item
import PIL.Image  # For creating tray icon images

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
LISTENING_PORT = 15411   # Port for continuously listening to incoming requests
SENDING_PORT = 15413     # Port for sending requests and receiving acknowledgments
CLIPBOARD_PORT = 15412   # Port for clipboard data transfer
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet


TARGET_USERS = {}  # Dictionary to store target IPs and their details

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_USERS:
                            sock.sendto(message.encode('utf-8'), (ip, CLIPBOARD_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', CLIPBOARD_PORT))
            logging.debug(f"Listening for clipboard updates on port {CLIPBOARD_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CLIPBOARD_PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update TARGET_USERS with username and copy count
                            if addr[0] in TARGET_USERS:
                                TARGET_USERS[addr[0]]['username'] = received_username
                                TARGET_USERS[addr[0]]['copy_count'] += 1
                                update_connected_users_display()  # Update display after incrementing copy_count
                            else:
                                TARGET_USERS[addr[0]] = {'port': addr[1], 'copy_count': 1, 'username': received_username}
                                # Assign color to new user
                                if received_username not in user_colors:
                                    user_colors[received_username] = get_next_color()
                                update_connected_users_display()
                            # Log the activity with username and copied text
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static LISTENING_PORT
            sock.bind(('', LISTENING_PORT))
            logging.debug(f"Listening for connection requests on port {LISTENING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {LISTENING_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == LISTENING_PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), (addr[0], sender_port))
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0, 'username': 'Unknown'}
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], sender_port)
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses and username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on the static SENDING_PORT
            sock.bind(('', SENDING_PORT))
            logging.debug(f"Listening for connection responses and username updates on port {SENDING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {SENDING_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': SENDING_PORT, 'copy_count': 0, 'username': responder_username}
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{SENDING_PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{SENDING_PORT}! ")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{SENDING_PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                elif received_message.startswith("USERNAME_UPDATE:"):
                    new_username = received_message.split(':', 1)[1]
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling incoming messages: {e}")

def send_connection_request(target_ip):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{SENDING_PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, LISTENING_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{LISTENING_PORT}")
            # Removed binding to SENDING_PORT and waiting for response
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            if isinstance(e, socket.error) and e.errno == 10048:
                custom_error_popup("Port In Use",
                                   f"Port {SENDING_PORT} is already in use. Please set a different port.")
            else:
                custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, target_port))
            logging.debug(f"Sent username update to {target_ip}:{target_port}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses and username updates
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info.get('copy_count', 0)))

# GUI Setup
def main():
    global root, username, connected_users_tree, log_text, pause_button, tray_icon

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry (disabled since now using static ports)
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144", state='disabled')  # Disable port entry
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{LISTENING_PORT}", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 15412
            invite_window.destroy()
            send_connection_request(target_ip)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling with my buddies anyone else wanna join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        """Logs activities in the GUI with the user's color."""
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)
        logging.info(log_entry.strip())  # Add this line to log to the file

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            tray_icon.stop()  # Ensure tray icon is removed
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username is set."""
        if username:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username is set
    root.after(1000, check_ready)

    # Bind Enter key to Set Username button
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    # **Enhancement 3: Add a button to minimize to system tray**
    def minimize_to_tray():
        root.withdraw()
        tray_icon.visible = True

    # Create tray icon
    def create_tray_icon():
        image = PIL.Image.new('RGB', (64, 64), color='blue')
        draw = PIL.ImageDraw.Draw(image)
        draw.rectangle((0, 0, 64, 64), fill='blue')
        draw.text((10, 25), "CT", fill='white')  # Example text
        menu = (
            item('Restore', restore_window),
            item('Exit', exit_application)
        )
        tray = pystray.Icon("ClipHilarity Sync", image, "ClipHilarity Sync", menu)
        return tray

    def restore_window(icon, item):
        icon.visible = False
        root.deiconify()

    def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)



2024-11-05 18:19:15,789 - ERROR - Error receiving clipboard content: name 'log_activity' is not defined
2024-11-05 18:19:38,209 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 18:19:38,209 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 18:19:38,209 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 18:19:38,209 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 18:19:38,668 - DEBUG - Listening for clipboard updates on port 15412...
2024-11-05 18:19:38,669 - DEBUG - Listening for connection requests on port 15411...
2024-11-05 18:19:38,669 - DEBUG - Listening for connection responses and username updates on port 15413...
2024-11-05 18:19:38,671 - DEBUG - Importing BlpImagePlugin
2024-11-05 18:19:38,672 - DEBUG - Importing BmpImagePlugin
2024-11-05 18:19:38,672 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 18:19:38,672 - DEBUG - Importing CurImagePlugin
2024-11-05 18:19:38,673 - DEBUG - Importing DcxImagePlugin
2024-11-05 18:19:38,674 - DEBUG - Importing DdsImagePlugin
2024-11-05 18:19:38,677 - DEBUG - Importing EpsImagePlugin
2024-11-05 18:19:38,677 - DEBUG - Importing FitsImagePlugin
2024-11-05 18:19:38,679 - DEBUG - Importing FliImagePlugin
2024-11-05 18:19:38,679 - DEBUG - Importing FpxImagePlugin
2024-11-05 18:19:38,680 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 18:19:38,680 - DEBUG - Importing FtexImagePlugin
2024-11-05 18:19:38,681 - DEBUG - Importing GbrImagePlugin
2024-11-05 18:19:38,681 - DEBUG - Importing GifImagePlugin
2024-11-05 18:19:38,681 - DEBUG - Importing GribStubImagePlugin
2024-11-05 18:19:38,681 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 18:19:38,682 - DEBUG - Importing IcnsImagePlugin
2024-11-05 18:19:38,683 - DEBUG - Importing IcoImagePlugin
2024-11-05 18:19:38,684 - DEBUG - Importing ImImagePlugin
2024-11-05 18:19:38,685 - DEBUG - Importing ImtImagePlugin
2024-11-05 18:19:38,686 - DEBUG - Importing IptcImagePlugin
2024-11-05 18:19:38,686 - DEBUG - Importing JpegImagePlugin
2024-11-05 18:19:38,686 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 18:19:38,686 - DEBUG - Importing McIdasImagePlugin
2024-11-05 18:19:38,687 - DEBUG - Importing MicImagePlugin
2024-11-05 18:19:38,688 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 18:19:38,688 - DEBUG - Importing MpegImagePlugin
2024-11-05 18:19:38,688 - DEBUG - Importing MpoImagePlugin
2024-11-05 18:19:38,693 - DEBUG - Importing MspImagePlugin
2024-11-05 18:19:38,693 - DEBUG - Importing PalmImagePlugin
2024-11-05 18:19:38,694 - DEBUG - Importing PcdImagePlugin
2024-11-05 18:19:38,694 - DEBUG - Importing PcxImagePlugin
2024-11-05 18:19:38,694 - DEBUG - Importing PdfImagePlugin
2024-11-05 18:19:38,698 - DEBUG - Importing PixarImagePlugin
2024-11-05 18:19:38,699 - DEBUG - Importing PngImagePlugin
2024-11-05 18:19:38,699 - DEBUG - Importing PpmImagePlugin
2024-11-05 18:19:38,699 - DEBUG - Importing PsdImagePlugin
2024-11-05 18:19:38,699 - DEBUG - Importing QoiImagePlugin
2024-11-05 18:19:38,700 - DEBUG - Importing SgiImagePlugin
2024-11-05 18:19:38,700 - DEBUG - Importing SpiderImagePlugin
2024-11-05 18:19:38,701 - DEBUG - Importing SunImagePlugin
2024-11-05 18:19:38,701 - DEBUG - Importing TgaImagePlugin
2024-11-05 18:19:38,701 - DEBUG - Importing TiffImagePlugin
2024-11-05 18:19:38,702 - DEBUG - Importing WebPImagePlugin
2024-11-05 18:19:38,702 - DEBUG - Importing WmfImagePlugin
2024-11-05 18:19:38,703 - DEBUG - Importing XbmImagePlugin
2024-11-05 18:19:38,704 - DEBUG - Importing XpmImagePlugin
2024-11-05 18:19:38,704 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 18:19:38,721 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import ImageDraw
from PIL import Image, ImageTk, ImageDraw
import ctypes
import logging  # For debugging purposes
import pystray  # For system tray integration
from pystray import MenuItem as item
import PIL.Image  # For creating tray icon images

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
LISTENING_PORT = 15411   # Port for continuously listening to incoming requests
SENDING_PORT = 15413     # Port for sending requests and receiving acknowledgments
CLIPBOARD_PORT = 15412   # Port for clipboard data transfer
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet


TARGET_USERS = {}  # Dictionary to store target IPs and their details

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_USERS:
                            sock.sendto(message.encode('utf-8'), (ip, CLIPBOARD_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', CLIPBOARD_PORT))
            logging.debug(f"Listening for clipboard updates on port {CLIPBOARD_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CLIPBOARD_PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update TARGET_USERS with username and copy count
                            if addr[0] in TARGET_USERS:
                                TARGET_USERS[addr[0]]['username'] = received_username
                                TARGET_USERS[addr[0]]['copy_count'] += 1
                                update_connected_users_display()  # Update display after incrementing copy_count
                            else:
                                TARGET_USERS[addr[0]] = {'port': addr[1], 'copy_count': 1, 'username': received_username}
                                # Assign color to new user
                                if received_username not in user_colors:
                                    user_colors[received_username] = get_next_color()
                                update_connected_users_display()
                            # Log the activity with username and copied text
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static LISTENING_PORT
            sock.bind(('', LISTENING_PORT))
            logging.debug(f"Listening for connection requests on port {LISTENING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {LISTENING_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == LISTENING_PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), (addr[0], sender_port))
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0, 'username': 'Unknown'}
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], sender_port)
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses and username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on the static SENDING_PORT
            sock.bind(('', SENDING_PORT))
            logging.debug(f"Listening for connection responses and username updates on port {SENDING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {SENDING_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': SENDING_PORT, 'copy_count': 0, 'username': responder_username}
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{SENDING_PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{SENDING_PORT}! ")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{SENDING_PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                elif received_message.startswith("USERNAME_UPDATE:"):
                    new_username = received_message.split(':', 1)[1]
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling incoming messages: {e}")

def send_connection_request(target_ip):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{SENDING_PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, LISTENING_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{LISTENING_PORT}")
            # Removed binding to SENDING_PORT and waiting for response
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            if isinstance(e, socket.error) and e.errno == 10048:
                custom_error_popup("Port In Use",
                                   f"Port {SENDING_PORT} is already in use. Please set a different port.")
            else:
                custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, target_port))
            logging.debug(f"Sent username update to {target_ip}:{target_port}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses and username updates
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info.get('copy_count', 0)))

# GUI Setup
def main():
    global root, username, connected_users_tree, log_text, pause_button, tray_icon

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry (disabled since now using static ports)
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144", state='disabled')  # Disable port entry
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{LISTENING_PORT}", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 15412
            invite_window.destroy()
            send_connection_request(target_ip)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling with my buddies anyone else wanna join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        """Logs activities in the GUI with the user's color."""
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)
        logging.info(log_entry.strip())  # Add this line to log to the file

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            tray_icon.stop()  # Ensure tray icon is removed
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username is set."""
        if username:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username is set
    root.after(1000, check_ready)

    # Bind Enter key to Set Username button
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    # **Enhancement 3: Add a button to minimize to system tray**
    def minimize_to_tray():
        root.withdraw()
        tray_icon.visible = True

    # Create tray icon
    def create_tray_icon():
        image = PIL.Image.new('RGB', (64, 64), color='blue')
        draw = PIL.ImageDraw.Draw(image)
        draw.rectangle((0, 0, 64, 64), fill='blue')
        draw.text((10, 25), "CT", fill='white')  # Example text
        menu = (
            item('Restore', restore_window),
            item('Exit', exit_application)
        )
        tray = pystray.Icon("ClipHilarity Sync", image, "ClipHilarity Sync", menu)
        return tray

    def restore_window(icon, item):
        icon.visible = False
        root.deiconify()

    def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)



2024-11-05 18:20:01,860 - DEBUG - Received connection request from 192.168.1.26:65200: REQUEST_CONNECTION:15413
2024-11-05 18:20:03,481 - DEBUG - Accepted connection from 192.168.1.26:15413
2024-11-05 18:20:03,482 - ERROR - Error handling connection request: name 'log_activity' is not defined
2024-11-05 18:20:09,922 - DEBUG - Broadcasting clipboard content: 
if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)



2024-11-05 18:22:49,632 - DEBUG - Broadcasting clipboard content:     # Start the tray icon thread

2024-11-05 18:22:52,171 - DEBUG - Broadcasting clipboard content:     # Start the threads for clipboard sync and connection handling

2024-11-05 18:22:54,149 - DEBUG - Broadcasting clipboard content:     while True:

2024-11-05 18:22:55,536 - DEBUG - Broadcasting clipboard content:     main()

2024-11-05 18:22:56,955 - DEBUG - Broadcasting clipboard content:     def show_tray_icon():

2024-11-05 18:23:01,192 - DEBUG - Received clipboard content from 192.168.1.26:57419: which is the best ai to work on python code
2024-11-05 18:23:01,193 - DEBUG - Updating local clipboard with received content...
2024-11-05 18:23:01,200 - DEBUG - Clipboard updated from network: which is the best ai to work on python code
2024-11-05 18:23:01,204 - ERROR - Error receiving clipboard content: name 'log_activity' is not defined
2024-11-05 18:23:09,435 - DEBUG - Received clipboard content from 192.168.1.26:55202: which is the best ai to work on python code for free
2024-11-05 18:23:09,435 - DEBUG - Updating local clipboard with received content...
2024-11-05 18:23:09,444 - DEBUG - Clipboard updated from network: which is the best ai to work on python code for free
2024-11-05 18:23:09,450 - ERROR - Error receiving clipboard content: name 'log_activity' is not defined
2024-11-06 12:57:05,827 - DEBUG - STREAM b'IHDR' 16 13
2024-11-06 12:57:05,827 - DEBUG - STREAM b'pHYs' 41 9
2024-11-06 12:57:05,827 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-06 12:57:05,827 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-06 12:57:06,367 - DEBUG - Listening for connection requests on port 15411...
2024-11-06 12:57:06,367 - DEBUG - Listening for clipboard updates on port 15412...
2024-11-06 12:57:06,367 - DEBUG - Listening for connection responses and username updates on port 15413...
2024-11-06 12:57:06,369 - DEBUG - Importing BlpImagePlugin
2024-11-06 12:57:06,370 - DEBUG - Importing BmpImagePlugin
2024-11-06 12:57:06,370 - DEBUG - Importing BufrStubImagePlugin
2024-11-06 12:57:06,372 - DEBUG - Importing CurImagePlugin
2024-11-06 12:57:06,372 - DEBUG - Importing DcxImagePlugin
2024-11-06 12:57:06,373 - DEBUG - Importing DdsImagePlugin
2024-11-06 12:57:06,375 - DEBUG - Importing EpsImagePlugin
2024-11-06 12:57:06,376 - DEBUG - Importing FitsImagePlugin
2024-11-06 12:57:06,377 - DEBUG - Importing FliImagePlugin
2024-11-06 12:57:06,378 - DEBUG - Importing FpxImagePlugin
2024-11-06 12:57:06,378 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-06 12:57:06,379 - DEBUG - Importing FtexImagePlugin
2024-11-06 12:57:06,379 - DEBUG - Importing GbrImagePlugin
2024-11-06 12:57:06,380 - DEBUG - Importing GifImagePlugin
2024-11-06 12:57:06,380 - DEBUG - Importing GribStubImagePlugin
2024-11-06 12:57:06,381 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-06 12:57:06,382 - DEBUG - Importing IcnsImagePlugin
2024-11-06 12:57:06,383 - DEBUG - Importing IcoImagePlugin
2024-11-06 12:57:06,384 - DEBUG - Importing ImImagePlugin
2024-11-06 12:57:06,385 - DEBUG - Importing ImtImagePlugin
2024-11-06 12:57:06,385 - DEBUG - Importing IptcImagePlugin
2024-11-06 12:57:06,386 - DEBUG - Importing JpegImagePlugin
2024-11-06 12:57:06,386 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-06 12:57:06,386 - DEBUG - Importing McIdasImagePlugin
2024-11-06 12:57:06,387 - DEBUG - Importing MicImagePlugin
2024-11-06 12:57:06,388 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-06 12:57:06,388 - DEBUG - Importing MpegImagePlugin
2024-11-06 12:57:06,388 - DEBUG - Importing MpoImagePlugin
2024-11-06 12:57:06,396 - DEBUG - Importing MspImagePlugin
2024-11-06 12:57:06,396 - DEBUG - Importing PalmImagePlugin
2024-11-06 12:57:06,397 - DEBUG - Importing PcdImagePlugin
2024-11-06 12:57:06,397 - DEBUG - Importing PcxImagePlugin
2024-11-06 12:57:06,397 - DEBUG - Importing PdfImagePlugin
2024-11-06 12:57:06,402 - DEBUG - Importing PixarImagePlugin
2024-11-06 12:57:06,402 - DEBUG - Importing PngImagePlugin
2024-11-06 12:57:06,402 - DEBUG - Importing PpmImagePlugin
2024-11-06 12:57:06,402 - DEBUG - Importing PsdImagePlugin
2024-11-06 12:57:06,403 - DEBUG - Importing QoiImagePlugin
2024-11-06 12:57:06,403 - DEBUG - Importing SgiImagePlugin
2024-11-06 12:57:06,404 - DEBUG - Importing SpiderImagePlugin
2024-11-06 12:57:06,404 - DEBUG - Importing SunImagePlugin
2024-11-06 12:57:06,404 - DEBUG - Importing TgaImagePlugin
2024-11-06 12:57:06,405 - DEBUG - Importing TiffImagePlugin
2024-11-06 12:57:06,405 - DEBUG - Importing WebPImagePlugin
2024-11-06 12:57:06,420 - DEBUG - Importing WmfImagePlugin
2024-11-06 12:57:06,420 - DEBUG - Importing XbmImagePlugin
2024-11-06 12:57:06,421 - DEBUG - Importing XpmImagePlugin
2024-11-06 12:57:06,422 - DEBUG - Importing XVThumbImagePlugin
2024-11-06 12:57:06,427 - DEBUG - Broadcasting clipboard content: wk9nmN6+
2024-11-06 12:57:20,551 - DEBUG - Sent connection request to 192.168.1.20:15411
2024-11-06 12:57:25,170 - DEBUG - Connection established with 'None' at 192.168.1.20:15413
2024-11-06 12:57:29,517 - ERROR - Error handling incoming messages: name 'log_activity' is not defined
2024-11-06 12:57:35,868 - ERROR - Error handling incoming messages: name 'log_activity' is not defined
2024-11-06 12:57:45,321 - DEBUG - Received clipboard content from 192.168.1.20:57051: import socket
import threading
import pyperclip    
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import ImageDraw
from PIL import Image, ImageTk, ImageDraw
import ctypes
import logging  # For debugging purposes
import pystray  # For system tray integration
from pystray import MenuItem as item
import PIL.Image  # For creating tray icon images

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
LISTENING_PORT = 15411   # Port for continuously listening to incoming requests
SENDING_PORT = 15413     # Port for sending requests and receiving acknowledgments
CLIPBOARD_PORT = 15412   # Port for clipboard data transfer
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet


TARGET_USERS = {}  # Dictionary to store target IPs and their details

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40 )

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_USERS:
                            sock.sendto(message.encode('utf-8'), (ip, CLIPBOARD_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', CLIPBOARD_PORT))
            logging.debug(f"Listening for clipboard updates on port {CLIPBOARD_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CLIPBOARD_PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update TARGET_USERS with username and copy count
                            if addr[0] in TARGET_USERS:
                                TARGET_USERS[addr[0]]['username'] = received_username
                                TARGET_USERS[addr[0]]['copy_count'] += 1
                                update_connected_users_display()  # Update display after incrementing copy_count
                            else:
                                TARGET_USERS[addr[0]] = {'port': addr[1], 'copy_count': 1, 'username': received_username}
                                # Assign color to new user
                                if received_username not in user_colors:
                                    user_colors[received_username] = get_next_color()
                                update_connected_users_display()
                            # Log the activity with username and copied text
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static LISTENING_PORT
            sock.bind(('', LISTENING_PORT))
            logging.debug(f"Listening for connection requests on port {LISTENING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {LISTENING_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == LISTENING_PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), (addr[0], sender_port))
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0, 'username': 'Unknown'}
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], sender_port)
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses and username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on the static SENDING_PORT
            sock.bind(('', SENDING_PORT))
            logging.debug(f"Listening for connection responses and username updates on port {SENDING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {SENDING_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': SENDING_PORT, 'copy_count': 0, 'username': responder_username}
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{SENDING_PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{SENDING_PORT}! ")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{SENDING_PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                elif received_message.startswith("USERNAME_UPDATE:"):
                    new_username = received_message.split(':', 1)[1]
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling incoming messages: {e}")

def send_connection_request(target_ip):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{SENDING_PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, LISTENING_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{LISTENING_PORT}")
            # Removed binding to SENDING_PORT and waiting for response
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            if isinstance(e, socket.error) and e.errno == 10048:
                custom_error_popup("Port In Use",
                                   f"Port {SENDING_PORT} is already in use. Please set a different port.")
            else:
                custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, target_port))
            logging.debug(f"Sent username update to {target_ip}:{target_port}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses and username updates
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info.get('copy_count', 0)))

# GUI Setup
def main():
    global root, username, connected_users_tree, log_text, pause_button, tray_icon

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry (disabled since now using static ports)
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144", state='disabled')  # Disable port entry
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{LISTENING_PORT}", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 15412
            invite_window.destroy()
            send_connection_request(target_ip)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling with my buddies anyone else wanna join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Clipboard Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    def save_clipboard_log(username, copied_text):
        """Saves clipboard logs in the format: $username $time $copied text."""
        time_stamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        log_entry = f"{username} {time_stamp} {copied_text}"
        with open('clipboard_logs.txt', 'a') as log_file:
            log_file.write(log_entry + '\n')

    def log_activity(user, message):
        """Logs clipboard activities in the GUI with the user's color."""
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        # Updated log entry format
        log_entry = f"{user} {time.strftime('%Y-%m-%d %H:%M:%S')} {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)
        logging.info(log_entry.strip())  # Add this line to log to the file
        # Save clipboard log
        save_clipboard_log(user, message)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            tray_icon.stop()  # Ensure tray icon is removed
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username is set."""
        if username:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username is set
    root.after(1000, check_ready)

    # Bind Enter key to Set Username button
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    # **Enhancement 3: Add a button to minimize to system tray**
    def minimize_to_tray():
        root.withdraw()
        tray_icon.visible = True

    # Create tray icon
    def create_tray_icon():
        image = PIL.Image.new('RGB', (64, 64), color='blue')
        draw = PIL.ImageDraw.Draw(image)
        draw.rectangle((0, 0, 64, 64), fill='blue')
        draw.text((10, 25), "CT", fill='white')  # Example text
        menu = (
            item('Restore', restore_window),
            item('Exit', exit_application)
        )
        tray = pystray.Icon("ClipHilarity Sync", image, "ClipHilarity Sync", menu)
        return tray

    def restore_window(icon, item):
        icon.visible = False
        root.deiconify()

    def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)



2024-11-06 12:57:45,321 - DEBUG - Updating local clipboard with received content...
2024-11-06 12:57:45,325 - DEBUG - Clipboard updated from network: import socket
import threading
import pyperclip    
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import ImageDraw
from PIL import Image, ImageTk, ImageDraw
import ctypes
import logging  # For debugging purposes
import pystray  # For system tray integration
from pystray import MenuItem as item
import PIL.Image  # For creating tray icon images

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
LISTENING_PORT = 15411   # Port for continuously listening to incoming requests
SENDING_PORT = 15413     # Port for sending requests and receiving acknowledgments
CLIPBOARD_PORT = 15412   # Port for clipboard data transfer
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet


TARGET_USERS = {}  # Dictionary to store target IPs and their details

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40 )

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_USERS:
                            sock.sendto(message.encode('utf-8'), (ip, CLIPBOARD_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', CLIPBOARD_PORT))
            logging.debug(f"Listening for clipboard updates on port {CLIPBOARD_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CLIPBOARD_PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update TARGET_USERS with username and copy count
                            if addr[0] in TARGET_USERS:
                                TARGET_USERS[addr[0]]['username'] = received_username
                                TARGET_USERS[addr[0]]['copy_count'] += 1
                                update_connected_users_display()  # Update display after incrementing copy_count
                            else:
                                TARGET_USERS[addr[0]] = {'port': addr[1], 'copy_count': 1, 'username': received_username}
                                # Assign color to new user
                                if received_username not in user_colors:
                                    user_colors[received_username] = get_next_color()
                                update_connected_users_display()
                            # Log the activity with username and copied text
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static LISTENING_PORT
            sock.bind(('', LISTENING_PORT))
            logging.debug(f"Listening for connection requests on port {LISTENING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {LISTENING_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == LISTENING_PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), (addr[0], sender_port))
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0, 'username': 'Unknown'}
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], sender_port)
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses and username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on the static SENDING_PORT
            sock.bind(('', SENDING_PORT))
            logging.debug(f"Listening for connection responses and username updates on port {SENDING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {SENDING_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': SENDING_PORT, 'copy_count': 0, 'username': responder_username}
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{SENDING_PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{SENDING_PORT}! ")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{SENDING_PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                elif received_message.startswith("USERNAME_UPDATE:"):
                    new_username = received_message.split(':', 1)[1]
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling incoming messages: {e}")

def send_connection_request(target_ip):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{SENDING_PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, LISTENING_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{LISTENING_PORT}")
            # Removed binding to SENDING_PORT and waiting for response
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            if isinstance(e, socket.error) and e.errno == 10048:
                custom_error_popup("Port In Use",
                                   f"Port {SENDING_PORT} is already in use. Please set a different port.")
            else:
                custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, target_port))
            logging.debug(f"Sent username update to {target_ip}:{target_port}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses and username updates
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info.get('copy_count', 0)))

# GUI Setup
def main():
    global root, username, connected_users_tree, log_text, pause_button, tray_icon

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry (disabled since now using static ports)
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144", state='disabled')  # Disable port entry
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{LISTENING_PORT}", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 15412
            invite_window.destroy()
            send_connection_request(target_ip)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling with my buddies anyone else wanna join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Clipboard Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    def save_clipboard_log(username, copied_text):
        """Saves clipboard logs in the format: $username $time $copied text."""
        time_stamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        log_entry = f"{username} {time_stamp} {copied_text}"
        with open('clipboard_logs.txt', 'a') as log_file:
            log_file.write(log_entry + '\n')

    def log_activity(user, message):
        """Logs clipboard activities in the GUI with the user's color."""
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        # Updated log entry format
        log_entry = f"{user} {time.strftime('%Y-%m-%d %H:%M:%S')} {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)
        logging.info(log_entry.strip())  # Add this line to log to the file
        # Save clipboard log
        save_clipboard_log(user, message)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            tray_icon.stop()  # Ensure tray icon is removed
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username is set."""
        if username:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username is set
    root.after(1000, check_ready)

    # Bind Enter key to Set Username button
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    # **Enhancement 3: Add a button to minimize to system tray**
    def minimize_to_tray():
        root.withdraw()
        tray_icon.visible = True

    # Create tray icon
    def create_tray_icon():
        image = PIL.Image.new('RGB', (64, 64), color='blue')
        draw = PIL.ImageDraw.Draw(image)
        draw.rectangle((0, 0, 64, 64), fill='blue')
        draw.text((10, 25), "CT", fill='white')  # Example text
        menu = (
            item('Restore', restore_window),
            item('Exit', exit_application)
        )
        tray = pystray.Icon("ClipHilarity Sync", image, "ClipHilarity Sync", menu)
        return tray

    def restore_window(icon, item):
        icon.visible = False
        root.deiconify()

    def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)



2024-11-06 12:57:45,327 - ERROR - Error receiving clipboard content: name 'log_activity' is not defined
2024-11-06 12:57:53,381 - DEBUG - STREAM b'IHDR' 16 13
2024-11-06 12:57:53,381 - DEBUG - STREAM b'pHYs' 41 9
2024-11-06 12:57:53,381 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-06 12:57:53,381 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-06 12:57:53,814 - DEBUG - Listening for clipboard updates on port 15412...
2024-11-06 12:57:53,814 - DEBUG - Listening for connection requests on port 15411...
2024-11-06 12:57:53,814 - DEBUG - Listening for connection responses and username updates on port 15413...
2024-11-06 12:57:53,816 - DEBUG - Importing BlpImagePlugin
2024-11-06 12:57:53,817 - DEBUG - Importing BmpImagePlugin
2024-11-06 12:57:53,817 - DEBUG - Importing BufrStubImagePlugin
2024-11-06 12:57:53,818 - DEBUG - Importing CurImagePlugin
2024-11-06 12:57:53,818 - DEBUG - Importing DcxImagePlugin
2024-11-06 12:57:53,819 - DEBUG - Importing DdsImagePlugin
2024-11-06 12:57:53,821 - DEBUG - Importing EpsImagePlugin
2024-11-06 12:57:53,822 - DEBUG - Importing FitsImagePlugin
2024-11-06 12:57:53,824 - DEBUG - Importing FliImagePlugin
2024-11-06 12:57:53,824 - DEBUG - Importing FpxImagePlugin
2024-11-06 12:57:53,825 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-06 12:57:53,825 - DEBUG - Importing FtexImagePlugin
2024-11-06 12:57:53,826 - DEBUG - Importing GbrImagePlugin
2024-11-06 12:57:53,827 - DEBUG - Importing GifImagePlugin
2024-11-06 12:57:53,827 - DEBUG - Importing GribStubImagePlugin
2024-11-06 12:57:53,827 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-06 12:57:53,828 - DEBUG - Importing IcnsImagePlugin
2024-11-06 12:57:53,829 - DEBUG - Importing IcoImagePlugin
2024-11-06 12:57:53,830 - DEBUG - Importing ImImagePlugin
2024-11-06 12:57:53,830 - DEBUG - Importing ImtImagePlugin
2024-11-06 12:57:53,831 - DEBUG - Importing IptcImagePlugin
2024-11-06 12:57:53,831 - DEBUG - Importing JpegImagePlugin
2024-11-06 12:57:53,831 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-06 12:57:53,831 - DEBUG - Importing McIdasImagePlugin
2024-11-06 12:57:53,832 - DEBUG - Importing MicImagePlugin
2024-11-06 12:57:53,832 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-06 12:57:53,832 - DEBUG - Importing MpegImagePlugin
2024-11-06 12:57:53,833 - DEBUG - Importing MpoImagePlugin
2024-11-06 12:57:53,837 - DEBUG - Importing MspImagePlugin
2024-11-06 12:57:53,837 - DEBUG - Importing PalmImagePlugin
2024-11-06 12:57:53,838 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip    
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import ImageDraw
from PIL import Image, ImageTk, ImageDraw
import ctypes
import logging  # For debugging purposes
import pystray  # For system tray integration
from pystray import MenuItem as item
import PIL.Image  # For creating tray icon images

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
LISTENING_PORT = 15411   # Port for continuously listening to incoming requests
SENDING_PORT = 15413     # Port for sending requests and receiving acknowledgments
CLIPBOARD_PORT = 15412   # Port for clipboard data transfer
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet


TARGET_USERS = {}  # Dictionary to store target IPs and their details

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40 )

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_USERS:
                            sock.sendto(message.encode('utf-8'), (ip, CLIPBOARD_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', CLIPBOARD_PORT))
            logging.debug(f"Listening for clipboard updates on port {CLIPBOARD_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CLIPBOARD_PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update TARGET_USERS with username and copy count
                            if addr[0] in TARGET_USERS:
                                TARGET_USERS[addr[0]]['username'] = received_username
                                TARGET_USERS[addr[0]]['copy_count'] += 1
                                update_connected_users_display()  # Update display after incrementing copy_count
                            else:
                                TARGET_USERS[addr[0]] = {'port': addr[1], 'copy_count': 1, 'username': received_username}
                                # Assign color to new user
                                if received_username not in user_colors:
                                    user_colors[received_username] = get_next_color()
                                update_connected_users_display()
                            # Log the activity with username and copied text
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static LISTENING_PORT
            sock.bind(('', LISTENING_PORT))
            logging.debug(f"Listening for connection requests on port {LISTENING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {LISTENING_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == LISTENING_PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), (addr[0], sender_port))
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0, 'username': 'Unknown'}
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], sender_port)
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses and username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on the static SENDING_PORT
            sock.bind(('', SENDING_PORT))
            logging.debug(f"Listening for connection responses and username updates on port {SENDING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {SENDING_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': SENDING_PORT, 'copy_count': 0, 'username': responder_username}
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{SENDING_PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{SENDING_PORT}! ")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{SENDING_PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                elif received_message.startswith("USERNAME_UPDATE:"):
                    new_username = received_message.split(':', 1)[1]
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling incoming messages: {e}")

def send_connection_request(target_ip):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{SENDING_PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, LISTENING_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{LISTENING_PORT}")
            # Removed binding to SENDING_PORT and waiting for response
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            if isinstance(e, socket.error) and e.errno == 10048:
                custom_error_popup("Port In Use",
                                   f"Port {SENDING_PORT} is already in use. Please set a different port.")
            else:
                custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, target_port))
            logging.debug(f"Sent username update to {target_ip}:{target_port}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses and username updates
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info.get('copy_count', 0)))

# GUI Setup
def main():
    global root, username, connected_users_tree, log_text, pause_button, tray_icon

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry (disabled since now using static ports)
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144", state='disabled')  # Disable port entry
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{LISTENING_PORT}", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 15412
            invite_window.destroy()
            send_connection_request(target_ip)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling with my buddies anyone else wanna join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Clipboard Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    def save_clipboard_log(username, copied_text):
        """Saves clipboard logs in the format: $username $time $copied text."""
        time_stamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        log_entry = f"{username} {time_stamp} {copied_text}"
        with open('clipboard_logs.txt', 'a') as log_file:
            log_file.write(log_entry + '\n')

    def log_activity(user, message):
        """Logs clipboard activities in the GUI with the user's color."""
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        # Updated log entry format
        log_entry = f"{user} {time.strftime('%Y-%m-%d %H:%M:%S')} {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)
        logging.info(log_entry.strip())  # Add this line to log to the file
        # Save clipboard log
        save_clipboard_log(user, message)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            tray_icon.stop()  # Ensure tray icon is removed
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username is set."""
        if username:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username is set
    root.after(1000, check_ready)

    # Bind Enter key to Set Username button
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    # **Enhancement 3: Add a button to minimize to system tray**
    def minimize_to_tray():
        root.withdraw()
        tray_icon.visible = True

    # Create tray icon
    def create_tray_icon():
        image = PIL.Image.new('RGB', (64, 64), color='blue')
        draw = PIL.ImageDraw.Draw(image)
        draw.rectangle((0, 0, 64, 64), fill='blue')
        draw.text((10, 25), "CT", fill='white')  # Example text
        menu = (
            item('Restore', restore_window),
            item('Exit', exit_application)
        )
        tray = pystray.Icon("ClipHilarity Sync", image, "ClipHilarity Sync", menu)
        return tray

    def restore_window(icon, item):
        icon.visible = False
        root.deiconify()

    def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)



2024-11-06 12:57:53,838 - DEBUG - Importing PcdImagePlugin
2024-11-06 12:57:53,839 - DEBUG - Importing PcxImagePlugin
2024-11-06 12:57:53,839 - DEBUG - Importing PdfImagePlugin
2024-11-06 12:57:53,843 - DEBUG - Importing PixarImagePlugin
2024-11-06 12:57:53,843 - DEBUG - Importing PngImagePlugin
2024-11-06 12:57:53,843 - DEBUG - Importing PpmImagePlugin
2024-11-06 12:57:53,843 - DEBUG - Importing PsdImagePlugin
2024-11-06 12:57:53,844 - DEBUG - Importing QoiImagePlugin
2024-11-06 12:57:53,844 - DEBUG - Importing SgiImagePlugin
2024-11-06 12:57:53,845 - DEBUG - Importing SpiderImagePlugin
2024-11-06 12:57:53,845 - DEBUG - Importing SunImagePlugin
2024-11-06 12:57:53,846 - DEBUG - Importing TgaImagePlugin
2024-11-06 12:57:53,846 - DEBUG - Importing TiffImagePlugin
2024-11-06 12:57:53,846 - DEBUG - Importing WebPImagePlugin
2024-11-06 12:57:53,847 - DEBUG - Importing WmfImagePlugin
2024-11-06 12:57:53,847 - DEBUG - Importing XbmImagePlugin
2024-11-06 12:57:53,848 - DEBUG - Importing XpmImagePlugin
2024-11-06 12:57:53,848 - DEBUG - Importing XVThumbImagePlugin
2024-11-06 12:58:32,793 - DEBUG - Sent connection request to 192.168.1.20:15411
2024-11-06 12:58:34,129 - DEBUG - Connection established with 'None' at 192.168.1.20:15413
2024-11-06 12:58:35,831 - ERROR - Error handling incoming messages: name 'log_activity' is not defined
2024-11-06 12:58:42,657 - ERROR - Error handling incoming messages: name 'log_activity' is not defined
2024-11-06 12:58:46,541 - DEBUG - Broadcasting clipboard content: 
    # Start the tray icon thread

2024-11-06 12:58:53,500 - DEBUG - Broadcasting clipboard content: 
if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)



2024-11-06 12:58:55,121 - DEBUG - Broadcasting clipboard content: tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)



2024-11-06 12:58:56,394 - DEBUG - Broadcasting clipboard content: icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
2024-11-06 12:58:58,382 - DEBUG - Broadcasting clipboard content: 
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()
2024-11-06 12:58:59,935 - DEBUG - Broadcasting clipboard content: 

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
2024-11-06 13:00:00,682 - DEBUG - Broadcasting clipboard content: 2024-11-06 12:58:35,831 - ERROR - Error handling incoming messages: name 'log_activity' is not defined
2024-11-06 12:58:42,657 - ERROR - Error handling incoming messages: name 'log_activity' is not defined

2024-11-06 13:04:05,471 - DEBUG - STREAM b'IHDR' 16 13
2024-11-06 13:04:05,471 - DEBUG - STREAM b'pHYs' 41 9
2024-11-06 13:04:05,471 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-06 13:04:05,471 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-06 13:04:05,933 - DEBUG - Listening for clipboard updates on port 15412...
2024-11-06 13:04:05,934 - DEBUG - Listening for connection requests on port 15411...
2024-11-06 13:04:05,934 - DEBUG - Listening for connection responses and username updates on port 15413...
2024-11-06 13:04:05,936 - DEBUG - Importing BlpImagePlugin
2024-11-06 13:04:05,937 - DEBUG - Importing BmpImagePlugin
2024-11-06 13:04:05,937 - DEBUG - Importing BufrStubImagePlugin
2024-11-06 13:04:05,937 - DEBUG - Importing CurImagePlugin
2024-11-06 13:04:05,937 - DEBUG - Importing DcxImagePlugin
2024-11-06 13:04:05,939 - DEBUG - Importing DdsImagePlugin
2024-11-06 13:04:05,941 - DEBUG - Importing EpsImagePlugin
2024-11-06 13:04:05,942 - DEBUG - Importing FitsImagePlugin
2024-11-06 13:04:05,943 - DEBUG - Importing FliImagePlugin
2024-11-06 13:04:05,944 - DEBUG - Importing FpxImagePlugin
2024-11-06 13:04:05,945 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-06 13:04:05,945 - DEBUG - Importing FtexImagePlugin
2024-11-06 13:04:05,945 - DEBUG - Importing GbrImagePlugin
2024-11-06 13:04:05,946 - DEBUG - Importing GifImagePlugin
2024-11-06 13:04:05,946 - DEBUG - Importing GribStubImagePlugin
2024-11-06 13:04:05,946 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-06 13:04:05,947 - DEBUG - Importing IcnsImagePlugin
2024-11-06 13:04:05,948 - DEBUG - Importing IcoImagePlugin
2024-11-06 13:04:05,949 - DEBUG - Importing ImImagePlugin
2024-11-06 13:04:05,949 - DEBUG - Importing ImtImagePlugin
2024-11-06 13:04:05,950 - DEBUG - Importing IptcImagePlugin
2024-11-06 13:04:05,951 - DEBUG - Importing JpegImagePlugin
2024-11-06 13:04:05,951 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-06 13:04:05,951 - DEBUG - Importing McIdasImagePlugin
2024-11-06 13:04:05,951 - DEBUG - Importing MicImagePlugin
2024-11-06 13:04:05,952 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-06 13:04:05,952 - DEBUG - Importing MpegImagePlugin
2024-11-06 13:04:05,952 - DEBUG - Importing MpoImagePlugin
2024-11-06 13:04:05,957 - DEBUG - Importing MspImagePlugin
2024-11-06 13:04:05,957 - DEBUG - Importing PalmImagePlugin
2024-11-06 13:04:05,958 - DEBUG - Importing PcdImagePlugin
2024-11-06 13:04:05,958 - DEBUG - Importing PcxImagePlugin
2024-11-06 13:04:05,958 - DEBUG - Importing PdfImagePlugin
2024-11-06 13:04:05,963 - DEBUG - Importing PixarImagePlugin
2024-11-06 13:04:05,964 - DEBUG - Importing PngImagePlugin
2024-11-06 13:04:05,964 - DEBUG - Importing PpmImagePlugin
2024-11-06 13:04:05,964 - DEBUG - Importing PsdImagePlugin
2024-11-06 13:04:05,964 - DEBUG - Importing QoiImagePlugin
2024-11-06 13:04:05,965 - DEBUG - Importing SgiImagePlugin
2024-11-06 13:04:05,965 - DEBUG - Importing SpiderImagePlugin
2024-11-06 13:04:05,966 - DEBUG - Importing SunImagePlugin
2024-11-06 13:04:05,966 - DEBUG - Importing TgaImagePlugin
2024-11-06 13:04:05,966 - DEBUG - Importing TiffImagePlugin
2024-11-06 13:04:05,966 - DEBUG - Importing WebPImagePlugin
2024-11-06 13:04:05,967 - DEBUG - Importing WmfImagePlugin
2024-11-06 13:04:05,967 - DEBUG - Importing XbmImagePlugin
2024-11-06 13:04:05,968 - DEBUG - Importing XpmImagePlugin
2024-11-06 13:04:05,968 - DEBUG - Importing XVThumbImagePlugin
2024-11-06 13:04:05,986 - DEBUG - Broadcasting clipboard content: 2024-11-06 12:58:35,831 - ERROR - Error handling incoming messages: name 'log_activity' is not defined
2024-11-06 12:58:42,657 - ERROR - Error handling incoming messages: name 'log_activity' is not defined

2024-11-06 13:04:15,296 - DEBUG - Sent connection request to 192.168.1.20:15411
2024-11-06 13:04:19,717 - DEBUG - Connection established with 'FontFunk' at 192.168.1.20:15413
2024-11-06 13:04:21,528 - ERROR - Error handling incoming messages: name 'log_activity' is not defined
2024-11-06 13:04:40,540 - DEBUG - STREAM b'IHDR' 16 13
2024-11-06 13:04:40,540 - DEBUG - STREAM b'pHYs' 41 9
2024-11-06 13:04:40,540 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-06 13:04:40,540 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-06 13:04:40,977 - DEBUG - Listening for clipboard updates on port 15412...
2024-11-06 13:04:40,977 - DEBUG - Listening for connection requests on port 15411...
2024-11-06 13:04:40,977 - DEBUG - Listening for connection responses and username updates on port 15413...
2024-11-06 13:04:40,979 - DEBUG - Importing BlpImagePlugin
2024-11-06 13:04:40,980 - DEBUG - Importing BmpImagePlugin
2024-11-06 13:04:40,980 - DEBUG - Importing BufrStubImagePlugin
2024-11-06 13:04:40,981 - DEBUG - Importing CurImagePlugin
2024-11-06 13:04:40,981 - DEBUG - Importing DcxImagePlugin
2024-11-06 13:04:40,983 - DEBUG - Importing DdsImagePlugin
2024-11-06 13:04:40,985 - DEBUG - Importing EpsImagePlugin
2024-11-06 13:04:40,986 - DEBUG - Importing FitsImagePlugin
2024-11-06 13:04:40,987 - DEBUG - Importing FliImagePlugin
2024-11-06 13:04:40,988 - DEBUG - Importing FpxImagePlugin
2024-11-06 13:04:40,989 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-06 13:04:40,989 - DEBUG - Importing FtexImagePlugin
2024-11-06 13:04:40,989 - DEBUG - Importing GbrImagePlugin
2024-11-06 13:04:40,990 - DEBUG - Importing GifImagePlugin
2024-11-06 13:04:40,990 - DEBUG - Importing GribStubImagePlugin
2024-11-06 13:04:40,990 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-06 13:04:40,991 - DEBUG - Importing IcnsImagePlugin
2024-11-06 13:04:40,993 - DEBUG - Importing IcoImagePlugin
2024-11-06 13:04:40,993 - DEBUG - Importing ImImagePlugin
2024-11-06 13:04:40,994 - DEBUG - Importing ImtImagePlugin
2024-11-06 13:04:40,995 - DEBUG - Importing IptcImagePlugin
2024-11-06 13:04:40,995 - DEBUG - Importing JpegImagePlugin
2024-11-06 13:04:40,995 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-06 13:04:40,995 - DEBUG - Importing McIdasImagePlugin
2024-11-06 13:04:40,996 - DEBUG - Importing MicImagePlugin
2024-11-06 13:04:40,996 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-06 13:04:40,996 - DEBUG - Importing MpegImagePlugin
2024-11-06 13:04:40,997 - DEBUG - Importing MpoImagePlugin
2024-11-06 13:04:41,001 - DEBUG - Importing MspImagePlugin
2024-11-06 13:04:41,002 - DEBUG - Importing PalmImagePlugin
2024-11-06 13:04:41,002 - DEBUG - Broadcasting clipboard content: 2024-11-06 12:58:35,831 - ERROR - Error handling incoming messages: name 'log_activity' is not defined
2024-11-06 12:58:42,657 - ERROR - Error handling incoming messages: name 'log_activity' is not defined

2024-11-06 13:04:41,002 - DEBUG - Importing PcdImagePlugin
2024-11-06 13:04:41,003 - DEBUG - Importing PcxImagePlugin
2024-11-06 13:04:41,003 - DEBUG - Importing PdfImagePlugin
2024-11-06 13:04:41,007 - DEBUG - Importing PixarImagePlugin
2024-11-06 13:04:41,007 - DEBUG - Importing PngImagePlugin
2024-11-06 13:04:41,007 - DEBUG - Importing PpmImagePlugin
2024-11-06 13:04:41,007 - DEBUG - Importing PsdImagePlugin
2024-11-06 13:04:41,008 - DEBUG - Importing QoiImagePlugin
2024-11-06 13:04:41,008 - DEBUG - Importing SgiImagePlugin
2024-11-06 13:04:41,008 - DEBUG - Importing SpiderImagePlugin
2024-11-06 13:04:41,009 - DEBUG - Importing SunImagePlugin
2024-11-06 13:04:41,009 - DEBUG - Importing TgaImagePlugin
2024-11-06 13:04:41,010 - DEBUG - Importing TiffImagePlugin
2024-11-06 13:04:41,010 - DEBUG - Importing WebPImagePlugin
2024-11-06 13:04:41,010 - DEBUG - Importing WmfImagePlugin
2024-11-06 13:04:41,011 - DEBUG - Importing XbmImagePlugin
2024-11-06 13:04:41,011 - DEBUG - Importing XpmImagePlugin
2024-11-06 13:04:41,012 - DEBUG - Importing XVThumbImagePlugin
2024-11-06 13:04:51,704 - DEBUG - Sent connection request to 192.168.1.20:15411
2024-11-06 13:04:53,107 - DEBUG - Connection established with 'None' at 192.168.1.20:15413
2024-11-06 13:04:53,551 - ERROR - Error handling incoming messages: name 'log_activity' is not defined
2024-11-06 13:04:57,973 - ERROR - Error handling incoming messages: name 'log_activity' is not defined
2024-11-06 13:05:07,576 - DEBUG - Received clipboard content from 192.168.1.20:52462: import socket
import threading
import pyperclip    
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import ImageDraw
from PIL import Image, ImageTk, ImageDraw
import ctypes
import logging  # For debugging purposes
import pystray  # For system tray integration
from pystray import MenuItem as item
import PIL.Image  # For creating tray icon images

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
LISTENING_PORT = 15411   # Port for continuously listening to incoming requests
SENDING_PORT = 15413     # Port for sending requests and receiving acknowledgments
CLIPBOARD_PORT = 15412   # Port for clipboard data transfer
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet


TARGET_USERS = {}  # Dictionary to store target IPs and their details

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40 )

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_USERS:
                            sock.sendto(message.encode('utf-8'), (ip, CLIPBOARD_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', CLIPBOARD_PORT))
            logging.debug(f"Listening for clipboard updates on port {CLIPBOARD_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CLIPBOARD_PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update TARGET_USERS with username and copy count
                            if addr[0] in TARGET_USERS:
                                TARGET_USERS[addr[0]]['username'] = received_username
                                TARGET_USERS[addr[0]]['copy_count'] += 1
                                update_connected_users_display()  # Update display after incrementing copy_count
                            else:
                                TARGET_USERS[addr[0]] = {'port': addr[1], 'copy_count': 1, 'username': received_username}
                                # Assign color to new user
                                if received_username not in user_colors:
                                    user_colors[received_username] = get_next_color()
                                update_connected_users_display()
                            # Log the activity with username and copied text
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static LISTENING_PORT
            sock.bind(('', LISTENING_PORT))
            logging.debug(f"Listening for connection requests on port {LISTENING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {LISTENING_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == LISTENING_PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), (addr[0], sender_port))
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0, 'username': 'Unknown'}
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], sender_port)
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses and username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on the static SENDING_PORT
            sock.bind(('', SENDING_PORT))
            logging.debug(f"Listening for connection responses and username updates on port {SENDING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {SENDING_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': SENDING_PORT, 'copy_count': 0, 'username': responder_username}
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{SENDING_PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{SENDING_PORT}! ")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{SENDING_PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                elif received_message.startswith("USERNAME_UPDATE:"):
                    new_username = received_message.split(':', 1)[1]
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling incoming messages: {e}")

def send_connection_request(target_ip):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{SENDING_PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, LISTENING_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{LISTENING_PORT}")
            # Removed binding to SENDING_PORT and waiting for response
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            if isinstance(e, socket.error) and e.errno == 10048:
                custom_error_popup("Port In Use",
                                   f"Port {SENDING_PORT} is already in use. Please set a different port.")
            else:
                custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, target_port))
            logging.debug(f"Sent username update to {target_ip}:{target_port}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses and username updates
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info.get('copy_count', 0)))

# Move these functions to the global scope
def save_clipboard_log(username, copied_text):
    """Saves clipboard logs in the format: $username $time $copied text."""
    time_stamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
    log_entry = f"{username} {time_stamp} {copied_text}"
    with open('clipboard_logs.txt', 'a') as log_file:
        log_file.write(log_entry + '\n')

# Declare log_text as a global variable
log_text = None

def log_activity(user, message):
    """Logs clipboard activities in the GUI with the user's color."""
    global log_text
    if log_text is None:
        logging.error("log_text widget is not initialized.")
        return

    log_text.config(state='normal')
    if user in user_colors:
        color = user_colors[user]
    else:
        color = get_next_color()
        user_colors[user] = color
    log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
    # Updated log entry format
    log_entry = f"{user} {time.strftime('%Y-%m-%d %H:%M:%S')} {message}\n"
    log_text.insert(tk.END, log_entry, user)
    log_text.config(state='disabled')
    log_text.yview(tk.END)
    logging.info(log_entry.strip())  # Log to the file
    # Save clipboard log
    save_clipboard_log(user, message)

# GUI Setup
def main():
    global root, username, connected_users_tree, log_text, pause_button, tray_icon

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry (disabled since now using static ports)
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144", state='disabled')  # Disable port entry
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{LISTENING_PORT}", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 15412
            invite_window.destroy()
            send_connection_request(target_ip)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling with my buddies anyone else wanna join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Clipboard Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    # Initialize log_text as a global variable
    global log_text
    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            tray_icon.stop()  # Ensure tray icon is removed
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username is set."""
        if username:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username is set
    root.after(1000, check_ready)

    # Bind Enter key to Set Username button
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    # **Enhancement 3: Add a button to minimize to system tray**
    def minimize_to_tray():
        root.withdraw()
        tray_icon.visible = True

    # Create tray icon
    def create_tray_icon():
        image = PIL.Image.new('RGB', (64, 64), color='blue')
        draw = PIL.ImageDraw.Draw(image)
        draw.rectangle((0, 0, 64, 64), fill='blue')
        draw.text((10, 25), "CT", fill='white')  # Example text
        menu = (
            item('Restore', restore_window),
            item('Exit', exit_application)
        )
        tray = pystray.Icon("ClipHilarity Sync", image, "ClipHilarity Sync", menu)
        return tray

    def restore_window(icon, item):
        icon.visible = False
        root.deiconify()

    def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)



2024-11-06 13:05:07,576 - DEBUG - Updating local clipboard with received content...
2024-11-06 13:05:07,579 - DEBUG - Clipboard updated from network: import socket
import threading
import pyperclip    
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import ImageDraw
from PIL import Image, ImageTk, ImageDraw
import ctypes
import logging  # For debugging purposes
import pystray  # For system tray integration
from pystray import MenuItem as item
import PIL.Image  # For creating tray icon images

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
LISTENING_PORT = 15411   # Port for continuously listening to incoming requests
SENDING_PORT = 15413     # Port for sending requests and receiving acknowledgments
CLIPBOARD_PORT = 15412   # Port for clipboard data transfer
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet


TARGET_USERS = {}  # Dictionary to store target IPs and their details

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40 )

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_USERS:
                            sock.sendto(message.encode('utf-8'), (ip, CLIPBOARD_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', CLIPBOARD_PORT))
            logging.debug(f"Listening for clipboard updates on port {CLIPBOARD_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CLIPBOARD_PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update TARGET_USERS with username and copy count
                            if addr[0] in TARGET_USERS:
                                TARGET_USERS[addr[0]]['username'] = received_username
                                TARGET_USERS[addr[0]]['copy_count'] += 1
                                update_connected_users_display()  # Update display after incrementing copy_count
                            else:
                                TARGET_USERS[addr[0]] = {'port': addr[1], 'copy_count': 1, 'username': received_username}
                                # Assign color to new user
                                if received_username not in user_colors:
                                    user_colors[received_username] = get_next_color()
                                update_connected_users_display()
                            # Log the activity with username and copied text
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static LISTENING_PORT
            sock.bind(('', LISTENING_PORT))
            logging.debug(f"Listening for connection requests on port {LISTENING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {LISTENING_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == LISTENING_PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), (addr[0], sender_port))
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0, 'username': 'Unknown'}
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], sender_port)
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses and username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on the static SENDING_PORT
            sock.bind(('', SENDING_PORT))
            logging.debug(f"Listening for connection responses and username updates on port {SENDING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {SENDING_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': SENDING_PORT, 'copy_count': 0, 'username': responder_username}
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{SENDING_PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{SENDING_PORT}! ")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{SENDING_PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                elif received_message.startswith("USERNAME_UPDATE:"):
                    new_username = received_message.split(':', 1)[1]
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling incoming messages: {e}")

def send_connection_request(target_ip):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{SENDING_PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, LISTENING_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{LISTENING_PORT}")
            # Removed binding to SENDING_PORT and waiting for response
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            if isinstance(e, socket.error) and e.errno == 10048:
                custom_error_popup("Port In Use",
                                   f"Port {SENDING_PORT} is already in use. Please set a different port.")
            else:
                custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, target_port))
            logging.debug(f"Sent username update to {target_ip}:{target_port}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses and username updates
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info.get('copy_count', 0)))

# Move these functions to the global scope
def save_clipboard_log(username, copied_text):
    """Saves clipboard logs in the format: $username $time $copied text."""
    time_stamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
    log_entry = f"{username} {time_stamp} {copied_text}"
    with open('clipboard_logs.txt', 'a') as log_file:
        log_file.write(log_entry + '\n')

# Declare log_text as a global variable
log_text = None

def log_activity(user, message):
    """Logs clipboard activities in the GUI with the user's color."""
    global log_text
    if log_text is None:
        logging.error("log_text widget is not initialized.")
        return

    log_text.config(state='normal')
    if user in user_colors:
        color = user_colors[user]
    else:
        color = get_next_color()
        user_colors[user] = color
    log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
    # Updated log entry format
    log_entry = f"{user} {time.strftime('%Y-%m-%d %H:%M:%S')} {message}\n"
    log_text.insert(tk.END, log_entry, user)
    log_text.config(state='disabled')
    log_text.yview(tk.END)
    logging.info(log_entry.strip())  # Log to the file
    # Save clipboard log
    save_clipboard_log(user, message)

# GUI Setup
def main():
    global root, username, connected_users_tree, log_text, pause_button, tray_icon

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry (disabled since now using static ports)
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144", state='disabled')  # Disable port entry
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{LISTENING_PORT}", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 15412
            invite_window.destroy()
            send_connection_request(target_ip)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling with my buddies anyone else wanna join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Clipboard Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    # Initialize log_text as a global variable
    global log_text
    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            tray_icon.stop()  # Ensure tray icon is removed
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username is set."""
        if username:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username is set
    root.after(1000, check_ready)

    # Bind Enter key to Set Username button
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    # **Enhancement 3: Add a button to minimize to system tray**
    def minimize_to_tray():
        root.withdraw()
        tray_icon.visible = True

    # Create tray icon
    def create_tray_icon():
        image = PIL.Image.new('RGB', (64, 64), color='blue')
        draw = PIL.ImageDraw.Draw(image)
        draw.rectangle((0, 0, 64, 64), fill='blue')
        draw.text((10, 25), "CT", fill='white')  # Example text
        menu = (
            item('Restore', restore_window),
            item('Exit', exit_application)
        )
        tray = pystray.Icon("ClipHilarity Sync", image, "ClipHilarity Sync", menu)
        return tray

    def restore_window(icon, item):
        icon.visible = False
        root.deiconify()

    def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)



2024-11-06 13:05:07,580 - ERROR - Error receiving clipboard content: name 'log_activity' is not defined
2024-11-06 13:05:24,519 - DEBUG - STREAM b'IHDR' 16 13
2024-11-06 13:05:24,519 - DEBUG - STREAM b'pHYs' 41 9
2024-11-06 13:05:24,519 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-06 13:05:24,519 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-06 13:05:24,965 - DEBUG - Listening for connection requests on port 15411...
2024-11-06 13:05:24,965 - DEBUG - Listening for clipboard updates on port 15412...
2024-11-06 13:05:24,965 - DEBUG - Listening for connection responses and username updates on port 15413...
2024-11-06 13:05:24,967 - DEBUG - Importing BlpImagePlugin
2024-11-06 13:05:24,968 - DEBUG - Importing BmpImagePlugin
2024-11-06 13:05:24,968 - DEBUG - Importing BufrStubImagePlugin
2024-11-06 13:05:24,968 - DEBUG - Importing CurImagePlugin
2024-11-06 13:05:24,969 - DEBUG - Importing DcxImagePlugin
2024-11-06 13:05:24,970 - DEBUG - Importing DdsImagePlugin
2024-11-06 13:05:24,973 - DEBUG - Importing EpsImagePlugin
2024-11-06 13:05:24,974 - DEBUG - Importing FitsImagePlugin
2024-11-06 13:05:24,975 - DEBUG - Importing FliImagePlugin
2024-11-06 13:05:24,975 - DEBUG - Importing FpxImagePlugin
2024-11-06 13:05:24,976 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-06 13:05:24,976 - DEBUG - Importing FtexImagePlugin
2024-11-06 13:05:24,977 - DEBUG - Importing GbrImagePlugin
2024-11-06 13:05:24,977 - DEBUG - Importing GifImagePlugin
2024-11-06 13:05:24,977 - DEBUG - Importing GribStubImagePlugin
2024-11-06 13:05:24,978 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-06 13:05:24,978 - DEBUG - Importing IcnsImagePlugin
2024-11-06 13:05:24,979 - DEBUG - Importing IcoImagePlugin
2024-11-06 13:05:24,980 - DEBUG - Importing ImImagePlugin
2024-11-06 13:05:24,980 - DEBUG - Importing ImtImagePlugin
2024-11-06 13:05:24,981 - DEBUG - Importing IptcImagePlugin
2024-11-06 13:05:24,981 - DEBUG - Importing JpegImagePlugin
2024-11-06 13:05:24,981 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-06 13:05:24,981 - DEBUG - Importing McIdasImagePlugin
2024-11-06 13:05:24,982 - DEBUG - Importing MicImagePlugin
2024-11-06 13:05:24,982 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-06 13:05:24,982 - DEBUG - Importing MpegImagePlugin
2024-11-06 13:05:24,983 - DEBUG - Importing MpoImagePlugin
2024-11-06 13:05:24,987 - DEBUG - Importing MspImagePlugin
2024-11-06 13:05:24,987 - DEBUG - Importing PalmImagePlugin
2024-11-06 13:05:24,988 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip    
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import ImageDraw
from PIL import Image, ImageTk, ImageDraw
import ctypes
import logging  # For debugging purposes
import pystray  # For system tray integration
from pystray import MenuItem as item
import PIL.Image  # For creating tray icon images

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
LISTENING_PORT = 15411   # Port for continuously listening to incoming requests
SENDING_PORT = 15413     # Port for sending requests and receiving acknowledgments
CLIPBOARD_PORT = 15412   # Port for clipboard data transfer
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet


TARGET_USERS = {}  # Dictionary to store target IPs and their details

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40 )

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_USERS:
                            sock.sendto(message.encode('utf-8'), (ip, CLIPBOARD_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', CLIPBOARD_PORT))
            logging.debug(f"Listening for clipboard updates on port {CLIPBOARD_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {CLIPBOARD_PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update TARGET_USERS with username and copy count
                            if addr[0] in TARGET_USERS:
                                TARGET_USERS[addr[0]]['username'] = received_username
                                TARGET_USERS[addr[0]]['copy_count'] += 1
                                update_connected_users_display()  # Update display after incrementing copy_count
                            else:
                                TARGET_USERS[addr[0]] = {'port': addr[1], 'copy_count': 1, 'username': received_username}
                                # Assign color to new user
                                if received_username not in user_colors:
                                    user_colors[received_username] = get_next_color()
                                update_connected_users_display()
                            # Log the activity with username and copied text
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static LISTENING_PORT
            sock.bind(('', LISTENING_PORT))
            logging.debug(f"Listening for connection requests on port {LISTENING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {LISTENING_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == LISTENING_PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), (addr[0], sender_port))
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0, 'username': 'Unknown'}
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], sender_port)
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses and username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on the static SENDING_PORT
            sock.bind(('', SENDING_PORT))
            logging.debug(f"Listening for connection responses and username updates on port {SENDING_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {SENDING_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': SENDING_PORT, 'copy_count': 0, 'username': responder_username}
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{SENDING_PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{SENDING_PORT}! ")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{SENDING_PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                elif received_message.startswith("USERNAME_UPDATE:"):
                    new_username = received_message.split(':', 1)[1]
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling incoming messages: {e}")

def send_connection_request(target_ip):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{SENDING_PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, LISTENING_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{LISTENING_PORT}")
            # Removed binding to SENDING_PORT and waiting for response
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            if isinstance(e, socket.error) and e.errno == 10048:
                custom_error_popup("Port In Use",
                                   f"Port {SENDING_PORT} is already in use. Please set a different port.")
            else:
                custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, target_port))
            logging.debug(f"Sent username update to {target_ip}:{target_port}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses and username updates
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info.get('copy_count', 0)))

# Move these functions to the global scope
def save_clipboard_log(username, copied_text):
    """Saves clipboard logs in the format: $username $time $copied text."""
    time_stamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
    log_entry = f"{username} {time_stamp} {copied_text}"
    with open('clipboard_logs.txt', 'a') as log_file:
        log_file.write(log_entry + '\n')

# Declare log_text as a global variable
log_text = None

def log_activity(user, message):
    """Logs clipboard activities in the GUI with the user's color."""
    global log_text
    if log_text is None:
        logging.error("log_text widget is not initialized.")
        return

    log_text.config(state='normal')
    if user in user_colors:
        color = user_colors[user]
    else:
        color = get_next_color()
        user_colors[user] = color
    log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
    # Updated log entry format
    log_entry = f"{user} {time.strftime('%Y-%m-%d %H:%M:%S')} {message}\n"
    log_text.insert(tk.END, log_entry, user)
    log_text.config(state='disabled')
    log_text.yview(tk.END)
    logging.info(log_entry.strip())  # Log to the file
    # Save clipboard log
    save_clipboard_log(user, message)

# GUI Setup
def main():
    global root, username, connected_users_tree, log_text, pause_button, tray_icon

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry (disabled since now using static ports)
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144", state='disabled')  # Disable port entry
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{LISTENING_PORT}", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 15412
            invite_window.destroy()
            send_connection_request(target_ip)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling with my buddies anyone else wanna join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Clipboard Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    # Initialize log_text as a global variable
    global log_text
    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            tray_icon.stop()  # Ensure tray icon is removed
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username is set."""
        if username:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username is set
    root.after(1000, check_ready)

    # Bind Enter key to Set Username button
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    # **Enhancement 3: Add a button to minimize to system tray**
    def minimize_to_tray():
        root.withdraw()
        tray_icon.visible = True

    # Create tray icon
    def create_tray_icon():
        image = PIL.Image.new('RGB', (64, 64), color='blue')
        draw = PIL.ImageDraw.Draw(image)
        draw.rectangle((0, 0, 64, 64), fill='blue')
        draw.text((10, 25), "CT", fill='white')  # Example text
        menu = (
            item('Restore', restore_window),
            item('Exit', exit_application)
        )
        tray = pystray.Icon("ClipHilarity Sync", image, "ClipHilarity Sync", menu)
        return tray

    def restore_window(icon, item):
        icon.visible = False
        root.deiconify()

    def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)



2024-11-06 13:05:24,988 - DEBUG - Importing PcdImagePlugin
2024-11-06 13:05:24,989 - DEBUG - Importing PcxImagePlugin
2024-11-06 13:05:24,989 - DEBUG - Importing PdfImagePlugin
2024-11-06 13:05:24,993 - DEBUG - Importing PixarImagePlugin
2024-11-06 13:05:24,993 - DEBUG - Importing PngImagePlugin
2024-11-06 13:05:24,993 - DEBUG - Importing PpmImagePlugin
2024-11-06 13:05:24,993 - DEBUG - Importing PsdImagePlugin
2024-11-06 13:05:24,994 - DEBUG - Importing QoiImagePlugin
2024-11-06 13:05:24,994 - DEBUG - Importing SgiImagePlugin
2024-11-06 13:05:24,994 - DEBUG - Importing SpiderImagePlugin
2024-11-06 13:05:24,995 - DEBUG - Importing SunImagePlugin
2024-11-06 13:05:24,995 - DEBUG - Importing TgaImagePlugin
2024-11-06 13:05:24,996 - DEBUG - Importing TiffImagePlugin
2024-11-06 13:05:24,996 - DEBUG - Importing WebPImagePlugin
2024-11-06 13:05:24,996 - DEBUG - Importing WmfImagePlugin
2024-11-06 13:05:24,997 - DEBUG - Importing XbmImagePlugin
2024-11-06 13:05:24,997 - DEBUG - Importing XpmImagePlugin
2024-11-06 13:05:24,998 - DEBUG - Importing XVThumbImagePlugin
2024-11-06 13:05:45,849 - DEBUG - Sent connection request to 192.168.1.20:15411
2024-11-06 13:05:47,736 - DEBUG - Connection established with 'ChuckleCharm' at 192.168.1.20:15413
2024-11-06 13:05:51,402 - INFO - ChuckleCharm 2024-11-06 13:05:51 Connected from 192.168.1.20:15413
2024-11-06 13:05:51,402 - DEBUG - Sent username update to 192.168.1.20:15413
2024-11-06 13:05:51,409 - INFO - ChuckleCharm 2024-11-06 13:05:51 Changed username from ChuckleCharm to ChuckleCharm
2024-11-06 13:05:55,658 - DEBUG - Broadcasting clipboard content:     def show_tray_icon():

2024-11-06 13:06:00,247 - DEBUG - Broadcasting clipboard content: 
    # Start the threads for clipboard sync and connection handling
    start_threads()

2024-11-06 13:06:10,383 - DEBUG - Received clipboard content from 192.168.1.20:60175:     def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)



2024-11-06 13:06:10,383 - DEBUG - Updating local clipboard with received content...
2024-11-06 13:06:10,386 - DEBUG - Clipboard updated from network:     def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)



2024-11-06 13:06:10,416 - INFO - ChuckleCharm 2024-11-06 13:06:10 Copied:     def exit_application(icon, item):
        icon.stop()
        sys.exit()

    # Add Minimize to Tray button
    minimize_tray_button = ttk.Button(root, text="\U0001f53b Minimize to Tray", style='Custom.TButton',
                                     command=lambda: minimize_to_tray())
    minimize_tray_button.pack(pady=10)

    # Initialize tray icon
    tray_icon = create_tray_icon()

    def show_tray_icon():
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()

    # Start the tray icon thread
    show_tray_icon()

    # Start the threads for clipboard sync and connection handling
    start_threads()

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)
2024-11-06 13:06:10,416 - ERROR - Error receiving clipboard content: 'charmap' codec can't encode character '\U0001f53b' in position 213: character maps to <undefined>
2024-11-06 13:06:32,515 - DEBUG - Received clipboard content from 192.168.1.20:51566:         tray_thread = threading.Thread(target=tray_icon.run, daemon=True)

2024-11-06 13:06:32,515 - DEBUG - Updating local clipboard with received content...
2024-11-06 13:06:32,518 - DEBUG - Clipboard updated from network:         tray_thread = threading.Thread(target=tray_icon.run, daemon=True)

2024-11-06 13:06:32,524 - INFO - ChuckleCharm 2024-11-06 13:06:32 Copied:         tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
2024-11-06 13:08:40,249 - DEBUG - Sent connection request to 192.168.1.20:15411
2024-11-06 13:08:41,629 - DEBUG - Connection established with 'ChuckleCharm' at 192.168.1.20:15413
2024-11-06 13:08:42,634 - INFO - ChuckleCharm 2024-11-06 13:08:42 Connected from 192.168.1.20:15413
2024-11-06 13:08:42,634 - DEBUG - Sent username update to 192.168.1.20:15413
2024-11-06 13:08:42,642 - INFO - ChuckleCharm 2024-11-06 13:08:42 Changed username from ChuckleCharm to ChuckleCharm
2024-11-06 13:09:11,999 - DEBUG - Sent username update to 192.168.1.20:15413
2024-11-06 13:09:20,094 - DEBUG - Sent username update to 192.168.1.20:15413
2024-11-06 13:09:22,223 - DEBUG - Sent username update to 192.168.1.20:15413
2024-11-06 13:09:22,589 - DEBUG - Sent username update to 192.168.1.20:15413
2024-11-06 13:09:22,928 - DEBUG - Sent username update to 192.168.1.20:15413
2024-11-06 13:09:23,248 - DEBUG - Sent username update to 192.168.1.20:15413
2024-11-06 13:09:23,551 - DEBUG - Sent username update to 192.168.1.20:15413
2024-11-06 13:09:23,887 - DEBUG - Sent username update to 192.168.1.20:15413
2024-11-06 13:09:24,216 - DEBUG - Sent username update to 192.168.1.20:15413
2024-11-06 13:09:24,510 - DEBUG - Sent username update to 192.168.1.20:15413
2024-11-06 13:09:24,791 - DEBUG - Sent username update to 192.168.1.20:15413
2024-11-06 13:09:29,779 - DEBUG - Broadcasting clipboard content:     main()

2024-11-06 13:09:32,247 - DEBUG - Sent username update to 192.168.1.20:15413
2024-11-06 13:09:34,307 - DEBUG - Broadcasting clipboard content:         tray_thread = threading.Thread(target=tray_icon.run, daemon=True)

2024-11-06 13:19:39,832 - DEBUG - STREAM b'IHDR' 16 13
2024-11-06 13:19:39,832 - DEBUG - STREAM b'pHYs' 41 9
2024-11-06 13:19:39,832 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-06 13:19:39,832 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-06 13:19:40,303 - DEBUG - Listening for connection requests on port 15411...
2024-11-06 13:19:40,304 - DEBUG - Listening for clipboard updates on port 15412...
2024-11-06 13:19:40,304 - DEBUG - Listening for connection responses and username updates on port 15413...
2024-11-06 13:19:40,306 - DEBUG - Importing BlpImagePlugin
2024-11-06 13:19:40,307 - DEBUG - Importing BmpImagePlugin
2024-11-06 13:19:40,307 - DEBUG - Importing BufrStubImagePlugin
2024-11-06 13:19:40,308 - DEBUG - Importing CurImagePlugin
2024-11-06 13:19:40,308 - DEBUG - Importing DcxImagePlugin
2024-11-06 13:19:40,309 - DEBUG - Importing DdsImagePlugin
2024-11-06 13:19:40,311 - DEBUG - Importing EpsImagePlugin
2024-11-06 13:19:40,312 - DEBUG - Importing FitsImagePlugin
2024-11-06 13:19:40,313 - DEBUG - Importing FliImagePlugin
2024-11-06 13:19:40,313 - DEBUG - Importing FpxImagePlugin
2024-11-06 13:19:40,314 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-06 13:19:40,314 - DEBUG - Importing FtexImagePlugin
2024-11-06 13:19:40,315 - DEBUG - Importing GbrImagePlugin
2024-11-06 13:19:40,315 - DEBUG - Importing GifImagePlugin
2024-11-06 13:19:40,315 - DEBUG - Importing GribStubImagePlugin
2024-11-06 13:19:40,315 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-06 13:19:40,316 - DEBUG - Importing IcnsImagePlugin
2024-11-06 13:19:40,318 - DEBUG - Importing IcoImagePlugin
2024-11-06 13:19:40,319 - DEBUG - Importing ImImagePlugin
2024-11-06 13:19:40,319 - DEBUG - Importing ImtImagePlugin
2024-11-06 13:19:40,320 - DEBUG - Importing IptcImagePlugin
2024-11-06 13:19:40,320 - DEBUG - Importing JpegImagePlugin
2024-11-06 13:19:40,321 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-06 13:19:40,321 - DEBUG - Importing McIdasImagePlugin
2024-11-06 13:19:40,321 - DEBUG - Importing MicImagePlugin
2024-11-06 13:19:40,322 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-06 13:19:40,322 - DEBUG - Importing MpegImagePlugin
2024-11-06 13:19:40,322 - DEBUG - Importing MpoImagePlugin
2024-11-06 13:19:40,328 - DEBUG - Importing MspImagePlugin
2024-11-06 13:19:40,329 - DEBUG - Importing PalmImagePlugin
2024-11-06 13:19:40,329 - DEBUG - Importing PcdImagePlugin
2024-11-06 13:19:40,330 - DEBUG - Importing PcxImagePlugin
2024-11-06 13:19:40,330 - DEBUG - Importing PdfImagePlugin
2024-11-06 13:19:40,334 - DEBUG - Importing PixarImagePlugin
2024-11-06 13:19:40,335 - DEBUG - Importing PngImagePlugin
2024-11-06 13:19:40,335 - DEBUG - Importing PpmImagePlugin
2024-11-06 13:19:40,335 - DEBUG - Importing PsdImagePlugin
2024-11-06 13:19:40,335 - DEBUG - Importing QoiImagePlugin
2024-11-06 13:19:40,336 - DEBUG - Importing SgiImagePlugin
2024-11-06 13:19:40,336 - DEBUG - Importing SpiderImagePlugin
2024-11-06 13:19:40,337 - DEBUG - Importing SunImagePlugin
2024-11-06 13:19:40,337 - DEBUG - Importing TgaImagePlugin
2024-11-06 13:19:40,337 - DEBUG - Importing TiffImagePlugin
2024-11-06 13:19:40,338 - DEBUG - Importing WebPImagePlugin
2024-11-06 13:19:40,340 - DEBUG - Importing WmfImagePlugin
2024-11-06 13:19:40,340 - DEBUG - Importing XbmImagePlugin
2024-11-06 13:19:40,341 - DEBUG - Importing XpmImagePlugin
2024-11-06 13:19:40,342 - DEBUG - Importing XVThumbImagePlugin
2024-11-06 13:19:52,298 - DEBUG - Sent connection request to 192.168.1.20:15411
2024-11-06 13:19:53,112 - DEBUG - Connection established with 'ScrollSorcerer' at 192.168.1.20:15413
2024-11-06 13:19:53,277 - INFO - ScrollSorcerer 2024-11-06 13:19:53 Connected from 192.168.1.20:15413
2024-11-06 13:19:53,278 - DEBUG - Sent username update to 192.168.1.20:15413
2024-11-06 13:19:53,281 - INFO - ScrollSorcerer 2024-11-06 13:19:53 Changed username from ScrollSorcerer to ScrollSorcerer
2024-11-06 13:19:57,501 - INFO - TypoTitan 2024-11-06 13:19:57 Changed username from ScrollSorcerer to TypoTitan
2024-11-06 13:19:58,446 - INFO - LaughingLetter 2024-11-06 13:19:58 Changed username from TypoTitan to LaughingLetter
2024-11-06 13:20:26,418 - DEBUG - Received clipboard content from 192.168.1.20:57976: openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365

2024-11-06 13:20:26,418 - DEBUG - Updating local clipboard with received content...
2024-11-06 13:20:26,421 - DEBUG - Clipboard updated from network: openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365

2024-11-06 13:20:26,427 - INFO - LaughingLetter 2024-11-06 13:20:26 Copied: openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365
2024-11-06 13:20:28,901 - DEBUG - Received clipboard content from 192.168.1.20:62355: openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365

2024-11-06 13:20:28,901 - DEBUG - Updating local clipboard with received content...
2024-11-06 13:20:28,904 - DEBUG - Clipboard updated from network: openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365

2024-11-06 13:20:28,908 - INFO - LaughingLetter 2024-11-06 13:20:28 Copied: openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365
2024-11-06 13:20:30,486 - DEBUG - Received clipboard content from 192.168.1.20:65213: To create a self-signed certificate with OpenSSL:
bash
Copied!

2024-11-06 13:20:30,486 - DEBUG - Updating local clipboard with received content...
2024-11-06 13:20:30,490 - DEBUG - Clipboard updated from network: To create a self-signed certificate with OpenSSL:
bash
Copied!

2024-11-06 13:20:30,495 - INFO - LaughingLetter 2024-11-06 13:20:30 Copied: To create a self-signed certificate with OpenSSL:
bash
Copied!
2024-11-06 13:20:35,343 - DEBUG - Received clipboard content from 192.168.1.20:57362: openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365

2024-11-06 13:20:35,343 - DEBUG - Updating local clipboard with received content...
2024-11-06 13:20:35,346 - DEBUG - Clipboard updated from network: openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365

2024-11-06 13:20:35,350 - INFO - LaughingLetter 2024-11-06 13:20:35 Copied: openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365
2024-11-06 13:22:55,439 - DEBUG - Broadcasting clipboard content: server clipboard CERT
2024-11-06 13:23:23,617 - DEBUG - Broadcasting clipboard content: 
