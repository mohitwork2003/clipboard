2024-11-05 14:07:48,562 - DEBUG - Listening for clipboard updates on port 5000...
2024-11-05 14:07:48,563 - DEBUG - Listening for connection requests on port 5001...
2024-11-05 14:07:48,588 - DEBUG - Broadcasting clipboard content:     main()

2024-11-05 14:07:53,148 - DEBUG - Hiding main window and minimizing to system tray.
2024-11-05 14:07:53,161 - ERROR - Logo file 'logo.png' not found.
2024-11-05 14:08:13,044 - DEBUG - Listening for clipboard updates on port 5000...
2024-11-05 14:08:13,044 - DEBUG - Listening for connection requests on port 5001...
2024-11-05 14:08:14,547 - DEBUG - Hiding main window and minimizing to system tray.
2024-11-05 14:08:14,587 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:08:14,587 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:08:14,587 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:08:14,587 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:08:14,592 - DEBUG - Importing BlpImagePlugin
2024-11-05 14:08:14,592 - DEBUG - Importing BmpImagePlugin
2024-11-05 14:08:14,592 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 14:08:14,593 - DEBUG - Importing CurImagePlugin
2024-11-05 14:08:14,593 - DEBUG - Importing DcxImagePlugin
2024-11-05 14:08:14,593 - DEBUG - Importing DdsImagePlugin
2024-11-05 14:08:14,595 - DEBUG - Importing EpsImagePlugin
2024-11-05 14:08:14,595 - DEBUG - Importing FitsImagePlugin
2024-11-05 14:08:14,596 - DEBUG - Importing FliImagePlugin
2024-11-05 14:08:14,596 - DEBUG - Importing FpxImagePlugin
2024-11-05 14:08:14,596 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 14:08:14,596 - DEBUG - Importing FtexImagePlugin
2024-11-05 14:08:14,596 - DEBUG - Importing GbrImagePlugin
2024-11-05 14:08:14,597 - DEBUG - Importing GifImagePlugin
2024-11-05 14:08:14,597 - DEBUG - Importing GribStubImagePlugin
2024-11-05 14:08:14,597 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 14:08:14,597 - DEBUG - Importing IcnsImagePlugin
2024-11-05 14:08:14,598 - DEBUG - Importing IcoImagePlugin
2024-11-05 14:08:14,598 - DEBUG - Importing ImImagePlugin
2024-11-05 14:08:14,598 - DEBUG - Importing ImtImagePlugin
2024-11-05 14:08:14,599 - DEBUG - Importing IptcImagePlugin
2024-11-05 14:08:14,599 - DEBUG - Importing JpegImagePlugin
2024-11-05 14:08:14,599 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 14:08:14,599 - DEBUG - Importing McIdasImagePlugin
2024-11-05 14:08:14,599 - DEBUG - Importing MicImagePlugin
2024-11-05 14:08:14,599 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 14:08:14,599 - DEBUG - Importing MpegImagePlugin
2024-11-05 14:08:14,599 - DEBUG - Importing MpoImagePlugin
2024-11-05 14:08:14,604 - DEBUG - Importing MspImagePlugin
2024-11-05 14:08:14,604 - DEBUG - Importing PalmImagePlugin
2024-11-05 14:08:14,605 - DEBUG - Importing PcdImagePlugin
2024-11-05 14:08:14,605 - DEBUG - Importing PcxImagePlugin
2024-11-05 14:08:14,605 - DEBUG - Importing PdfImagePlugin
2024-11-05 14:08:14,608 - DEBUG - Importing PixarImagePlugin
2024-11-05 14:08:14,608 - DEBUG - Importing PngImagePlugin
2024-11-05 14:08:14,608 - DEBUG - Importing PpmImagePlugin
2024-11-05 14:08:14,608 - DEBUG - Importing PsdImagePlugin
2024-11-05 14:08:14,609 - DEBUG - Importing QoiImagePlugin
2024-11-05 14:08:14,609 - DEBUG - Importing SgiImagePlugin
2024-11-05 14:08:14,609 - DEBUG - Importing SpiderImagePlugin
2024-11-05 14:08:14,609 - DEBUG - Importing SunImagePlugin
2024-11-05 14:08:14,609 - DEBUG - Importing TgaImagePlugin
2024-11-05 14:08:14,609 - DEBUG - Importing TiffImagePlugin
2024-11-05 14:08:14,609 - DEBUG - Importing WebPImagePlugin
2024-11-05 14:08:14,610 - DEBUG - Importing WmfImagePlugin
2024-11-05 14:08:14,610 - DEBUG - Importing XbmImagePlugin
2024-11-05 14:08:14,611 - DEBUG - Importing XpmImagePlugin
2024-11-05 14:08:14,611 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 14:08:20,506 - DEBUG - Quitting application.
2024-11-05 14:08:20,507 - ERROR - An error occurred when calling message handler
Traceback (most recent call last):
  File "pystray\_win32.py", line 412, in _dispatcher
  File "pystray\_win32.py", line 224, in _on_notify
  File "pystray\_base.py", line 328, in inner
  File "pystray\_base.py", line 453, in __call__
  File "main.py", line 54, in on_quit
SystemExit
2024-11-05 14:08:23,674 - DEBUG - Listening for connection requests on port 5001...
2024-11-05 14:08:23,674 - DEBUG - Listening for clipboard updates on port 5000...
2024-11-05 14:08:26,347 - DEBUG - Hiding main window and minimizing to system tray.
2024-11-05 14:08:26,366 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:08:26,366 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:08:26,366 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:08:26,366 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:08:26,385 - DEBUG - Importing BlpImagePlugin
2024-11-05 14:08:26,386 - DEBUG - Importing BmpImagePlugin
2024-11-05 14:08:26,386 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 14:08:26,386 - DEBUG - Importing CurImagePlugin
2024-11-05 14:08:26,386 - DEBUG - Importing DcxImagePlugin
2024-11-05 14:08:26,386 - DEBUG - Importing DdsImagePlugin
2024-11-05 14:08:26,388 - DEBUG - Importing EpsImagePlugin
2024-11-05 14:08:26,388 - DEBUG - Importing FitsImagePlugin
2024-11-05 14:08:26,389 - DEBUG - Importing FliImagePlugin
2024-11-05 14:08:26,389 - DEBUG - Importing FpxImagePlugin
2024-11-05 14:08:26,389 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 14:08:26,389 - DEBUG - Importing FtexImagePlugin
2024-11-05 14:08:26,390 - DEBUG - Importing GbrImagePlugin
2024-11-05 14:08:26,390 - DEBUG - Importing GifImagePlugin
2024-11-05 14:08:26,390 - DEBUG - Importing GribStubImagePlugin
2024-11-05 14:08:26,390 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 14:08:26,390 - DEBUG - Importing IcnsImagePlugin
2024-11-05 14:08:26,391 - DEBUG - Importing IcoImagePlugin
2024-11-05 14:08:26,391 - DEBUG - Importing ImImagePlugin
2024-11-05 14:08:26,392 - DEBUG - Importing ImtImagePlugin
2024-11-05 14:08:26,392 - DEBUG - Importing IptcImagePlugin
2024-11-05 14:08:26,392 - DEBUG - Importing JpegImagePlugin
2024-11-05 14:08:26,392 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 14:08:26,392 - DEBUG - Importing McIdasImagePlugin
2024-11-05 14:08:26,392 - DEBUG - Importing MicImagePlugin
2024-11-05 14:08:26,392 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 14:08:26,392 - DEBUG - Importing MpegImagePlugin
2024-11-05 14:08:26,392 - DEBUG - Importing MpoImagePlugin
2024-11-05 14:08:26,397 - DEBUG - Importing MspImagePlugin
2024-11-05 14:08:26,398 - DEBUG - Importing PalmImagePlugin
2024-11-05 14:08:26,398 - DEBUG - Importing PcdImagePlugin
2024-11-05 14:08:26,398 - DEBUG - Importing PcxImagePlugin
2024-11-05 14:08:26,398 - DEBUG - Importing PdfImagePlugin
2024-11-05 14:08:26,401 - DEBUG - Importing PixarImagePlugin
2024-11-05 14:08:26,401 - DEBUG - Importing PngImagePlugin
2024-11-05 14:08:26,402 - DEBUG - Importing PpmImagePlugin
2024-11-05 14:08:26,402 - DEBUG - Importing PsdImagePlugin
2024-11-05 14:08:26,402 - DEBUG - Importing QoiImagePlugin
2024-11-05 14:08:26,402 - DEBUG - Importing SgiImagePlugin
2024-11-05 14:08:26,402 - DEBUG - Importing SpiderImagePlugin
2024-11-05 14:08:26,402 - DEBUG - Importing SunImagePlugin
2024-11-05 14:08:26,402 - DEBUG - Importing TgaImagePlugin
2024-11-05 14:08:26,403 - DEBUG - Importing TiffImagePlugin
2024-11-05 14:08:26,403 - DEBUG - Importing WebPImagePlugin
2024-11-05 14:08:26,403 - DEBUG - Importing WmfImagePlugin
2024-11-05 14:08:26,403 - DEBUG - Importing XbmImagePlugin
2024-11-05 14:08:26,404 - DEBUG - Importing XpmImagePlugin
2024-11-05 14:08:26,404 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 14:08:30,420 - DEBUG - Quitting application.
2024-11-05 14:08:30,421 - ERROR - An error occurred when calling message handler
Traceback (most recent call last):
  File "pystray\_win32.py", line 412, in _dispatcher
  File "pystray\_win32.py", line 224, in _on_notify
  File "pystray\_base.py", line 328, in inner
  File "pystray\_base.py", line 453, in __call__
  File "main.py", line 54, in on_quit
SystemExit
2024-11-05 14:09:58,686 - DEBUG - Listening for connection requests on port 5001...
2024-11-05 14:09:58,686 - DEBUG - Listening for clipboard updates on port 5000...
2024-11-05 14:10:35,402 - DEBUG - Sent connection request to 192.168.1.12
2024-11-05 14:10:39,281 - DEBUG - Connection established with 192.168.1.12
2024-11-05 14:10:50,265 - DEBUG - Sent connection request to 192.168.1.11
2024-11-05 14:10:53,512 - DEBUG - Connection established with 192.168.1.11
2024-11-05 14:11:06,476 - DEBUG - Broadcasting clipboard content:     # Keep the threads running in the background even after closing the GUI

2024-11-05 14:11:06,801 - DEBUG - Broadcasting clipboard content:     # Keep the threads running in the background even after closing the GUI

2024-11-05 14:11:06,883 - DEBUG - Broadcasting clipboard content:     # Keep the threads running in the background even after closing the GUI

2024-11-05 14:11:23,019 - DEBUG - Received clipboard content from network: Mohit
2024-11-05 14:11:23,019 - DEBUG - Updating local clipboard with received content...
2024-11-05 14:11:23,027 - DEBUG - Clipboard updated from network: Mohit
2024-11-05 14:11:23,312 - DEBUG - Broadcasting clipboard content: Mohit
2024-11-05 14:11:23,490 - DEBUG - Received clipboard content from network:     # Keep the threads running in the background even after closing the GUIaaaa
2024-11-05 14:11:23,491 - DEBUG - Updating local clipboard with received content...
2024-11-05 14:11:23,494 - DEBUG - Clipboard updated from network:     # Keep the threads running in the background even after closing the GUIaaaa
2024-11-05 14:11:24,315 - DEBUG - Broadcasting clipboard content:     # Keep the threads running in the background even after closing the GUIaaaa
2024-11-05 14:11:24,674 - DEBUG - Broadcasting clipboard content:     # Keep the threads running in the background even after closing the GUIaaaa
2024-11-05 14:11:34,189 - DEBUG - Received clipboard content from network: Mohit
2024-11-05 14:11:34,189 - DEBUG - Updating local clipboard with received content...
2024-11-05 14:11:34,199 - DEBUG - Clipboard updated from network: Mohit
2024-11-05 14:11:34,865 - DEBUG - Broadcasting clipboard content: Mohit
2024-11-05 14:11:34,934 - DEBUG - Broadcasting clipboard content: Mohit
2024-11-05 14:15:07,074 - DEBUG - Hiding main window and minimizing to system tray.
2024-11-05 14:15:07,096 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:15:07,096 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:15:07,097 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:15:07,097 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:15:07,102 - DEBUG - Importing BlpImagePlugin
2024-11-05 14:15:07,103 - DEBUG - Importing BmpImagePlugin
2024-11-05 14:15:07,103 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 14:15:07,103 - DEBUG - Importing CurImagePlugin
2024-11-05 14:15:07,104 - DEBUG - Importing DcxImagePlugin
2024-11-05 14:15:07,104 - DEBUG - Importing DdsImagePlugin
2024-11-05 14:15:07,106 - DEBUG - Importing EpsImagePlugin
2024-11-05 14:15:07,107 - DEBUG - Importing FitsImagePlugin
2024-11-05 14:15:07,108 - DEBUG - Importing FliImagePlugin
2024-11-05 14:15:07,108 - DEBUG - Importing FpxImagePlugin
2024-11-05 14:15:07,108 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 14:15:07,108 - DEBUG - Importing FtexImagePlugin
2024-11-05 14:15:07,109 - DEBUG - Importing GbrImagePlugin
2024-11-05 14:15:07,109 - DEBUG - Importing GifImagePlugin
2024-11-05 14:15:07,109 - DEBUG - Importing GribStubImagePlugin
2024-11-05 14:15:07,109 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 14:15:07,109 - DEBUG - Importing IcnsImagePlugin
2024-11-05 14:15:07,110 - DEBUG - Importing IcoImagePlugin
2024-11-05 14:15:07,111 - DEBUG - Importing ImImagePlugin
2024-11-05 14:15:07,111 - DEBUG - Importing ImtImagePlugin
2024-11-05 14:15:07,111 - DEBUG - Importing IptcImagePlugin
2024-11-05 14:15:07,112 - DEBUG - Importing JpegImagePlugin
2024-11-05 14:15:07,112 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 14:15:07,112 - DEBUG - Importing McIdasImagePlugin
2024-11-05 14:15:07,112 - DEBUG - Importing MicImagePlugin
2024-11-05 14:15:07,112 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 14:15:07,112 - DEBUG - Importing MpegImagePlugin
2024-11-05 14:15:07,112 - DEBUG - Importing MpoImagePlugin
2024-11-05 14:15:07,117 - DEBUG - Importing MspImagePlugin
2024-11-05 14:15:07,117 - DEBUG - Importing PalmImagePlugin
2024-11-05 14:15:07,117 - DEBUG - Importing PcdImagePlugin
2024-11-05 14:15:07,118 - DEBUG - Importing PcxImagePlugin
2024-11-05 14:15:07,118 - DEBUG - Importing PdfImagePlugin
2024-11-05 14:15:07,121 - DEBUG - Importing PixarImagePlugin
2024-11-05 14:15:07,121 - DEBUG - Importing PngImagePlugin
2024-11-05 14:15:07,121 - DEBUG - Importing PpmImagePlugin
2024-11-05 14:15:07,121 - DEBUG - Importing PsdImagePlugin
2024-11-05 14:15:07,121 - DEBUG - Importing QoiImagePlugin
2024-11-05 14:15:07,121 - DEBUG - Importing SgiImagePlugin
2024-11-05 14:15:07,122 - DEBUG - Importing SpiderImagePlugin
2024-11-05 14:15:07,122 - DEBUG - Importing SunImagePlugin
2024-11-05 14:15:07,122 - DEBUG - Importing TgaImagePlugin
2024-11-05 14:15:07,122 - DEBUG - Importing TiffImagePlugin
2024-11-05 14:15:07,122 - DEBUG - Importing WebPImagePlugin
2024-11-05 14:15:07,123 - DEBUG - Importing WmfImagePlugin
2024-11-05 14:15:07,123 - DEBUG - Importing XbmImagePlugin
2024-11-05 14:15:07,123 - DEBUG - Importing XpmImagePlugin
2024-11-05 14:15:07,124 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 14:15:18,772 - DEBUG - Quitting application.
2024-11-05 14:15:18,773 - ERROR - An error occurred when calling message handler
Traceback (most recent call last):
  File "pystray\_win32.py", line 412, in _dispatcher
  File "pystray\_win32.py", line 224, in _on_notify
  File "pystray\_base.py", line 328, in inner
  File "pystray\_base.py", line 453, in __call__
  File "main.py", line 54, in on_quit
SystemExit
2024-11-05 14:15:58,833 - DEBUG - Listening for clipboard updates on port 5000...
2024-11-05 14:15:58,833 - DEBUG - Listening for connection requests on port 5001...
2024-11-05 14:15:58,850 - DEBUG - Broadcasting clipboard content: Mohit
2024-11-05 14:15:58,949 - DEBUG - Listening for clipboard updates on port 5000...
2024-11-05 14:15:58,949 - DEBUG - Listening for connection requests on port 5001...
2024-11-05 14:15:58,970 - DEBUG - Broadcasting clipboard content: Mohit
2024-11-05 14:16:25,159 - ERROR - Error sending connection request: str, bytes or bytearray expected, not NoneType
2024-11-05 14:16:52,416 - DEBUG - Hiding main window and minimizing to system tray.
2024-11-05 14:16:52,440 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:16:52,440 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:16:52,440 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:16:52,440 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:16:52,450 - DEBUG - Importing BlpImagePlugin
2024-11-05 14:16:52,452 - DEBUG - Importing BmpImagePlugin
2024-11-05 14:16:52,452 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 14:16:52,452 - DEBUG - Importing CurImagePlugin
2024-11-05 14:16:52,452 - DEBUG - Importing DcxImagePlugin
2024-11-05 14:16:52,452 - DEBUG - Importing DdsImagePlugin
2024-11-05 14:16:52,454 - DEBUG - Importing EpsImagePlugin
2024-11-05 14:16:52,454 - DEBUG - Importing FitsImagePlugin
2024-11-05 14:16:52,455 - DEBUG - Importing FliImagePlugin
2024-11-05 14:16:52,455 - DEBUG - Importing FpxImagePlugin
2024-11-05 14:16:52,455 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 14:16:52,455 - DEBUG - Importing FtexImagePlugin
2024-11-05 14:16:52,456 - DEBUG - Importing GbrImagePlugin
2024-11-05 14:16:52,456 - DEBUG - Importing GifImagePlugin
2024-11-05 14:16:52,456 - DEBUG - Importing GribStubImagePlugin
2024-11-05 14:16:52,456 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 14:16:52,456 - DEBUG - Importing IcnsImagePlugin
2024-11-05 14:16:52,457 - DEBUG - Importing IcoImagePlugin
2024-11-05 14:16:52,457 - DEBUG - Importing ImImagePlugin
2024-11-05 14:16:52,457 - DEBUG - Importing ImtImagePlugin
2024-11-05 14:16:52,458 - DEBUG - Importing IptcImagePlugin
2024-11-05 14:16:52,458 - DEBUG - Importing JpegImagePlugin
2024-11-05 14:16:52,458 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 14:16:52,458 - DEBUG - Importing McIdasImagePlugin
2024-11-05 14:16:52,458 - DEBUG - Importing MicImagePlugin
2024-11-05 14:16:52,458 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 14:16:52,458 - DEBUG - Importing MpegImagePlugin
2024-11-05 14:16:52,458 - DEBUG - Importing MpoImagePlugin
2024-11-05 14:16:52,463 - DEBUG - Importing MspImagePlugin
2024-11-05 14:16:52,464 - DEBUG - Importing PalmImagePlugin
2024-11-05 14:16:52,464 - DEBUG - Importing PcdImagePlugin
2024-11-05 14:16:52,464 - DEBUG - Importing PcxImagePlugin
2024-11-05 14:16:52,464 - DEBUG - Importing PdfImagePlugin
2024-11-05 14:16:52,468 - DEBUG - Importing PixarImagePlugin
2024-11-05 14:16:52,468 - DEBUG - Importing PngImagePlugin
2024-11-05 14:16:52,468 - DEBUG - Importing PpmImagePlugin
2024-11-05 14:16:52,468 - DEBUG - Importing PsdImagePlugin
2024-11-05 14:16:52,468 - DEBUG - Importing QoiImagePlugin
2024-11-05 14:16:52,468 - DEBUG - Importing SgiImagePlugin
2024-11-05 14:16:52,468 - DEBUG - Importing SpiderImagePlugin
2024-11-05 14:16:52,469 - DEBUG - Importing SunImagePlugin
2024-11-05 14:16:52,469 - DEBUG - Importing TgaImagePlugin
2024-11-05 14:16:52,469 - DEBUG - Importing TiffImagePlugin
2024-11-05 14:16:52,469 - DEBUG - Importing WebPImagePlugin
2024-11-05 14:16:52,470 - DEBUG - Importing WmfImagePlugin
2024-11-05 14:16:52,470 - DEBUG - Importing XbmImagePlugin
2024-11-05 14:16:52,470 - DEBUG - Importing XpmImagePlugin
2024-11-05 14:16:52,471 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 14:16:56,100 - DEBUG - Quitting application.
2024-11-05 14:16:56,100 - ERROR - An error occurred when calling message handler
Traceback (most recent call last):
  File "pystray\_win32.py", line 412, in _dispatcher
  File "pystray\_win32.py", line 224, in _on_notify
  File "pystray\_base.py", line 328, in inner
  File "pystray\_base.py", line 453, in __call__
  File "main.py", line 54, in on_quit
SystemExit
2024-11-05 14:18:41,783 - DEBUG - Received clipboard content from network: md:h-[650px]
2024-11-05 14:18:41,783 - DEBUG - Updating local clipboard with received content...
2024-11-05 14:18:41,791 - DEBUG - Clipboard updated from network: md:h-[650px]
2024-11-05 14:18:42,521 - DEBUG - Broadcasting clipboard content: md:h-[650px]
2024-11-05 14:18:43,177 - DEBUG - Broadcasting clipboard content: md:h-[650px]
2024-11-05 14:18:43,197 - DEBUG - Broadcasting clipboard content: md:h-[650px]
2024-11-05 14:19:45,566 - DEBUG - Sent connection request to 192.168.1.26
2024-11-05 14:19:55,570 - DEBUG - No response from 192.168.1.26. Connection request timed out.
2024-11-05 14:20:35,018 - DEBUG - Broadcasting clipboard content: logo_photo = ImageTk.PhotoImage(logo_image)
logo_label = tk.Label(root, image=logo_photo)
logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
logo_label.pack(pady=10)

2024-11-05 14:20:35,084 - DEBUG - Broadcasting clipboard content: logo_photo = ImageTk.PhotoImage(logo_image)
logo_label = tk.Label(root, image=logo_photo)
logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
logo_label.pack(pady=10)

2024-11-05 14:20:36,102 - DEBUG - Broadcasting clipboard content: logo_photo = ImageTk.PhotoImage(logo_image)
logo_label = tk.Label(root, image=logo_photo)
logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
logo_label.pack(pady=10)

2024-11-05 14:20:36,529 - DEBUG - Broadcasting clipboard content: logo_photo = ImageTk.PhotoImage(logo_image)
logo_label = tk.Label(root, image=logo_photo)
logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
logo_label.pack(pady=10)

2024-11-05 14:21:33,093 - DEBUG - Broadcasting clipboard content: PS C:\Users\Dell\Music\clipboard> python main.py
PS C:\Users\Dell\Music\clipboard> python main.py


2024-11-05 14:21:33,168 - DEBUG - Broadcasting clipboard content: PS C:\Users\Dell\Music\clipboard> python main.py
PS C:\Users\Dell\Music\clipboard> python main.py


2024-11-05 14:21:33,884 - DEBUG - Broadcasting clipboard content: PS C:\Users\Dell\Music\clipboard> python main.py
PS C:\Users\Dell\Music\clipboard> python main.py


2024-11-05 14:21:34,039 - DEBUG - Broadcasting clipboard content: PS C:\Users\Dell\Music\clipboard> python main.py
PS C:\Users\Dell\Music\clipboard> python main.py


2024-11-05 14:21:50,265 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
PORT = 5000  # Port for broadcasting and listening
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_IPS = []  # List to store target IP addresses

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

def on_quit(icon, item):
    logging.debug("Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Showing main window from system tray.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and minimizing to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Error", f"Logo file '{image_path}' not found. Exiting application.")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show', show_window), item('Quit', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Error", f"Error while setting up system tray icon: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_IPS:
                            sock.sendto(message.encode('utf-8'), (ip, PORT))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return
        
        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, _ = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)
                
                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue
                
                logging.debug(f"Received clipboard content from network: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                    else:
                        logging.debug("Received content is the same as the current clipboard content. No update needed.")
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return
        
        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request message from {addr[0]}: {received_message}")
                if received_message == "REQUEST_CONNECTION":
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request", f"Accept connection request from {addr[0]}?")
                    if result:
                        TARGET_IPS.append(addr[0])
                        logging.debug(f"Accepted connection from {addr[0]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = "CONNECTION_ACCEPTED"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                    else:
                        logging.debug(f"Rejected connection from {addr[0]}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def send_connection_request(target_ip):
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = "REQUEST_CONNECTION"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind((local_ip, RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    if data.decode('utf-8') == "CONNECTION_ACCEPTED":
                        TARGET_IPS.append(target_ip)
                        logging.debug(f"Connection established with {target_ip}")
                        messagebox.showinfo("Connection Request", f"Connection established with {target_ip}")
                        is_connected.set()  # Set connection established flag
                    else:
                        logging.debug(f"Connection request to {target_ip} was not accepted.")
                except socket.timeout:
                    logging.debug(f"No response from {target_ip}. Connection request timed out.")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()

# GUI Setup
def main():
    global root
    root = tk.Tk()
    root.title("Clipboard Sync Dashboard")
    root.geometry("400x300")

    # Display the local IP address at the top of the dashboard
    ip_label = tk.Label(root, text=f"Your IP address: {local_ip}", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=10)

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)  # Resize logo for better fit
      logo_photo = ImageTk.PhotoImage(logo_image)
logo_label = tk.Label(root, image=logo_photo)
logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
logo_label.pack(pady=10)


2024-11-05 14:21:50,292 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
PORT = 5000  # Port for broadcasting and listening
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_IPS = []  # List to store target IP addresses

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

def on_quit(icon, item):
    logging.debug("Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Showing main window from system tray.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and minimizing to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Error", f"Logo file '{image_path}' not found. Exiting application.")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show', show_window), item('Quit', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Error", f"Error while setting up system tray icon: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_IPS:
                            sock.sendto(message.encode('utf-8'), (ip, PORT))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return
        
        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, _ = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)
                
                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue
                
                logging.debug(f"Received clipboard content from network: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                    else:
                        logging.debug("Received content is the same as the current clipboard content. No update needed.")
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return
        
        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request message from {addr[0]}: {received_message}")
                if received_message == "REQUEST_CONNECTION":
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request", f"Accept connection request from {addr[0]}?")
                    if result:
                        TARGET_IPS.append(addr[0])
                        logging.debug(f"Accepted connection from {addr[0]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = "CONNECTION_ACCEPTED"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                    else:
                        logging.debug(f"Rejected connection from {addr[0]}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def send_connection_request(target_ip):
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = "REQUEST_CONNECTION"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind((local_ip, RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    if data.decode('utf-8') == "CONNECTION_ACCEPTED":
                        TARGET_IPS.append(target_ip)
                        logging.debug(f"Connection established with {target_ip}")
                        messagebox.showinfo("Connection Request", f"Connection established with {target_ip}")
                        is_connected.set()  # Set connection established flag
                    else:
                        logging.debug(f"Connection request to {target_ip} was not accepted.")
                except socket.timeout:
                    logging.debug(f"No response from {target_ip}. Connection request timed out.")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()

# GUI Setup
def main():
    global root
    root = tk.Tk()
    root.title("Clipboard Sync Dashboard")
    root.geometry("400x300")

    # Display the local IP address at the top of the dashboard
    ip_label = tk.Label(root, text=f"Your IP address: {local_ip}", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=10)

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)  # Resize logo for better fit
      logo_photo = ImageTk.PhotoImage(logo_image)
logo_label = tk.Label(root, image=logo_photo)
logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
logo_label.pack(pady=10)


2024-11-05 14:21:51,082 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
PORT = 5000  # Port for broadcasting and listening
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_IPS = []  # List to store target IP addresses

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

def on_quit(icon, item):
    logging.debug("Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Showing main window from system tray.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and minimizing to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Error", f"Logo file '{image_path}' not found. Exiting application.")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show', show_window), item('Quit', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Error", f"Error while setting up system tray icon: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_IPS:
                            sock.sendto(message.encode('utf-8'), (ip, PORT))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return
        
        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, _ = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)
                
                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue
                
                logging.debug(f"Received clipboard content from network: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                    else:
                        logging.debug("Received content is the same as the current clipboard content. No update needed.")
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return
        
        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request message from {addr[0]}: {received_message}")
                if received_message == "REQUEST_CONNECTION":
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request", f"Accept connection request from {addr[0]}?")
                    if result:
                        TARGET_IPS.append(addr[0])
                        logging.debug(f"Accepted connection from {addr[0]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = "CONNECTION_ACCEPTED"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                    else:
                        logging.debug(f"Rejected connection from {addr[0]}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def send_connection_request(target_ip):
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = "REQUEST_CONNECTION"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind((local_ip, RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    if data.decode('utf-8') == "CONNECTION_ACCEPTED":
                        TARGET_IPS.append(target_ip)
                        logging.debug(f"Connection established with {target_ip}")
                        messagebox.showinfo("Connection Request", f"Connection established with {target_ip}")
                        is_connected.set()  # Set connection established flag
                    else:
                        logging.debug(f"Connection request to {target_ip} was not accepted.")
                except socket.timeout:
                    logging.debug(f"No response from {target_ip}. Connection request timed out.")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()

# GUI Setup
def main():
    global root
    root = tk.Tk()
    root.title("Clipboard Sync Dashboard")
    root.geometry("400x300")

    # Display the local IP address at the top of the dashboard
    ip_label = tk.Label(root, text=f"Your IP address: {local_ip}", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=10)

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)  # Resize logo for better fit
      logo_photo = ImageTk.PhotoImage(logo_image)
logo_label = tk.Label(root, image=logo_photo)
logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
logo_label.pack(pady=10)


2024-11-05 14:21:51,132 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
PORT = 5000  # Port for broadcasting and listening
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_IPS = []  # List to store target IP addresses

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

def on_quit(icon, item):
    logging.debug("Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Showing main window from system tray.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and minimizing to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Error", f"Logo file '{image_path}' not found. Exiting application.")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show', show_window), item('Quit', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Error", f"Error while setting up system tray icon: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_IPS:
                            sock.sendto(message.encode('utf-8'), (ip, PORT))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return
        
        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, _ = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)
                
                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue
                
                logging.debug(f"Received clipboard content from network: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                    else:
                        logging.debug("Received content is the same as the current clipboard content. No update needed.")
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return
        
        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request message from {addr[0]}: {received_message}")
                if received_message == "REQUEST_CONNECTION":
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request", f"Accept connection request from {addr[0]}?")
                    if result:
                        TARGET_IPS.append(addr[0])
                        logging.debug(f"Accepted connection from {addr[0]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = "CONNECTION_ACCEPTED"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                    else:
                        logging.debug(f"Rejected connection from {addr[0]}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def send_connection_request(target_ip):
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = "REQUEST_CONNECTION"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind((local_ip, RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    if data.decode('utf-8') == "CONNECTION_ACCEPTED":
                        TARGET_IPS.append(target_ip)
                        logging.debug(f"Connection established with {target_ip}")
                        messagebox.showinfo("Connection Request", f"Connection established with {target_ip}")
                        is_connected.set()  # Set connection established flag
                    else:
                        logging.debug(f"Connection request to {target_ip} was not accepted.")
                except socket.timeout:
                    logging.debug(f"No response from {target_ip}. Connection request timed out.")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()

# GUI Setup
def main():
    global root
    root = tk.Tk()
    root.title("Clipboard Sync Dashboard")
    root.geometry("400x300")

    # Display the local IP address at the top of the dashboard
    ip_label = tk.Label(root, text=f"Your IP address: {local_ip}", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=10)

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)  # Resize logo for better fit
      logo_photo = ImageTk.PhotoImage(logo_image)
logo_label = tk.Label(root, image=logo_photo)
logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
logo_label.pack(pady=10)


2024-11-05 14:22:02,417 - DEBUG - Broadcasting clipboard content: time.sleep(1)
2024-11-05 14:22:03,116 - DEBUG - Broadcasting clipboard content: time.sleep(1)
2024-11-05 14:22:03,435 - DEBUG - Broadcasting clipboard content: time.sleep(1)
2024-11-05 14:22:03,984 - DEBUG - Broadcasting clipboard content: time.sleep(1)
2024-11-05 14:22:32,711 - DEBUG - Broadcasting clipboard content: the logo isnt showing on the window only showing when its minimised to system trey and the logo isnt binding with exe


2024-11-05 14:22:32,728 - DEBUG - Broadcasting clipboard content: the logo isnt showing on the window only showing when its minimised to system trey and the logo isnt binding with exe


2024-11-05 14:22:33,104 - DEBUG - Broadcasting clipboard content: the logo isnt showing on the window only showing when its minimised to system trey and the logo isnt binding with exe


2024-11-05 14:22:33,608 - DEBUG - Broadcasting clipboard content: the logo isnt showing on the window only showing when its minimised to system trey and the logo isnt binding with exe


2024-11-05 14:24:23,608 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
PORT = 5000  # Port for broadcasting and listening
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_IPS = []  # List to store target IP addresses

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

def on_quit(icon, item):
    logging.debug("Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Showing main window from system tray.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and minimizing to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Error", f"Logo file '{image_path}' not found. Exiting application.")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show', show_window), item('Quit', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Error", f"Error while setting up system tray icon: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_IPS:
                            sock.sendto(message.encode('utf-8'), (ip, PORT))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return
        
        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, _ = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)
                
                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue
                
                logging.debug(f"Received clipboard content from network: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                    else:
                        logging.debug("Received content is the same as the current clipboard content. No update needed.")
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return
        
        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request message from {addr[0]}: {received_message}")
                if received_message == "REQUEST_CONNECTION":
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request", f"Accept connection request from {addr[0]}?")
                    if result:
                        TARGET_IPS.append(addr[0])
                        logging.debug(f"Accepted connection from {addr[0]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = "CONNECTION_ACCEPTED"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                    else:
                        logging.debug(f"Rejected connection from {addr[0]}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def send_connection_request(target_ip):
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = "REQUEST_CONNECTION"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind((local_ip, RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    if data.decode('utf-8') == "CONNECTION_ACCEPTED":
                        TARGET_IPS.append(target_ip)
                        logging.debug(f"Connection established with {target_ip}")
                        messagebox.showinfo("Connection Request", f"Connection established with {target_ip}")
                        is_connected.set()  # Set connection established flag
                    else:
                        logging.debug(f"Connection request to {target_ip} was not accepted.")
                except socket.timeout:
                    logging.debug(f"No response from {target_ip}. Connection request timed out.")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()

# GUI Setup
def main():
    global root
    root = tk.Tk()
    root.title("Clipboard Sync Dashboard")
    

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Display the local IP address at the top of the dashboard
    ip_label = tk.Label(root, text=f"Your IP address: {local_ip}", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=10)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="Send Connection Request", command=lambda: send_connection_request(simpledialog.askstring("Send Request", "Enter IP address to send connection request:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="Waiting for incoming connection requests...")
    listening_label.pack(pady=10)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="Resume Sync")
        else:
            pause_flag.set()
            pause_button.config(text="Pause Sync")
    
    pause_button = tk.Button(root, text="Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Start threads for clipboard sync and connection handling
    start_threads()

    def on_close():
        hide_window()
        messagebox.showinfo("Clipboard Sync", "Clipboard sync will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:24:24,039 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
PORT = 5000  # Port for broadcasting and listening
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_IPS = []  # List to store target IP addresses

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

def on_quit(icon, item):
    logging.debug("Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Showing main window from system tray.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and minimizing to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Error", f"Logo file '{image_path}' not found. Exiting application.")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show', show_window), item('Quit', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Error", f"Error while setting up system tray icon: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_IPS:
                            sock.sendto(message.encode('utf-8'), (ip, PORT))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return
        
        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, _ = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)
                
                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue
                
                logging.debug(f"Received clipboard content from network: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                    else:
                        logging.debug("Received content is the same as the current clipboard content. No update needed.")
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return
        
        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request message from {addr[0]}: {received_message}")
                if received_message == "REQUEST_CONNECTION":
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request", f"Accept connection request from {addr[0]}?")
                    if result:
                        TARGET_IPS.append(addr[0])
                        logging.debug(f"Accepted connection from {addr[0]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = "CONNECTION_ACCEPTED"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                    else:
                        logging.debug(f"Rejected connection from {addr[0]}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def send_connection_request(target_ip):
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = "REQUEST_CONNECTION"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind((local_ip, RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    if data.decode('utf-8') == "CONNECTION_ACCEPTED":
                        TARGET_IPS.append(target_ip)
                        logging.debug(f"Connection established with {target_ip}")
                        messagebox.showinfo("Connection Request", f"Connection established with {target_ip}")
                        is_connected.set()  # Set connection established flag
                    else:
                        logging.debug(f"Connection request to {target_ip} was not accepted.")
                except socket.timeout:
                    logging.debug(f"No response from {target_ip}. Connection request timed out.")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()

# GUI Setup
def main():
    global root
    root = tk.Tk()
    root.title("Clipboard Sync Dashboard")
    

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Display the local IP address at the top of the dashboard
    ip_label = tk.Label(root, text=f"Your IP address: {local_ip}", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=10)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="Send Connection Request", command=lambda: send_connection_request(simpledialog.askstring("Send Request", "Enter IP address to send connection request:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="Waiting for incoming connection requests...")
    listening_label.pack(pady=10)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="Resume Sync")
        else:
            pause_flag.set()
            pause_button.config(text="Pause Sync")
    
    pause_button = tk.Button(root, text="Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Start threads for clipboard sync and connection handling
    start_threads()

    def on_close():
        hide_window()
        messagebox.showinfo("Clipboard Sync", "Clipboard sync will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:24:24,521 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
PORT = 5000  # Port for broadcasting and listening
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_IPS = []  # List to store target IP addresses

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

def on_quit(icon, item):
    logging.debug("Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Showing main window from system tray.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and minimizing to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Error", f"Logo file '{image_path}' not found. Exiting application.")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show', show_window), item('Quit', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Error", f"Error while setting up system tray icon: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_IPS:
                            sock.sendto(message.encode('utf-8'), (ip, PORT))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return
        
        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, _ = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)
                
                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue
                
                logging.debug(f"Received clipboard content from network: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                    else:
                        logging.debug("Received content is the same as the current clipboard content. No update needed.")
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return
        
        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request message from {addr[0]}: {received_message}")
                if received_message == "REQUEST_CONNECTION":
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request", f"Accept connection request from {addr[0]}?")
                    if result:
                        TARGET_IPS.append(addr[0])
                        logging.debug(f"Accepted connection from {addr[0]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = "CONNECTION_ACCEPTED"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                    else:
                        logging.debug(f"Rejected connection from {addr[0]}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def send_connection_request(target_ip):
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = "REQUEST_CONNECTION"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind((local_ip, RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    if data.decode('utf-8') == "CONNECTION_ACCEPTED":
                        TARGET_IPS.append(target_ip)
                        logging.debug(f"Connection established with {target_ip}")
                        messagebox.showinfo("Connection Request", f"Connection established with {target_ip}")
                        is_connected.set()  # Set connection established flag
                    else:
                        logging.debug(f"Connection request to {target_ip} was not accepted.")
                except socket.timeout:
                    logging.debug(f"No response from {target_ip}. Connection request timed out.")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()

# GUI Setup
def main():
    global root
    root = tk.Tk()
    root.title("Clipboard Sync Dashboard")
    

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Display the local IP address at the top of the dashboard
    ip_label = tk.Label(root, text=f"Your IP address: {local_ip}", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=10)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="Send Connection Request", command=lambda: send_connection_request(simpledialog.askstring("Send Request", "Enter IP address to send connection request:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="Waiting for incoming connection requests...")
    listening_label.pack(pady=10)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="Resume Sync")
        else:
            pause_flag.set()
            pause_button.config(text="Pause Sync")
    
    pause_button = tk.Button(root, text="Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Start threads for clipboard sync and connection handling
    start_threads()

    def on_close():
        hide_window()
        messagebox.showinfo("Clipboard Sync", "Clipboard sync will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:24:24,645 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
PORT = 5000  # Port for broadcasting and listening
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_IPS = []  # List to store target IP addresses

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

def on_quit(icon, item):
    logging.debug("Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Showing main window from system tray.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and minimizing to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Error", f"Logo file '{image_path}' not found. Exiting application.")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show', show_window), item('Quit', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Error", f"Error while setting up system tray icon: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_IPS:
                            sock.sendto(message.encode('utf-8'), (ip, PORT))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return
        
        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, _ = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)
                
                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue
                
                logging.debug(f"Received clipboard content from network: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                    else:
                        logging.debug("Received content is the same as the current clipboard content. No update needed.")
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return
        
        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request message from {addr[0]}: {received_message}")
                if received_message == "REQUEST_CONNECTION":
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request", f"Accept connection request from {addr[0]}?")
                    if result:
                        TARGET_IPS.append(addr[0])
                        logging.debug(f"Accepted connection from {addr[0]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = "CONNECTION_ACCEPTED"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                    else:
                        logging.debug(f"Rejected connection from {addr[0]}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def send_connection_request(target_ip):
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = "REQUEST_CONNECTION"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind((local_ip, RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    if data.decode('utf-8') == "CONNECTION_ACCEPTED":
                        TARGET_IPS.append(target_ip)
                        logging.debug(f"Connection established with {target_ip}")
                        messagebox.showinfo("Connection Request", f"Connection established with {target_ip}")
                        is_connected.set()  # Set connection established flag
                    else:
                        logging.debug(f"Connection request to {target_ip} was not accepted.")
                except socket.timeout:
                    logging.debug(f"No response from {target_ip}. Connection request timed out.")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()

# GUI Setup
def main():
    global root
    root = tk.Tk()
    root.title("Clipboard Sync Dashboard")
    

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Display the local IP address at the top of the dashboard
    ip_label = tk.Label(root, text=f"Your IP address: {local_ip}", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=10)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="Send Connection Request", command=lambda: send_connection_request(simpledialog.askstring("Send Request", "Enter IP address to send connection request:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="Waiting for incoming connection requests...")
    listening_label.pack(pady=10)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="Resume Sync")
        else:
            pause_flag.set()
            pause_button.config(text="Pause Sync")
    
    pause_button = tk.Button(root, text="Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Start threads for clipboard sync and connection handling
    start_threads()

    def on_close():
        hide_window()
        messagebox.showinfo("Clipboard Sync", "Clipboard sync will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:24:34,396 - DEBUG - Broadcasting clipboard content: PS C:\Users\Dell\Music\clipboard> python main.py
  File "C:\Users\Dell\Music\clipboard\main.py", line 229
    \u263a
    ^
SyntaxError: invalid non-printable character U+0001
2024-11-05 14:24:34,496 - DEBUG - Broadcasting clipboard content: PS C:\Users\Dell\Music\clipboard> python main.py
  File "C:\Users\Dell\Music\clipboard\main.py", line 229
    \u263a
    ^
SyntaxError: invalid non-printable character U+0001
2024-11-05 14:24:34,715 - DEBUG - Broadcasting clipboard content: PS C:\Users\Dell\Music\clipboard> python main.py
  File "C:\Users\Dell\Music\clipboard\main.py", line 229
    \u263a
    ^
SyntaxError: invalid non-printable character U+0001
2024-11-05 14:24:35,060 - DEBUG - Broadcasting clipboard content: PS C:\Users\Dell\Music\clipboard> python main.py
  File "C:\Users\Dell\Music\clipboard\main.py", line 229
    \u263a
    ^
SyntaxError: invalid non-printable character U+0001
2024-11-05 14:25:03,178 - DEBUG - Broadcasting clipboard content: PS C:\Users\Dell\Music\clipboard> python main.py
  File "C:\Users\Dell\Music\clipboard\main.py", line 229
    \u263a
    ^
SyntaxError: invalid non-printable character U+0001
PS C:\Users\Dell\Music\clipboard> python main.py
Traceback (most recent call last):
  File "C:\Users\Dell\Music\clipboard\main.py", line 285, in <module>
    main()
    ~~~~^^
  File "C:\Users\Dell\Music\clipboard\main.py", line 234, in main
    logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
                                               ^^^^^^^^^^^^^^^
AttributeError: module 'PIL.Image' has no attribute 'ANTIALIAS'
2024-11-05 14:25:03,453 - DEBUG - Broadcasting clipboard content: PS C:\Users\Dell\Music\clipboard> python main.py
  File "C:\Users\Dell\Music\clipboard\main.py", line 229
    \u263a
    ^
SyntaxError: invalid non-printable character U+0001
PS C:\Users\Dell\Music\clipboard> python main.py
Traceback (most recent call last):
  File "C:\Users\Dell\Music\clipboard\main.py", line 285, in <module>
    main()
    ~~~~^^
  File "C:\Users\Dell\Music\clipboard\main.py", line 234, in main
    logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
                                               ^^^^^^^^^^^^^^^
AttributeError: module 'PIL.Image' has no attribute 'ANTIALIAS'
2024-11-05 14:25:03,769 - DEBUG - Broadcasting clipboard content: PS C:\Users\Dell\Music\clipboard> python main.py
  File "C:\Users\Dell\Music\clipboard\main.py", line 229
    \u263a
    ^
SyntaxError: invalid non-printable character U+0001
PS C:\Users\Dell\Music\clipboard> python main.py
Traceback (most recent call last):
  File "C:\Users\Dell\Music\clipboard\main.py", line 285, in <module>
    main()
    ~~~~^^
  File "C:\Users\Dell\Music\clipboard\main.py", line 234, in main
    logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
                                               ^^^^^^^^^^^^^^^
AttributeError: module 'PIL.Image' has no attribute 'ANTIALIAS'
2024-11-05 14:25:03,916 - DEBUG - Broadcasting clipboard content: PS C:\Users\Dell\Music\clipboard> python main.py
  File "C:\Users\Dell\Music\clipboard\main.py", line 229
    \u263a
    ^
SyntaxError: invalid non-printable character U+0001
PS C:\Users\Dell\Music\clipboard> python main.py
Traceback (most recent call last):
  File "C:\Users\Dell\Music\clipboard\main.py", line 285, in <module>
    main()
    ~~~~^^
  File "C:\Users\Dell\Music\clipboard\main.py", line 234, in main
    logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
                                               ^^^^^^^^^^^^^^^
AttributeError: module 'PIL.Image' has no attribute 'ANTIALIAS'
2024-11-05 14:25:26,977 - DEBUG - Broadcasting clipboard content: LANCZOS
2024-11-05 14:25:27,861 - DEBUG - Broadcasting clipboard content: LANCZOS
2024-11-05 14:25:28,317 - DEBUG - Broadcasting clipboard content: LANCZOS
2024-11-05 14:25:28,918 - DEBUG - Broadcasting clipboard content: LANCZOS
2024-11-05 14:25:43,266 - DEBUG - Broadcasting clipboard content: Image.ANTIALIAS
2024-11-05 14:25:43,366 - DEBUG - Broadcasting clipboard content: Image.ANTIALIAS
2024-11-05 14:25:43,537 - DEBUG - Broadcasting clipboard content: Image.ANTIALIAS
2024-11-05 14:25:44,035 - DEBUG - Broadcasting clipboard content: Image.ANTIALIAS
2024-11-05 14:25:57,609 - DEBUG - Broadcasting clipboard content: 
2024-11-05 14:25:59,233 - DEBUG - Broadcasting clipboard content: Image.ANTIALIAS
2024-11-05 14:26:13,129 - DEBUG - Broadcasting clipboard content: Image.LANCZOS
2024-11-05 14:26:13,844 - DEBUG - Broadcasting clipboard content: Image.LANCZOS
2024-11-05 14:26:13,991 - DEBUG - Broadcasting clipboard content: Image.LANCZOS
2024-11-05 14:26:14,029 - DEBUG - Broadcasting clipboard content: Image.LANCZOS
2024-11-05 14:27:49,308 - DEBUG - Hiding main window and minimizing to system tray.
2024-11-05 14:27:49,339 - DEBUG - STREAM b'IHDR' 16 13
2024-11-05 14:27:49,339 - DEBUG - STREAM b'pHYs' 41 9
2024-11-05 14:27:49,339 - DEBUG - STREAM b'iTXt' 62 1105
2024-11-05 14:27:49,339 - DEBUG - STREAM b'IDAT' 1179 20020
2024-11-05 14:27:49,352 - DEBUG - Importing BlpImagePlugin
2024-11-05 14:27:49,353 - DEBUG - Importing BmpImagePlugin
2024-11-05 14:27:49,353 - DEBUG - Importing BufrStubImagePlugin
2024-11-05 14:27:49,354 - DEBUG - Importing CurImagePlugin
2024-11-05 14:27:49,354 - DEBUG - Importing DcxImagePlugin
2024-11-05 14:27:49,355 - DEBUG - Importing DdsImagePlugin
2024-11-05 14:27:49,357 - DEBUG - Importing EpsImagePlugin
2024-11-05 14:27:49,357 - DEBUG - Importing FitsImagePlugin
2024-11-05 14:27:49,358 - DEBUG - Importing FliImagePlugin
2024-11-05 14:27:49,358 - DEBUG - Importing FpxImagePlugin
2024-11-05 14:27:49,358 - DEBUG - Image: failed to import FpxImagePlugin: No module named 'olefile'
2024-11-05 14:27:49,358 - DEBUG - Importing FtexImagePlugin
2024-11-05 14:27:49,358 - DEBUG - Importing GbrImagePlugin
2024-11-05 14:27:49,358 - DEBUG - Importing GifImagePlugin
2024-11-05 14:27:49,358 - DEBUG - Importing GribStubImagePlugin
2024-11-05 14:27:49,359 - DEBUG - Importing Hdf5StubImagePlugin
2024-11-05 14:27:49,359 - DEBUG - Importing IcnsImagePlugin
2024-11-05 14:27:49,359 - DEBUG - Importing IcoImagePlugin
2024-11-05 14:27:49,360 - DEBUG - Importing ImImagePlugin
2024-11-05 14:27:49,360 - DEBUG - Importing ImtImagePlugin
2024-11-05 14:27:49,360 - DEBUG - Importing IptcImagePlugin
2024-11-05 14:27:49,360 - DEBUG - Importing JpegImagePlugin
2024-11-05 14:27:49,360 - DEBUG - Importing Jpeg2KImagePlugin
2024-11-05 14:27:49,360 - DEBUG - Importing McIdasImagePlugin
2024-11-05 14:27:49,361 - DEBUG - Importing MicImagePlugin
2024-11-05 14:27:49,361 - DEBUG - Image: failed to import MicImagePlugin: No module named 'olefile'
2024-11-05 14:27:49,361 - DEBUG - Importing MpegImagePlugin
2024-11-05 14:27:49,361 - DEBUG - Importing MpoImagePlugin
2024-11-05 14:27:49,366 - DEBUG - Importing MspImagePlugin
2024-11-05 14:27:49,366 - DEBUG - Importing PalmImagePlugin
2024-11-05 14:27:49,367 - DEBUG - Importing PcdImagePlugin
2024-11-05 14:27:49,367 - DEBUG - Importing PcxImagePlugin
2024-11-05 14:27:49,367 - DEBUG - Importing PdfImagePlugin
2024-11-05 14:27:49,370 - DEBUG - Importing PixarImagePlugin
2024-11-05 14:27:49,370 - DEBUG - Importing PngImagePlugin
2024-11-05 14:27:49,370 - DEBUG - Importing PpmImagePlugin
2024-11-05 14:27:49,370 - DEBUG - Importing PsdImagePlugin
2024-11-05 14:27:49,370 - DEBUG - Importing QoiImagePlugin
2024-11-05 14:27:49,371 - DEBUG - Importing SgiImagePlugin
2024-11-05 14:27:49,371 - DEBUG - Importing SpiderImagePlugin
2024-11-05 14:27:49,371 - DEBUG - Importing SunImagePlugin
2024-11-05 14:27:49,371 - DEBUG - Importing TgaImagePlugin
2024-11-05 14:27:49,371 - DEBUG - Importing TiffImagePlugin
2024-11-05 14:27:49,371 - DEBUG - Importing WebPImagePlugin
2024-11-05 14:27:49,372 - DEBUG - Importing WmfImagePlugin
2024-11-05 14:27:49,372 - DEBUG - Importing XbmImagePlugin
2024-11-05 14:27:49,373 - DEBUG - Importing XpmImagePlugin
2024-11-05 14:27:49,373 - DEBUG - Importing XVThumbImagePlugin
2024-11-05 14:27:52,659 - DEBUG - Quitting application.
2024-11-05 14:27:52,660 - ERROR - An error occurred when calling message handler
Traceback (most recent call last):
  File "pystray\_win32.py", line 412, in _dispatcher
  File "pystray\_win32.py", line 224, in _on_notify
  File "pystray\_base.py", line 328, in inner
  File "pystray\_base.py", line 453, in __call__
  File "main.py", line 54, in on_quit
SystemExit
2024-11-05 14:28:38,158 - DEBUG - Broadcasting clipboard content: root.iconphoto
2024-11-05 14:28:38,187 - DEBUG - Broadcasting clipboard content: root.iconphoto
2024-11-05 14:28:38,348 - DEBUG - Broadcasting clipboard content: root.iconphoto
2024-11-05 14:28:38,762 - DEBUG - Broadcasting clipboard content: root.iconphoto
2024-11-05 14:32:39,101 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
PORT = 5000  # Port for broadcasting and listening
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_IPS = []  # List to store target IP addresses

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

def on_quit(icon, item):
    logging.debug("Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Showing main window from system tray.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and minimizing to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Error", f"Logo file '{image_path}' not found. Exiting application.")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show', show_window), item('Quit', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Error", f"Error while setting up system tray icon: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_IPS:
                            sock.sendto(message.encode('utf-8'), (ip, PORT))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return
        
        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, _ = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)
                
                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue
                
                logging.debug(f"Received clipboard content from network: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                    else:
                        logging.debug("Received content is the same as the current clipboard content. No update needed.")
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return
        
        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request message from {addr[0]}: {received_message}")
                if received_message == "REQUEST_CONNECTION":
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request", f"Accept connection request from {addr[0]}?")
                    if result:
                        TARGET_IPS.append(addr[0])
                        logging.debug(f"Accepted connection from {addr[0]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = "CONNECTION_ACCEPTED"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                    else:
                        logging.debug(f"Rejected connection from {addr[0]}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def send_connection_request(target_ip):
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = "REQUEST_CONNECTION"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind((local_ip, RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    if data.decode('utf-8') == "CONNECTION_ACCEPTED":
                        TARGET_IPS.append(target_ip)
                        logging.debug(f"Connection established with {target_ip}")
                        messagebox.showinfo("Connection Request", f"Connection established with {target_ip}")
                        is_connected.set()  # Set connection established flag
                    else:
                        logging.debug(f"Connection request to {target_ip} was not accepted.")
                except socket.timeout:
                    logging.debug(f"No response from {target_ip}. Connection request timed out.")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()

# GUI Setup
def main():
    global root
    root = tk.Tk()
    
    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)
    

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Display the local IP address at the top of the dashboard
    ip_label = tk.Label(root, text=f"Your IP address: {local_ip}", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=10)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="Send Connection Request", command=lambda: send_connection_request(simpledialog.askstring("Send Request", "Enter IP address to send connection request:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="Waiting for incoming connection requests...")
    listening_label.pack(pady=10)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="Resume Sync")
        else:
            pause_flag.set()
            pause_button.config(text="Pause Sync")
    
    pause_button = tk.Button(root, text="Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Start threads for clipboard sync and connection handling
    start_threads()

    def on_close():
        hide_window()
        messagebox.showinfo("Clipboard Sync", "Clipboard sync will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:32:39,149 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
PORT = 5000  # Port for broadcasting and listening
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_IPS = []  # List to store target IP addresses

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

def on_quit(icon, item):
    logging.debug("Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Showing main window from system tray.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and minimizing to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Error", f"Logo file '{image_path}' not found. Exiting application.")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show', show_window), item('Quit', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Error", f"Error while setting up system tray icon: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_IPS:
                            sock.sendto(message.encode('utf-8'), (ip, PORT))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return
        
        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, _ = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)
                
                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue
                
                logging.debug(f"Received clipboard content from network: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                    else:
                        logging.debug("Received content is the same as the current clipboard content. No update needed.")
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return
        
        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request message from {addr[0]}: {received_message}")
                if received_message == "REQUEST_CONNECTION":
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request", f"Accept connection request from {addr[0]}?")
                    if result:
                        TARGET_IPS.append(addr[0])
                        logging.debug(f"Accepted connection from {addr[0]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = "CONNECTION_ACCEPTED"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                    else:
                        logging.debug(f"Rejected connection from {addr[0]}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def send_connection_request(target_ip):
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = "REQUEST_CONNECTION"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind((local_ip, RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    if data.decode('utf-8') == "CONNECTION_ACCEPTED":
                        TARGET_IPS.append(target_ip)
                        logging.debug(f"Connection established with {target_ip}")
                        messagebox.showinfo("Connection Request", f"Connection established with {target_ip}")
                        is_connected.set()  # Set connection established flag
                    else:
                        logging.debug(f"Connection request to {target_ip} was not accepted.")
                except socket.timeout:
                    logging.debug(f"No response from {target_ip}. Connection request timed out.")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()

# GUI Setup
def main():
    global root
    root = tk.Tk()
    
    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)
    

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Display the local IP address at the top of the dashboard
    ip_label = tk.Label(root, text=f"Your IP address: {local_ip}", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=10)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="Send Connection Request", command=lambda: send_connection_request(simpledialog.askstring("Send Request", "Enter IP address to send connection request:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="Waiting for incoming connection requests...")
    listening_label.pack(pady=10)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="Resume Sync")
        else:
            pause_flag.set()
            pause_button.config(text="Pause Sync")
    
    pause_button = tk.Button(root, text="Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Start threads for clipboard sync and connection handling
    start_threads()

    def on_close():
        hide_window()
        messagebox.showinfo("Clipboard Sync", "Clipboard sync will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:32:39,194 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
PORT = 5000  # Port for broadcasting and listening
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_IPS = []  # List to store target IP addresses

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

def on_quit(icon, item):
    logging.debug("Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Showing main window from system tray.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and minimizing to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Error", f"Logo file '{image_path}' not found. Exiting application.")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show', show_window), item('Quit', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Error", f"Error while setting up system tray icon: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_IPS:
                            sock.sendto(message.encode('utf-8'), (ip, PORT))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return
        
        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, _ = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)
                
                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue
                
                logging.debug(f"Received clipboard content from network: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                    else:
                        logging.debug("Received content is the same as the current clipboard content. No update needed.")
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return
        
        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request message from {addr[0]}: {received_message}")
                if received_message == "REQUEST_CONNECTION":
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request", f"Accept connection request from {addr[0]}?")
                    if result:
                        TARGET_IPS.append(addr[0])
                        logging.debug(f"Accepted connection from {addr[0]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = "CONNECTION_ACCEPTED"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                    else:
                        logging.debug(f"Rejected connection from {addr[0]}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def send_connection_request(target_ip):
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = "REQUEST_CONNECTION"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind((local_ip, RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    if data.decode('utf-8') == "CONNECTION_ACCEPTED":
                        TARGET_IPS.append(target_ip)
                        logging.debug(f"Connection established with {target_ip}")
                        messagebox.showinfo("Connection Request", f"Connection established with {target_ip}")
                        is_connected.set()  # Set connection established flag
                    else:
                        logging.debug(f"Connection request to {target_ip} was not accepted.")
                except socket.timeout:
                    logging.debug(f"No response from {target_ip}. Connection request timed out.")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()

# GUI Setup
def main():
    global root
    root = tk.Tk()
    
    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)
    

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Display the local IP address at the top of the dashboard
    ip_label = tk.Label(root, text=f"Your IP address: {local_ip}", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=10)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="Send Connection Request", command=lambda: send_connection_request(simpledialog.askstring("Send Request", "Enter IP address to send connection request:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="Waiting for incoming connection requests...")
    listening_label.pack(pady=10)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="Resume Sync")
        else:
            pause_flag.set()
            pause_button.config(text="Pause Sync")
    
    pause_button = tk.Button(root, text="Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Start threads for clipboard sync and connection handling
    start_threads()

    def on_close():
        hide_window()
        messagebox.showinfo("Clipboard Sync", "Clipboard sync will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:32:39,257 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
PORT = 5000  # Port for broadcasting and listening
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_IPS = []  # List to store target IP addresses

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

def on_quit(icon, item):
    logging.debug("Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Showing main window from system tray.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and minimizing to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Error", f"Logo file '{image_path}' not found. Exiting application.")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show', show_window), item('Quit', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Error", f"Error while setting up system tray icon: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_IPS:
                            sock.sendto(message.encode('utf-8'), (ip, PORT))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return
        
        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, _ = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)
                
                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue
                
                logging.debug(f"Received clipboard content from network: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                    else:
                        logging.debug("Received content is the same as the current clipboard content. No update needed.")
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return
        
        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request message from {addr[0]}: {received_message}")
                if received_message == "REQUEST_CONNECTION":
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request", f"Accept connection request from {addr[0]}?")
                    if result:
                        TARGET_IPS.append(addr[0])
                        logging.debug(f"Accepted connection from {addr[0]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = "CONNECTION_ACCEPTED"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                    else:
                        logging.debug(f"Rejected connection from {addr[0]}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def send_connection_request(target_ip):
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = "REQUEST_CONNECTION"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind((local_ip, RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    if data.decode('utf-8') == "CONNECTION_ACCEPTED":
                        TARGET_IPS.append(target_ip)
                        logging.debug(f"Connection established with {target_ip}")
                        messagebox.showinfo("Connection Request", f"Connection established with {target_ip}")
                        is_connected.set()  # Set connection established flag
                    else:
                        logging.debug(f"Connection request to {target_ip} was not accepted.")
                except socket.timeout:
                    logging.debug(f"No response from {target_ip}. Connection request timed out.")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()

# GUI Setup
def main():
    global root
    root = tk.Tk()
    
    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)
    

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Display the local IP address at the top of the dashboard
    ip_label = tk.Label(root, text=f"Your IP address: {local_ip}", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=10)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="Send Connection Request", command=lambda: send_connection_request(simpledialog.askstring("Send Request", "Enter IP address to send connection request:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="Waiting for incoming connection requests...")
    listening_label.pack(pady=10)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="Resume Sync")
        else:
            pause_flag.set()
            pause_button.config(text="Pause Sync")
    
    pause_button = tk.Button(root, text="Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Start threads for clipboard sync and connection handling
    start_threads()

    def on_close():
        hide_window()
        messagebox.showinfo("Clipboard Sync", "Clipboard sync will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:33:02,091 - DEBUG - Broadcasting clipboard content: PS C:\Users\Dell\Music\clipboard> python main.py
  File "C:\Users\Dell\Music\clipboard\main.py", line 228
    \u263a
    ^
SyntaxError: invalid non-printable character U+0001
2024-11-05 14:33:02,478 - DEBUG - Broadcasting clipboard content: PS C:\Users\Dell\Music\clipboard> python main.py
  File "C:\Users\Dell\Music\clipboard\main.py", line 228
    \u263a
    ^
SyntaxError: invalid non-printable character U+0001
2024-11-05 14:33:02,590 - DEBUG - Broadcasting clipboard content: PS C:\Users\Dell\Music\clipboard> python main.py
  File "C:\Users\Dell\Music\clipboard\main.py", line 228
    \u263a
    ^
SyntaxError: invalid non-printable character U+0001
2024-11-05 14:33:02,634 - DEBUG - Broadcasting clipboard content: PS C:\Users\Dell\Music\clipboard> python main.py
  File "C:\Users\Dell\Music\clipboard\main.py", line 228
    \u263a
    ^
SyntaxError: invalid non-printable character U+0001
2024-11-05 14:36:45,863 - DEBUG - Broadcasting clipboard content: 
2024-11-05 14:36:46,372 - DEBUG - Broadcasting clipboard content: 
2024-11-05 14:36:46,820 - DEBUG - Broadcasting clipboard content: 
2024-11-05 14:36:46,878 - DEBUG - Broadcasting clipboard content: 
2024-11-05 14:37:20,030 - DEBUG - Broadcasting clipboard content: Image.LANCZOS
2024-11-05 14:37:20,138 - DEBUG - Broadcasting clipboard content: Image.LANCZOS
2024-11-05 14:37:20,212 - DEBUG - Broadcasting clipboard content: Image.LANCZOS
2024-11-05 14:37:21,417 - DEBUG - Broadcasting clipboard content: Image.LANCZOS
2024-11-05 14:37:27,324 - DEBUG - Broadcasting clipboard content: Image.ANTIALIAS
2024-11-05 14:37:28,582 - DEBUG - Broadcasting clipboard content: Image.ANTIALIAS
2024-11-05 14:37:28,611 - DEBUG - Broadcasting clipboard content: Image.ANTIALIAS
2024-11-05 14:37:28,977 - DEBUG - Broadcasting clipboard content: Image.ANTIALIAS
2024-11-05 14:37:31,668 - DEBUG - Broadcasting clipboard content: Image.LANCZOS
2024-11-05 14:37:32,166 - DEBUG - Broadcasting clipboard content: Image.LANCZOS
2024-11-05 14:37:32,547 - DEBUG - Broadcasting clipboard content: Image.LANCZOS
2024-11-05 14:37:33,393 - DEBUG - Broadcasting clipboard content: Image.LANCZOS
2024-11-05 14:43:53,905 - DEBUG - Broadcasting clipboard content: 1. set a opction to create a Unique username and also allow to send request to usernames insted 

(also check if the none has set the same username before )

2. Cant send request to yourself (send a alert pop saying "BRUHHH you are sending request to yourself"

3. Change every text to something funny but it shows the actually meaning 

4. Show a Log below in the window Which will show Username or Ip address using different color for every different user (use Username in priority)
2024-11-05 14:43:53,989 - DEBUG - Broadcasting clipboard content: 1. set a opction to create a Unique username and also allow to send request to usernames insted 

(also check if the none has set the same username before )

2. Cant send request to yourself (send a alert pop saying "BRUHHH you are sending request to yourself"

3. Change every text to something funny but it shows the actually meaning 

4. Show a Log below in the window Which will show Username or Ip address using different color for every different user (use Username in priority)
2024-11-05 14:43:54,177 - DEBUG - Broadcasting clipboard content: 1. set a opction to create a Unique username and also allow to send request to usernames insted 

(also check if the none has set the same username before )

2. Cant send request to yourself (send a alert pop saying "BRUHHH you are sending request to yourself"

3. Change every text to something funny but it shows the actually meaning 

4. Show a Log below in the window Which will show Username or Ip address using different color for every different user (use Username in priority)
2024-11-05 14:43:54,500 - DEBUG - Broadcasting clipboard content: 1. set a opction to create a Unique username and also allow to send request to usernames insted 

(also check if the none has set the same username before )

2. Cant send request to yourself (send a alert pop saying "BRUHHH you are sending request to yourself"

3. Change every text to something funny but it shows the actually meaning 

4. Show a Log below in the window Which will show Username or Ip address using different color for every different user (use Username in priority)
2024-11-05 14:44:01,077 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
PORT = 5000  # Port for broadcasting and listening
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_IPS = []  # List to store target IP addresses

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

def on_quit(icon, item):
    logging.debug("Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Showing main window from system tray.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and minimizing to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Error", f"Logo file '{image_path}' not found. Exiting application.")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show', show_window), item('Quit', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Error", f"Error while setting up system tray icon: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_IPS:
                            sock.sendto(message.encode('utf-8'), (ip, PORT))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return
        
        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, _ = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)
                
                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue
                
                logging.debug(f"Received clipboard content from network: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                    else:
                        logging.debug("Received content is the same as the current clipboard content. No update needed.")
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return
        
        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request message from {addr[0]}: {received_message}")
                if received_message == "REQUEST_CONNECTION":
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request", f"Accept connection request from {addr[0]}?")
                    if result:
                        TARGET_IPS.append(addr[0])
                        logging.debug(f"Accepted connection from {addr[0]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = "CONNECTION_ACCEPTED"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                    else:
                        logging.debug(f"Rejected connection from {addr[0]}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def send_connection_request(target_ip):
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = "REQUEST_CONNECTION"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind((local_ip, RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    if data.decode('utf-8') == "CONNECTION_ACCEPTED":
                        TARGET_IPS.append(target_ip)
                        logging.debug(f"Connection established with {target_ip}")
                        messagebox.showinfo("Connection Request", f"Connection established with {target_ip}")
                        is_connected.set()  # Set connection established flag
                    else:
                        logging.debug(f"Connection request to {target_ip} was not accepted.")
                except socket.timeout:
                    logging.debug(f"No response from {target_ip}. Connection request timed out.")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()

# GUI Setup
def main():
    global root
    root = tk.Tk()
    
    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)
    

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Display the local IP address at the top of the dashboard
    ip_label = tk.Label(root, text=f"Your IP address: {local_ip}", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=10)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="Send Connection Request", command=lambda: send_connection_request(simpledialog.askstring("Send Request", "Enter IP address to send connection request:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="Waiting for incoming connection requests...")
    listening_label.pack(pady=10)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="Resume Sync")
        else:
            pause_flag.set()
            pause_button.config(text="Pause Sync")
    
    pause_button = tk.Button(root, text="Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Start threads for clipboard sync and connection handling
    start_threads()

    def on_close():
        hide_window()
        messagebox.showinfo("Clipboard Sync", "Clipboard sync will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:44:01,340 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
PORT = 5000  # Port for broadcasting and listening
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_IPS = []  # List to store target IP addresses

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

def on_quit(icon, item):
    logging.debug("Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Showing main window from system tray.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and minimizing to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Error", f"Logo file '{image_path}' not found. Exiting application.")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show', show_window), item('Quit', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Error", f"Error while setting up system tray icon: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_IPS:
                            sock.sendto(message.encode('utf-8'), (ip, PORT))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return
        
        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, _ = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)
                
                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue
                
                logging.debug(f"Received clipboard content from network: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                    else:
                        logging.debug("Received content is the same as the current clipboard content. No update needed.")
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return
        
        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request message from {addr[0]}: {received_message}")
                if received_message == "REQUEST_CONNECTION":
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request", f"Accept connection request from {addr[0]}?")
                    if result:
                        TARGET_IPS.append(addr[0])
                        logging.debug(f"Accepted connection from {addr[0]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = "CONNECTION_ACCEPTED"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                    else:
                        logging.debug(f"Rejected connection from {addr[0]}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def send_connection_request(target_ip):
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = "REQUEST_CONNECTION"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind((local_ip, RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    if data.decode('utf-8') == "CONNECTION_ACCEPTED":
                        TARGET_IPS.append(target_ip)
                        logging.debug(f"Connection established with {target_ip}")
                        messagebox.showinfo("Connection Request", f"Connection established with {target_ip}")
                        is_connected.set()  # Set connection established flag
                    else:
                        logging.debug(f"Connection request to {target_ip} was not accepted.")
                except socket.timeout:
                    logging.debug(f"No response from {target_ip}. Connection request timed out.")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()

# GUI Setup
def main():
    global root
    root = tk.Tk()
    
    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)
    

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Display the local IP address at the top of the dashboard
    ip_label = tk.Label(root, text=f"Your IP address: {local_ip}", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=10)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="Send Connection Request", command=lambda: send_connection_request(simpledialog.askstring("Send Request", "Enter IP address to send connection request:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="Waiting for incoming connection requests...")
    listening_label.pack(pady=10)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="Resume Sync")
        else:
            pause_flag.set()
            pause_button.config(text="Pause Sync")
    
    pause_button = tk.Button(root, text="Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Start threads for clipboard sync and connection handling
    start_threads()

    def on_close():
        hide_window()
        messagebox.showinfo("Clipboard Sync", "Clipboard sync will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:44:02,147 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
PORT = 5000  # Port for broadcasting and listening
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_IPS = []  # List to store target IP addresses

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

def on_quit(icon, item):
    logging.debug("Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Showing main window from system tray.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and minimizing to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Error", f"Logo file '{image_path}' not found. Exiting application.")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show', show_window), item('Quit', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Error", f"Error while setting up system tray icon: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_IPS:
                            sock.sendto(message.encode('utf-8'), (ip, PORT))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return
        
        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, _ = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)
                
                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue
                
                logging.debug(f"Received clipboard content from network: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                    else:
                        logging.debug("Received content is the same as the current clipboard content. No update needed.")
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return
        
        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request message from {addr[0]}: {received_message}")
                if received_message == "REQUEST_CONNECTION":
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request", f"Accept connection request from {addr[0]}?")
                    if result:
                        TARGET_IPS.append(addr[0])
                        logging.debug(f"Accepted connection from {addr[0]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = "CONNECTION_ACCEPTED"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                    else:
                        logging.debug(f"Rejected connection from {addr[0]}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def send_connection_request(target_ip):
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = "REQUEST_CONNECTION"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind((local_ip, RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    if data.decode('utf-8') == "CONNECTION_ACCEPTED":
                        TARGET_IPS.append(target_ip)
                        logging.debug(f"Connection established with {target_ip}")
                        messagebox.showinfo("Connection Request", f"Connection established with {target_ip}")
                        is_connected.set()  # Set connection established flag
                    else:
                        logging.debug(f"Connection request to {target_ip} was not accepted.")
                except socket.timeout:
                    logging.debug(f"No response from {target_ip}. Connection request timed out.")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()

# GUI Setup
def main():
    global root
    root = tk.Tk()
    
    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)
    

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Display the local IP address at the top of the dashboard
    ip_label = tk.Label(root, text=f"Your IP address: {local_ip}", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=10)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="Send Connection Request", command=lambda: send_connection_request(simpledialog.askstring("Send Request", "Enter IP address to send connection request:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="Waiting for incoming connection requests...")
    listening_label.pack(pady=10)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="Resume Sync")
        else:
            pause_flag.set()
            pause_button.config(text="Pause Sync")
    
    pause_button = tk.Button(root, text="Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Start threads for clipboard sync and connection handling
    start_threads()

    def on_close():
        hide_window()
        messagebox.showinfo("Clipboard Sync", "Clipboard sync will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:44:02,244 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
PORT = 5000  # Port for broadcasting and listening
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_IPS = []  # List to store target IP addresses

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

def on_quit(icon, item):
    logging.debug("Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Showing main window from system tray.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and minimizing to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Error", f"Logo file '{image_path}' not found. Exiting application.")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show', show_window), item('Quit', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Error", f"Error while setting up system tray icon: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip in TARGET_IPS:
                            sock.sendto(message.encode('utf-8'), (ip, PORT))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return
        
        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, _ = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)
                
                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue
                
                logging.debug(f"Received clipboard content from network: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                    else:
                        logging.debug("Received content is the same as the current clipboard content. No update needed.")
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return
        
        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request message from {addr[0]}: {received_message}")
                if received_message == "REQUEST_CONNECTION":
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request", f"Accept connection request from {addr[0]}?")
                    if result:
                        TARGET_IPS.append(addr[0])
                        logging.debug(f"Accepted connection from {addr[0]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = "CONNECTION_ACCEPTED"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                    else:
                        logging.debug(f"Rejected connection from {addr[0]}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def send_connection_request(target_ip):
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = "REQUEST_CONNECTION"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind((local_ip, RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    if data.decode('utf-8') == "CONNECTION_ACCEPTED":
                        TARGET_IPS.append(target_ip)
                        logging.debug(f"Connection established with {target_ip}")
                        messagebox.showinfo("Connection Request", f"Connection established with {target_ip}")
                        is_connected.set()  # Set connection established flag
                    else:
                        logging.debug(f"Connection request to {target_ip} was not accepted.")
                except socket.timeout:
                    logging.debug(f"No response from {target_ip}. Connection request timed out.")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()

# GUI Setup
def main():
    global root
    root = tk.Tk()
    
    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)
    

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Display the local IP address at the top of the dashboard
    ip_label = tk.Label(root, text=f"Your IP address: {local_ip}", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=10)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="Send Connection Request", command=lambda: send_connection_request(simpledialog.askstring("Send Request", "Enter IP address to send connection request:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="Waiting for incoming connection requests...")
    listening_label.pack(pady=10)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="Resume Sync")
        else:
            pause_flag.set()
            pause_button.config(text="Pause Sync")
    
    pause_button = tk.Button(root, text="Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Start threads for clipboard sync and connection handling
    start_threads()

    def on_close():
        hide_window()
        messagebox.showinfo("Clipboard Sync", "Clipboard sync will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:44:32,097 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox, scrolledtext
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
PORT = 5000  # Port for broadcasting and listening clipboard content
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_PORT = 5003  # Port for broadcasting usernames
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target usernames and their IPs

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def on_quit(icon, item):
    logging.debug("Buh-bye! Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Popping the main window back from the shadows.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and teleporting to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Oopsie!", f"Logo file '{image_path}' is missing. Exiting...")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show Me!', show_window), item('Hasta La Vista', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Yikes!", f"System tray setup failed: {e}")

def broadcast_username():
    """Broadcast the username to the network to ensure uniqueness."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        message = f"USERNAME:{username}:{local_ip}"
        sock.sendto(message.encode('utf-8'), ('<broadcast>', USERNAME_PORT))
        logging.debug(f"Broadcasted username '{username}' to the network.")
        # Listen for a short period to check for duplicates
        sock.settimeout(2)
        try:
            while True:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip = received_message.split(':', 2)
                    if received_username == username and received_ip != local_ip:
                        logging.warning(f"Username '{username}' is already taken by {received_ip}.")
                        messagebox.showerror("Username Jam!", f"'{username}' is already taken. Pick another one!")
                        return False
        except socket.timeout:
            pass  # No duplicates found
    return True

def listen_for_usernames():
    """Listen for username broadcasts to maintain the TARGET_USERS dictionary."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('', USERNAME_PORT))
        logging.debug(f"Listening for username broadcasts on port {USERNAME_PORT}...")
        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip = received_message.split(':', 2)
                    if received_ip == local_ip:
                        continue  # Ignore own broadcasts
                    if received_username not in TARGET_USERS:
                        TARGET_USERS[received_username] = received_ip
                        logging.debug(f"Discovered user '{received_username}' at {received_ip}.")
            except Exception as e:
                logging.error(f"Error receiving username broadcasts: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard magic: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for user, ip in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, PORT))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard sorcery: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard whispers on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard snippet from {addr[0]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Injecting received clipboard magic into local clipboard...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated with: {received_text}")
                        # Log the activity
                        log_activity(addr[0], received_text)
                    else:
                        logging.debug("Received clipboard is dj vu. No update needed.")
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard snippets: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection giggles on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection giggle from {addr[0]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, target_username = received_message.split(':', 1)
                    # Prevent accepting connection from self
                    if target_username == username:
                        logging.warning(f"Received connection request from self at {addr[0]}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Ping", f"Do you wanna vibe with '{target_username}' from {addr[0]}?")
                    if result:
                        TARGET_USERS[target_username] = addr[0]
                        logging.debug(f"Accepted connection from '{target_username}' at {addr[0]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = f"CONNECTION_ACCEPTED:{username}"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                        # Assign color for the new user
                        if target_username not in user_colors:
                            user_colors[target_username] = get_next_color()
                    else:
                        logging.debug(f"Declined connection from '{target_username}' at {addr[0]}")
            except Exception as e:
                logging.error(f"Error handling connection giggle: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection acceptance on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    _, responder_username = received_message.split(':', 1)
                    TARGET_USERS[responder_username] = addr[0]
                    logging.debug(f"Connection confirmed with '{responder_username}' at {addr[0]}")
                    messagebox.showinfo("Connection Made", f"You're now in cahoots with '{responder_username}'!")
                    is_connected.set()
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_username):
    if target_username == username:
        messagebox.showwarning("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    if target_username not in TARGET_USERS:
        messagebox.showerror("Whoops!", f"No one named '{target_username}' found in the vicinity.")
        logging.error(f"Attempted to connect to unknown username '{target_username}'.")
        return
    target_ip = TARGET_USERS[target_username]
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"REQUEST_CONNECTION:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection giggle to '{target_username}' at {target_ip}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind((local_ip, RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    response_message = data.decode('utf-8')
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        _, responder_username = response_message.split(':', 1)
                        TARGET_USERS[responder_username] = target_ip
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}")
                        messagebox.showinfo("Connection Success", f"Now sharing vibes with '{responder_username}'!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                except socket.timeout:
                    logging.debug(f"No response from '{target_username}' at {target_ip}. Connection timed out.")
                    messagebox.showerror("No Response", f"'{target_username}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection giggle: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to listen for username broadcasts
    threading.Thread(target=listen_for_usernames, daemon=True).start()

def main():
    global root, username
    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("600x500")
    
    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Prompt user to enter a unique username
    while True:
        username = simpledialog.askstring("Set Your Moniker", "Choose a funky username:")
        if not username:
            messagebox.showerror("No Name, No Game", "You gotta have a username to play!")
            continue
        if broadcast_username():
            break  # Unique username set successfully

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text=f"Your cool alias: {username}", font=("Helvetica", 12, "bold"))
    user_label.pack(pady=5)
    
    ip_label = tk.Label(root, text=f"Your secret lair IP: {local_ip}", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="Invite a Buddy", command=lambda: send_connection_request(simpledialog.askstring("Send Invite", "Enter username to invite:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="Chilling and waiting for buddies to join...", font=("Helvetica", 10, "italic"))
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root)
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"))
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10)
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color)
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Start threads for clipboard sync and connection handling
    start_threads()

    def on_close():
        hide_window()
        messagebox.showinfo("ClipHilarity Sync", "Clipboard antics will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:44:32,466 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox, scrolledtext
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
PORT = 5000  # Port for broadcasting and listening clipboard content
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_PORT = 5003  # Port for broadcasting usernames
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target usernames and their IPs

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def on_quit(icon, item):
    logging.debug("Buh-bye! Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Popping the main window back from the shadows.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and teleporting to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Oopsie!", f"Logo file '{image_path}' is missing. Exiting...")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show Me!', show_window), item('Hasta La Vista', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Yikes!", f"System tray setup failed: {e}")

def broadcast_username():
    """Broadcast the username to the network to ensure uniqueness."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        message = f"USERNAME:{username}:{local_ip}"
        sock.sendto(message.encode('utf-8'), ('<broadcast>', USERNAME_PORT))
        logging.debug(f"Broadcasted username '{username}' to the network.")
        # Listen for a short period to check for duplicates
        sock.settimeout(2)
        try:
            while True:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip = received_message.split(':', 2)
                    if received_username == username and received_ip != local_ip:
                        logging.warning(f"Username '{username}' is already taken by {received_ip}.")
                        messagebox.showerror("Username Jam!", f"'{username}' is already taken. Pick another one!")
                        return False
        except socket.timeout:
            pass  # No duplicates found
    return True

def listen_for_usernames():
    """Listen for username broadcasts to maintain the TARGET_USERS dictionary."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('', USERNAME_PORT))
        logging.debug(f"Listening for username broadcasts on port {USERNAME_PORT}...")
        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip = received_message.split(':', 2)
                    if received_ip == local_ip:
                        continue  # Ignore own broadcasts
                    if received_username not in TARGET_USERS:
                        TARGET_USERS[received_username] = received_ip
                        logging.debug(f"Discovered user '{received_username}' at {received_ip}.")
            except Exception as e:
                logging.error(f"Error receiving username broadcasts: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard magic: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for user, ip in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, PORT))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard sorcery: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard whispers on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard snippet from {addr[0]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Injecting received clipboard magic into local clipboard...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated with: {received_text}")
                        # Log the activity
                        log_activity(addr[0], received_text)
                    else:
                        logging.debug("Received clipboard is dj vu. No update needed.")
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard snippets: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection giggles on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection giggle from {addr[0]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, target_username = received_message.split(':', 1)
                    # Prevent accepting connection from self
                    if target_username == username:
                        logging.warning(f"Received connection request from self at {addr[0]}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Ping", f"Do you wanna vibe with '{target_username}' from {addr[0]}?")
                    if result:
                        TARGET_USERS[target_username] = addr[0]
                        logging.debug(f"Accepted connection from '{target_username}' at {addr[0]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = f"CONNECTION_ACCEPTED:{username}"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                        # Assign color for the new user
                        if target_username not in user_colors:
                            user_colors[target_username] = get_next_color()
                    else:
                        logging.debug(f"Declined connection from '{target_username}' at {addr[0]}")
            except Exception as e:
                logging.error(f"Error handling connection giggle: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection acceptance on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    _, responder_username = received_message.split(':', 1)
                    TARGET_USERS[responder_username] = addr[0]
                    logging.debug(f"Connection confirmed with '{responder_username}' at {addr[0]}")
                    messagebox.showinfo("Connection Made", f"You're now in cahoots with '{responder_username}'!")
                    is_connected.set()
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_username):
    if target_username == username:
        messagebox.showwarning("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    if target_username not in TARGET_USERS:
        messagebox.showerror("Whoops!", f"No one named '{target_username}' found in the vicinity.")
        logging.error(f"Attempted to connect to unknown username '{target_username}'.")
        return
    target_ip = TARGET_USERS[target_username]
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"REQUEST_CONNECTION:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection giggle to '{target_username}' at {target_ip}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind((local_ip, RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    response_message = data.decode('utf-8')
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        _, responder_username = response_message.split(':', 1)
                        TARGET_USERS[responder_username] = target_ip
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}")
                        messagebox.showinfo("Connection Success", f"Now sharing vibes with '{responder_username}'!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                except socket.timeout:
                    logging.debug(f"No response from '{target_username}' at {target_ip}. Connection timed out.")
                    messagebox.showerror("No Response", f"'{target_username}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection giggle: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to listen for username broadcasts
    threading.Thread(target=listen_for_usernames, daemon=True).start()

def main():
    global root, username
    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("600x500")
    
    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Prompt user to enter a unique username
    while True:
        username = simpledialog.askstring("Set Your Moniker", "Choose a funky username:")
        if not username:
            messagebox.showerror("No Name, No Game", "You gotta have a username to play!")
            continue
        if broadcast_username():
            break  # Unique username set successfully

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text=f"Your cool alias: {username}", font=("Helvetica", 12, "bold"))
    user_label.pack(pady=5)
    
    ip_label = tk.Label(root, text=f"Your secret lair IP: {local_ip}", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="Invite a Buddy", command=lambda: send_connection_request(simpledialog.askstring("Send Invite", "Enter username to invite:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="Chilling and waiting for buddies to join...", font=("Helvetica", 10, "italic"))
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root)
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"))
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10)
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color)
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Start threads for clipboard sync and connection handling
    start_threads()

    def on_close():
        hide_window()
        messagebox.showinfo("ClipHilarity Sync", "Clipboard antics will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:44:33,061 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox, scrolledtext
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
PORT = 5000  # Port for broadcasting and listening clipboard content
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_PORT = 5003  # Port for broadcasting usernames
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target usernames and their IPs

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def on_quit(icon, item):
    logging.debug("Buh-bye! Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Popping the main window back from the shadows.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and teleporting to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Oopsie!", f"Logo file '{image_path}' is missing. Exiting...")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show Me!', show_window), item('Hasta La Vista', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Yikes!", f"System tray setup failed: {e}")

def broadcast_username():
    """Broadcast the username to the network to ensure uniqueness."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        message = f"USERNAME:{username}:{local_ip}"
        sock.sendto(message.encode('utf-8'), ('<broadcast>', USERNAME_PORT))
        logging.debug(f"Broadcasted username '{username}' to the network.")
        # Listen for a short period to check for duplicates
        sock.settimeout(2)
        try:
            while True:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip = received_message.split(':', 2)
                    if received_username == username and received_ip != local_ip:
                        logging.warning(f"Username '{username}' is already taken by {received_ip}.")
                        messagebox.showerror("Username Jam!", f"'{username}' is already taken. Pick another one!")
                        return False
        except socket.timeout:
            pass  # No duplicates found
    return True

def listen_for_usernames():
    """Listen for username broadcasts to maintain the TARGET_USERS dictionary."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('', USERNAME_PORT))
        logging.debug(f"Listening for username broadcasts on port {USERNAME_PORT}...")
        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip = received_message.split(':', 2)
                    if received_ip == local_ip:
                        continue  # Ignore own broadcasts
                    if received_username not in TARGET_USERS:
                        TARGET_USERS[received_username] = received_ip
                        logging.debug(f"Discovered user '{received_username}' at {received_ip}.")
            except Exception as e:
                logging.error(f"Error receiving username broadcasts: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard magic: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for user, ip in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, PORT))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard sorcery: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard whispers on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard snippet from {addr[0]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Injecting received clipboard magic into local clipboard...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated with: {received_text}")
                        # Log the activity
                        log_activity(addr[0], received_text)
                    else:
                        logging.debug("Received clipboard is dj vu. No update needed.")
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard snippets: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection giggles on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection giggle from {addr[0]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, target_username = received_message.split(':', 1)
                    # Prevent accepting connection from self
                    if target_username == username:
                        logging.warning(f"Received connection request from self at {addr[0]}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Ping", f"Do you wanna vibe with '{target_username}' from {addr[0]}?")
                    if result:
                        TARGET_USERS[target_username] = addr[0]
                        logging.debug(f"Accepted connection from '{target_username}' at {addr[0]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = f"CONNECTION_ACCEPTED:{username}"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                        # Assign color for the new user
                        if target_username not in user_colors:
                            user_colors[target_username] = get_next_color()
                    else:
                        logging.debug(f"Declined connection from '{target_username}' at {addr[0]}")
            except Exception as e:
                logging.error(f"Error handling connection giggle: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection acceptance on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    _, responder_username = received_message.split(':', 1)
                    TARGET_USERS[responder_username] = addr[0]
                    logging.debug(f"Connection confirmed with '{responder_username}' at {addr[0]}")
                    messagebox.showinfo("Connection Made", f"You're now in cahoots with '{responder_username}'!")
                    is_connected.set()
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_username):
    if target_username == username:
        messagebox.showwarning("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    if target_username not in TARGET_USERS:
        messagebox.showerror("Whoops!", f"No one named '{target_username}' found in the vicinity.")
        logging.error(f"Attempted to connect to unknown username '{target_username}'.")
        return
    target_ip = TARGET_USERS[target_username]
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"REQUEST_CONNECTION:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection giggle to '{target_username}' at {target_ip}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind((local_ip, RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    response_message = data.decode('utf-8')
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        _, responder_username = response_message.split(':', 1)
                        TARGET_USERS[responder_username] = target_ip
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}")
                        messagebox.showinfo("Connection Success", f"Now sharing vibes with '{responder_username}'!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                except socket.timeout:
                    logging.debug(f"No response from '{target_username}' at {target_ip}. Connection timed out.")
                    messagebox.showerror("No Response", f"'{target_username}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection giggle: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to listen for username broadcasts
    threading.Thread(target=listen_for_usernames, daemon=True).start()

def main():
    global root, username
    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("600x500")
    
    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Prompt user to enter a unique username
    while True:
        username = simpledialog.askstring("Set Your Moniker", "Choose a funky username:")
        if not username:
            messagebox.showerror("No Name, No Game", "You gotta have a username to play!")
            continue
        if broadcast_username():
            break  # Unique username set successfully

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text=f"Your cool alias: {username}", font=("Helvetica", 12, "bold"))
    user_label.pack(pady=5)
    
    ip_label = tk.Label(root, text=f"Your secret lair IP: {local_ip}", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="Invite a Buddy", command=lambda: send_connection_request(simpledialog.askstring("Send Invite", "Enter username to invite:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="Chilling and waiting for buddies to join...", font=("Helvetica", 10, "italic"))
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root)
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"))
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10)
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color)
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Start threads for clipboard sync and connection handling
    start_threads()

    def on_close():
        hide_window()
        messagebox.showinfo("ClipHilarity Sync", "Clipboard antics will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:44:33,236 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox, scrolledtext
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
PORT = 5000  # Port for broadcasting and listening clipboard content
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_PORT = 5003  # Port for broadcasting usernames
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target usernames and their IPs

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def on_quit(icon, item):
    logging.debug("Buh-bye! Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Popping the main window back from the shadows.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and teleporting to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Oopsie!", f"Logo file '{image_path}' is missing. Exiting...")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show Me!', show_window), item('Hasta La Vista', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Yikes!", f"System tray setup failed: {e}")

def broadcast_username():
    """Broadcast the username to the network to ensure uniqueness."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        message = f"USERNAME:{username}:{local_ip}"
        sock.sendto(message.encode('utf-8'), ('<broadcast>', USERNAME_PORT))
        logging.debug(f"Broadcasted username '{username}' to the network.")
        # Listen for a short period to check for duplicates
        sock.settimeout(2)
        try:
            while True:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip = received_message.split(':', 2)
                    if received_username == username and received_ip != local_ip:
                        logging.warning(f"Username '{username}' is already taken by {received_ip}.")
                        messagebox.showerror("Username Jam!", f"'{username}' is already taken. Pick another one!")
                        return False
        except socket.timeout:
            pass  # No duplicates found
    return True

def listen_for_usernames():
    """Listen for username broadcasts to maintain the TARGET_USERS dictionary."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('', USERNAME_PORT))
        logging.debug(f"Listening for username broadcasts on port {USERNAME_PORT}...")
        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip = received_message.split(':', 2)
                    if received_ip == local_ip:
                        continue  # Ignore own broadcasts
                    if received_username not in TARGET_USERS:
                        TARGET_USERS[received_username] = received_ip
                        logging.debug(f"Discovered user '{received_username}' at {received_ip}.")
            except Exception as e:
                logging.error(f"Error receiving username broadcasts: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard magic: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for user, ip in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, PORT))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard sorcery: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard whispers on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard snippet from {addr[0]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Injecting received clipboard magic into local clipboard...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated with: {received_text}")
                        # Log the activity
                        log_activity(addr[0], received_text)
                    else:
                        logging.debug("Received clipboard is dj vu. No update needed.")
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard snippets: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection giggles on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection giggle from {addr[0]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, target_username = received_message.split(':', 1)
                    # Prevent accepting connection from self
                    if target_username == username:
                        logging.warning(f"Received connection request from self at {addr[0]}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Ping", f"Do you wanna vibe with '{target_username}' from {addr[0]}?")
                    if result:
                        TARGET_USERS[target_username] = addr[0]
                        logging.debug(f"Accepted connection from '{target_username}' at {addr[0]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = f"CONNECTION_ACCEPTED:{username}"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                        # Assign color for the new user
                        if target_username not in user_colors:
                            user_colors[target_username] = get_next_color()
                    else:
                        logging.debug(f"Declined connection from '{target_username}' at {addr[0]}")
            except Exception as e:
                logging.error(f"Error handling connection giggle: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection acceptance on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    _, responder_username = received_message.split(':', 1)
                    TARGET_USERS[responder_username] = addr[0]
                    logging.debug(f"Connection confirmed with '{responder_username}' at {addr[0]}")
                    messagebox.showinfo("Connection Made", f"You're now in cahoots with '{responder_username}'!")
                    is_connected.set()
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_username):
    if target_username == username:
        messagebox.showwarning("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    if target_username not in TARGET_USERS:
        messagebox.showerror("Whoops!", f"No one named '{target_username}' found in the vicinity.")
        logging.error(f"Attempted to connect to unknown username '{target_username}'.")
        return
    target_ip = TARGET_USERS[target_username]
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"REQUEST_CONNECTION:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection giggle to '{target_username}' at {target_ip}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind((local_ip, RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    response_message = data.decode('utf-8')
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        _, responder_username = response_message.split(':', 1)
                        TARGET_USERS[responder_username] = target_ip
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}")
                        messagebox.showinfo("Connection Success", f"Now sharing vibes with '{responder_username}'!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                except socket.timeout:
                    logging.debug(f"No response from '{target_username}' at {target_ip}. Connection timed out.")
                    messagebox.showerror("No Response", f"'{target_username}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection giggle: {e}")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to listen for username broadcasts
    threading.Thread(target=listen_for_usernames, daemon=True).start()

def main():
    global root, username
    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("600x500")
    
    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Prompt user to enter a unique username
    while True:
        username = simpledialog.askstring("Set Your Moniker", "Choose a funky username:")
        if not username:
            messagebox.showerror("No Name, No Game", "You gotta have a username to play!")
            continue
        if broadcast_username():
            break  # Unique username set successfully

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text=f"Your cool alias: {username}", font=("Helvetica", 12, "bold"))
    user_label.pack(pady=5)
    
    ip_label = tk.Label(root, text=f"Your secret lair IP: {local_ip}", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="Invite a Buddy", command=lambda: send_connection_request(simpledialog.askstring("Send Invite", "Enter username to invite:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="Chilling and waiting for buddies to join...", font=("Helvetica", 10, "italic"))
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root)
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"))
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10)
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color)
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Start threads for clipboard sync and connection handling
    start_threads()

    def on_close():
        hide_window()
        messagebox.showinfo("ClipHilarity Sync", "Clipboard antics will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:44:46,229 - DEBUG - Broadcasting clipboard content: 

2024-11-05 14:44:46,348 - DEBUG - Broadcasting clipboard content: 

2024-11-05 14:44:47,247 - DEBUG - Broadcasting clipboard content: 

2024-11-05 14:44:47,343 - DEBUG - Broadcasting clipboard content: 

2024-11-05 14:44:55,144 - DEBUG - Broadcasting clipboard content: Image.ANTIALIAS
2024-11-05 14:44:55,403 - DEBUG - Broadcasting clipboard content: Image.ANTIALIAS
2024-11-05 14:44:55,439 - DEBUG - Broadcasting clipboard content: Image.ANTIALIAS
2024-11-05 14:44:56,385 - DEBUG - Broadcasting clipboard content: Image.ANTIALIAS
2024-11-05 14:46:32,389 - DEBUG - Broadcasting clipboard content: Hasta La Vista
2024-11-05 14:46:32,894 - DEBUG - Broadcasting clipboard content: Hasta La Vista
2024-11-05 14:46:33,118 - DEBUG - Broadcasting clipboard content: Hasta La Vista
2024-11-05 14:46:33,206 - DEBUG - Broadcasting clipboard content: Hasta La Vista
2024-11-05 14:53:31,371 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_PORT = 5003  # Port for broadcasting usernames
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target usernames and their IPs
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def on_quit(icon, item):
    logging.debug("Buh-bye! Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Popping the main window back from the shadows.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and teleporting to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Oopsie!", f"Logo file '{image_path}' is missing. Exiting...")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show Me!', show_window), item('Hasta La Vista (QUIT)', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Yikes!", f"System tray setup failed: {e}")

def broadcast_username():
    """Broadcast the username to the network to ensure uniqueness."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        message = f"USERNAME:{username}:{local_ip}:{PORT}"
        sock.sendto(message.encode('utf-8'), ('<broadcast>', USERNAME_PORT))
        logging.debug(f"Broadcasted username '{username}' to the network.")
        # Listen for a short period to check for duplicates
        sock.settimeout(2)
        try:
            while True:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_username == username and received_ip != local_ip:
                        logging.warning(f"Username '{username}' is already taken by {received_ip}:{received_port}.")
                        messagebox.showerror("Username Jam!", f"'{username}' is already taken by {received_ip}:{received_port}. Pick another one!")
                        return False
        except socket.timeout:
            pass  # No duplicates found
    return True

def listen_for_usernames():
    """Listen for username broadcasts to maintain the TARGET_USERS dictionary."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('', USERNAME_PORT))
        logging.debug(f"Listening for username broadcasts on port {USERNAME_PORT}...")
        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_ip == local_ip and received_port == str(PORT):
                        continue  # Ignore own broadcasts
                    if received_username not in TARGET_USERS:
                        TARGET_USERS[received_username] = {'ip': received_ip, 'port': int(received_port), 'copy_count': 0}
                        logging.debug(f"Discovered user '{received_username}' at {received_ip}:{received_port}.")
            except Exception as e:
                logging.error(f"Error receiving username broadcasts: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard magic: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for user, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (info['ip'], info['port']))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard sorcery: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard whispers on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard snippet from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Injecting received clipboard magic into local clipboard...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated with: {received_text}")
                        # Update copy count
                        for user, info in TARGET_USERS.items():
                            if info['ip'] == addr[0] and info['port'] == addr[1]:
                                info['copy_count'] += 1
                                log_activity(user, f"Copied: {received_text}")
                                break
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard snippets: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection giggles on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection giggle from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, target_username = received_message.split(':', 1)
                    # Prevent accepting connection from self
                    if target_username == username:
                        logging.warning(f"Received connection request from self at {addr[0]}:{addr[1]}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Ping", f"Do you wanna vibe with '{target_username}' from {addr[0]}:{addr[1]}?")
                    if result:
                        TARGET_USERS[target_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                        logging.debug(f"Accepted connection from '{target_username}' at {addr[0]}:{addr[1]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = f"CONNECTION_ACCEPTED:{username}"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                        # Assign color for the new user
                        if target_username not in user_colors:
                            user_colors[target_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                    else:
                        logging.debug(f"Declined connection from '{target_username}' at {addr[0]}:{addr[1]}")
            except Exception as e:
                logging.error(f"Error handling connection giggle: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection acceptance on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    _, responder_username = received_message.split(':', 1)
                    # Find the IP and port based on the responder's address
                    for user, info in TARGET_USERS.items():
                        if info['ip'] == addr[0]:
                            break
                    else:
                        # If not found, add the user
                        TARGET_USERS[responder_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                    logging.debug(f"Connection confirmed with '{responder_username}' at {addr[0]}:{addr[1]}")
                    messagebox.showinfo("Connection Made", f"You're now in cahoots with '{responder_username}'!")
                    is_connected.set()
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_username):
    if not username:
        messagebox.showwarning("Oops!", "Please set your username first!")
        return
    if target_username == username:
        messagebox.showwarning("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    if target_username not in TARGET_USERS:
        messagebox.showerror("Whoops!", f"No one named '{target_username}' found in the vicinity.")
        logging.error(f"Attempted to connect to unknown username '{target_username}'.")
        return
    target_info = TARGET_USERS[target_username]
    target_ip = target_info['ip']
    target_port = target_info['port']
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"REQUEST_CONNECTION:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection giggle to '{target_username}' at {target_ip}:{target_port}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind(('', RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    response_message = data.decode('utf-8')
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        _, responder_username = response_message.split(':', 1)
                        TARGET_USERS[responder_username] = {'ip': target_ip, 'port': target_port, 'copy_count': 0}
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                        messagebox.showinfo("Connection Success", f"Now sharing vibes with '{responder_username}'!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                except socket.timeout:
                    logging.debug(f"No response from '{target_username}' at {target_ip}:{target_port}. Connection request timed out.")
                    messagebox.showerror("No Response", f"'{target_username}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection giggle: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to listen for username broadcasts
    threading.Thread(target=listen_for_usernames, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for user, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(user, info['ip'], info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Username and Port
    settings_frame = tk.Frame(root)
    settings_frame.pack(pady=10)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10))
    username_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30)
    username_entry.grid(row=0, column=1, padx=5, pady=5)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10))
    port_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30)
    port_entry.grid(row=1, column=1, padx=5, pady=5)
    port_info_label = tk.Label(settings_frame, text="Leave blank for automatic selection (5000-5050)", font=("Helvetica", 8), fg="gray")
    port_info_label.grid(row=2, column=0, columnspan=2, padx=5, pady=2)

    # Button to Set Username and Port
    def set_username_port():
        global username, PORT
        entered_username = username_entry.get().strip()
        entered_port = port_entry.get().strip()
        if not entered_username:
            messagebox.showerror("No Name, No Game", "You gotta have a username to play!")
            return
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        messagebox.showerror("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        return
            except ValueError:
                messagebox.showerror("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                logging.debug(f"Automatically selected free port: {PORT}")
            except Exception as e:
                messagebox.showerror("Port Error", str(e))
                return
        username = entered_username
        if broadcast_username():
            messagebox.showinfo("Username Set", f"Username '{username}' set successfully on port {PORT}.")
            # Disable the entries and button after setting
            username_entry.config(state='disabled')
            port_entry.config(state='disabled')
            set_button.config(state='disabled')
            # Display the username and local IP address at the top of the dashboard
            user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
            ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
            # Start the threads after setting username and port
            start_threads()
        else:
            # Username duplication detected; prompt to enter a new one
            username_entry.delete(0, tk.END)

    set_button = tk.Button(settings_frame, text="\U0001f389 Set Username & Port", command=set_username_port)
    set_button.grid(row=3, column=0, columnspan=2, pady=10)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"))
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled', command=lambda: send_connection_request(simpledialog.askstring("Send Invite", "Enter username to invite:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...", font=("Helvetica", 10, "italic"))
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root)
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"))
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10)
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color)
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"))
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def on_close():
        hide_window()
        messagebox.showinfo("ClipHilarity Sync", "Clipboard antics will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
            request_button.config(state='normal')
        else:
            pause_button.pack_forget()
            request_button.config(state='disabled')
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:53:32,149 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_PORT = 5003  # Port for broadcasting usernames
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target usernames and their IPs
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def on_quit(icon, item):
    logging.debug("Buh-bye! Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Popping the main window back from the shadows.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and teleporting to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Oopsie!", f"Logo file '{image_path}' is missing. Exiting...")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show Me!', show_window), item('Hasta La Vista (QUIT)', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Yikes!", f"System tray setup failed: {e}")

def broadcast_username():
    """Broadcast the username to the network to ensure uniqueness."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        message = f"USERNAME:{username}:{local_ip}:{PORT}"
        sock.sendto(message.encode('utf-8'), ('<broadcast>', USERNAME_PORT))
        logging.debug(f"Broadcasted username '{username}' to the network.")
        # Listen for a short period to check for duplicates
        sock.settimeout(2)
        try:
            while True:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_username == username and received_ip != local_ip:
                        logging.warning(f"Username '{username}' is already taken by {received_ip}:{received_port}.")
                        messagebox.showerror("Username Jam!", f"'{username}' is already taken by {received_ip}:{received_port}. Pick another one!")
                        return False
        except socket.timeout:
            pass  # No duplicates found
    return True

def listen_for_usernames():
    """Listen for username broadcasts to maintain the TARGET_USERS dictionary."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('', USERNAME_PORT))
        logging.debug(f"Listening for username broadcasts on port {USERNAME_PORT}...")
        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_ip == local_ip and received_port == str(PORT):
                        continue  # Ignore own broadcasts
                    if received_username not in TARGET_USERS:
                        TARGET_USERS[received_username] = {'ip': received_ip, 'port': int(received_port), 'copy_count': 0}
                        logging.debug(f"Discovered user '{received_username}' at {received_ip}:{received_port}.")
            except Exception as e:
                logging.error(f"Error receiving username broadcasts: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard magic: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for user, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (info['ip'], info['port']))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard sorcery: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard whispers on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard snippet from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Injecting received clipboard magic into local clipboard...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated with: {received_text}")
                        # Update copy count
                        for user, info in TARGET_USERS.items():
                            if info['ip'] == addr[0] and info['port'] == addr[1]:
                                info['copy_count'] += 1
                                log_activity(user, f"Copied: {received_text}")
                                break
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard snippets: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection giggles on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection giggle from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, target_username = received_message.split(':', 1)
                    # Prevent accepting connection from self
                    if target_username == username:
                        logging.warning(f"Received connection request from self at {addr[0]}:{addr[1]}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Ping", f"Do you wanna vibe with '{target_username}' from {addr[0]}:{addr[1]}?")
                    if result:
                        TARGET_USERS[target_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                        logging.debug(f"Accepted connection from '{target_username}' at {addr[0]}:{addr[1]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = f"CONNECTION_ACCEPTED:{username}"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                        # Assign color for the new user
                        if target_username not in user_colors:
                            user_colors[target_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                    else:
                        logging.debug(f"Declined connection from '{target_username}' at {addr[0]}:{addr[1]}")
            except Exception as e:
                logging.error(f"Error handling connection giggle: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection acceptance on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    _, responder_username = received_message.split(':', 1)
                    # Find the IP and port based on the responder's address
                    for user, info in TARGET_USERS.items():
                        if info['ip'] == addr[0]:
                            break
                    else:
                        # If not found, add the user
                        TARGET_USERS[responder_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                    logging.debug(f"Connection confirmed with '{responder_username}' at {addr[0]}:{addr[1]}")
                    messagebox.showinfo("Connection Made", f"You're now in cahoots with '{responder_username}'!")
                    is_connected.set()
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_username):
    if not username:
        messagebox.showwarning("Oops!", "Please set your username first!")
        return
    if target_username == username:
        messagebox.showwarning("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    if target_username not in TARGET_USERS:
        messagebox.showerror("Whoops!", f"No one named '{target_username}' found in the vicinity.")
        logging.error(f"Attempted to connect to unknown username '{target_username}'.")
        return
    target_info = TARGET_USERS[target_username]
    target_ip = target_info['ip']
    target_port = target_info['port']
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"REQUEST_CONNECTION:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection giggle to '{target_username}' at {target_ip}:{target_port}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind(('', RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    response_message = data.decode('utf-8')
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        _, responder_username = response_message.split(':', 1)
                        TARGET_USERS[responder_username] = {'ip': target_ip, 'port': target_port, 'copy_count': 0}
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                        messagebox.showinfo("Connection Success", f"Now sharing vibes with '{responder_username}'!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                except socket.timeout:
                    logging.debug(f"No response from '{target_username}' at {target_ip}:{target_port}. Connection request timed out.")
                    messagebox.showerror("No Response", f"'{target_username}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection giggle: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to listen for username broadcasts
    threading.Thread(target=listen_for_usernames, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for user, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(user, info['ip'], info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Username and Port
    settings_frame = tk.Frame(root)
    settings_frame.pack(pady=10)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10))
    username_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30)
    username_entry.grid(row=0, column=1, padx=5, pady=5)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10))
    port_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30)
    port_entry.grid(row=1, column=1, padx=5, pady=5)
    port_info_label = tk.Label(settings_frame, text="Leave blank for automatic selection (5000-5050)", font=("Helvetica", 8), fg="gray")
    port_info_label.grid(row=2, column=0, columnspan=2, padx=5, pady=2)

    # Button to Set Username and Port
    def set_username_port():
        global username, PORT
        entered_username = username_entry.get().strip()
        entered_port = port_entry.get().strip()
        if not entered_username:
            messagebox.showerror("No Name, No Game", "You gotta have a username to play!")
            return
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        messagebox.showerror("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        return
            except ValueError:
                messagebox.showerror("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                logging.debug(f"Automatically selected free port: {PORT}")
            except Exception as e:
                messagebox.showerror("Port Error", str(e))
                return
        username = entered_username
        if broadcast_username():
            messagebox.showinfo("Username Set", f"Username '{username}' set successfully on port {PORT}.")
            # Disable the entries and button after setting
            username_entry.config(state='disabled')
            port_entry.config(state='disabled')
            set_button.config(state='disabled')
            # Display the username and local IP address at the top of the dashboard
            user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
            ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
            # Start the threads after setting username and port
            start_threads()
        else:
            # Username duplication detected; prompt to enter a new one
            username_entry.delete(0, tk.END)

    set_button = tk.Button(settings_frame, text="\U0001f389 Set Username & Port", command=set_username_port)
    set_button.grid(row=3, column=0, columnspan=2, pady=10)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"))
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled', command=lambda: send_connection_request(simpledialog.askstring("Send Invite", "Enter username to invite:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...", font=("Helvetica", 10, "italic"))
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root)
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"))
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10)
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color)
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"))
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def on_close():
        hide_window()
        messagebox.showinfo("ClipHilarity Sync", "Clipboard antics will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
            request_button.config(state='normal')
        else:
            pause_button.pack_forget()
            request_button.config(state='disabled')
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:53:32,467 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_PORT = 5003  # Port for broadcasting usernames
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target usernames and their IPs
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def on_quit(icon, item):
    logging.debug("Buh-bye! Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Popping the main window back from the shadows.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and teleporting to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Oopsie!", f"Logo file '{image_path}' is missing. Exiting...")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show Me!', show_window), item('Hasta La Vista (QUIT)', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Yikes!", f"System tray setup failed: {e}")

def broadcast_username():
    """Broadcast the username to the network to ensure uniqueness."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        message = f"USERNAME:{username}:{local_ip}:{PORT}"
        sock.sendto(message.encode('utf-8'), ('<broadcast>', USERNAME_PORT))
        logging.debug(f"Broadcasted username '{username}' to the network.")
        # Listen for a short period to check for duplicates
        sock.settimeout(2)
        try:
            while True:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_username == username and received_ip != local_ip:
                        logging.warning(f"Username '{username}' is already taken by {received_ip}:{received_port}.")
                        messagebox.showerror("Username Jam!", f"'{username}' is already taken by {received_ip}:{received_port}. Pick another one!")
                        return False
        except socket.timeout:
            pass  # No duplicates found
    return True

def listen_for_usernames():
    """Listen for username broadcasts to maintain the TARGET_USERS dictionary."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('', USERNAME_PORT))
        logging.debug(f"Listening for username broadcasts on port {USERNAME_PORT}...")
        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_ip == local_ip and received_port == str(PORT):
                        continue  # Ignore own broadcasts
                    if received_username not in TARGET_USERS:
                        TARGET_USERS[received_username] = {'ip': received_ip, 'port': int(received_port), 'copy_count': 0}
                        logging.debug(f"Discovered user '{received_username}' at {received_ip}:{received_port}.")
            except Exception as e:
                logging.error(f"Error receiving username broadcasts: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard magic: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for user, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (info['ip'], info['port']))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard sorcery: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard whispers on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard snippet from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Injecting received clipboard magic into local clipboard...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated with: {received_text}")
                        # Update copy count
                        for user, info in TARGET_USERS.items():
                            if info['ip'] == addr[0] and info['port'] == addr[1]:
                                info['copy_count'] += 1
                                log_activity(user, f"Copied: {received_text}")
                                break
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard snippets: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection giggles on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection giggle from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, target_username = received_message.split(':', 1)
                    # Prevent accepting connection from self
                    if target_username == username:
                        logging.warning(f"Received connection request from self at {addr[0]}:{addr[1]}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Ping", f"Do you wanna vibe with '{target_username}' from {addr[0]}:{addr[1]}?")
                    if result:
                        TARGET_USERS[target_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                        logging.debug(f"Accepted connection from '{target_username}' at {addr[0]}:{addr[1]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = f"CONNECTION_ACCEPTED:{username}"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                        # Assign color for the new user
                        if target_username not in user_colors:
                            user_colors[target_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                    else:
                        logging.debug(f"Declined connection from '{target_username}' at {addr[0]}:{addr[1]}")
            except Exception as e:
                logging.error(f"Error handling connection giggle: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection acceptance on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    _, responder_username = received_message.split(':', 1)
                    # Find the IP and port based on the responder's address
                    for user, info in TARGET_USERS.items():
                        if info['ip'] == addr[0]:
                            break
                    else:
                        # If not found, add the user
                        TARGET_USERS[responder_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                    logging.debug(f"Connection confirmed with '{responder_username}' at {addr[0]}:{addr[1]}")
                    messagebox.showinfo("Connection Made", f"You're now in cahoots with '{responder_username}'!")
                    is_connected.set()
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_username):
    if not username:
        messagebox.showwarning("Oops!", "Please set your username first!")
        return
    if target_username == username:
        messagebox.showwarning("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    if target_username not in TARGET_USERS:
        messagebox.showerror("Whoops!", f"No one named '{target_username}' found in the vicinity.")
        logging.error(f"Attempted to connect to unknown username '{target_username}'.")
        return
    target_info = TARGET_USERS[target_username]
    target_ip = target_info['ip']
    target_port = target_info['port']
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"REQUEST_CONNECTION:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection giggle to '{target_username}' at {target_ip}:{target_port}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind(('', RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    response_message = data.decode('utf-8')
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        _, responder_username = response_message.split(':', 1)
                        TARGET_USERS[responder_username] = {'ip': target_ip, 'port': target_port, 'copy_count': 0}
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                        messagebox.showinfo("Connection Success", f"Now sharing vibes with '{responder_username}'!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                except socket.timeout:
                    logging.debug(f"No response from '{target_username}' at {target_ip}:{target_port}. Connection request timed out.")
                    messagebox.showerror("No Response", f"'{target_username}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection giggle: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to listen for username broadcasts
    threading.Thread(target=listen_for_usernames, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for user, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(user, info['ip'], info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Username and Port
    settings_frame = tk.Frame(root)
    settings_frame.pack(pady=10)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10))
    username_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30)
    username_entry.grid(row=0, column=1, padx=5, pady=5)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10))
    port_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30)
    port_entry.grid(row=1, column=1, padx=5, pady=5)
    port_info_label = tk.Label(settings_frame, text="Leave blank for automatic selection (5000-5050)", font=("Helvetica", 8), fg="gray")
    port_info_label.grid(row=2, column=0, columnspan=2, padx=5, pady=2)

    # Button to Set Username and Port
    def set_username_port():
        global username, PORT
        entered_username = username_entry.get().strip()
        entered_port = port_entry.get().strip()
        if not entered_username:
            messagebox.showerror("No Name, No Game", "You gotta have a username to play!")
            return
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        messagebox.showerror("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        return
            except ValueError:
                messagebox.showerror("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                logging.debug(f"Automatically selected free port: {PORT}")
            except Exception as e:
                messagebox.showerror("Port Error", str(e))
                return
        username = entered_username
        if broadcast_username():
            messagebox.showinfo("Username Set", f"Username '{username}' set successfully on port {PORT}.")
            # Disable the entries and button after setting
            username_entry.config(state='disabled')
            port_entry.config(state='disabled')
            set_button.config(state='disabled')
            # Display the username and local IP address at the top of the dashboard
            user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
            ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
            # Start the threads after setting username and port
            start_threads()
        else:
            # Username duplication detected; prompt to enter a new one
            username_entry.delete(0, tk.END)

    set_button = tk.Button(settings_frame, text="\U0001f389 Set Username & Port", command=set_username_port)
    set_button.grid(row=3, column=0, columnspan=2, pady=10)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"))
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled', command=lambda: send_connection_request(simpledialog.askstring("Send Invite", "Enter username to invite:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...", font=("Helvetica", 10, "italic"))
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root)
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"))
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10)
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color)
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"))
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def on_close():
        hide_window()
        messagebox.showinfo("ClipHilarity Sync", "Clipboard antics will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
            request_button.config(state='normal')
        else:
            pause_button.pack_forget()
            request_button.config(state='disabled')
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:53:32,819 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_PORT = 5003  # Port for broadcasting usernames
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target usernames and their IPs
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def on_quit(icon, item):
    logging.debug("Buh-bye! Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Popping the main window back from the shadows.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and teleporting to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Oopsie!", f"Logo file '{image_path}' is missing. Exiting...")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show Me!', show_window), item('Hasta La Vista (QUIT)', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Yikes!", f"System tray setup failed: {e}")

def broadcast_username():
    """Broadcast the username to the network to ensure uniqueness."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        message = f"USERNAME:{username}:{local_ip}:{PORT}"
        sock.sendto(message.encode('utf-8'), ('<broadcast>', USERNAME_PORT))
        logging.debug(f"Broadcasted username '{username}' to the network.")
        # Listen for a short period to check for duplicates
        sock.settimeout(2)
        try:
            while True:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_username == username and received_ip != local_ip:
                        logging.warning(f"Username '{username}' is already taken by {received_ip}:{received_port}.")
                        messagebox.showerror("Username Jam!", f"'{username}' is already taken by {received_ip}:{received_port}. Pick another one!")
                        return False
        except socket.timeout:
            pass  # No duplicates found
    return True

def listen_for_usernames():
    """Listen for username broadcasts to maintain the TARGET_USERS dictionary."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('', USERNAME_PORT))
        logging.debug(f"Listening for username broadcasts on port {USERNAME_PORT}...")
        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_ip == local_ip and received_port == str(PORT):
                        continue  # Ignore own broadcasts
                    if received_username not in TARGET_USERS:
                        TARGET_USERS[received_username] = {'ip': received_ip, 'port': int(received_port), 'copy_count': 0}
                        logging.debug(f"Discovered user '{received_username}' at {received_ip}:{received_port}.")
            except Exception as e:
                logging.error(f"Error receiving username broadcasts: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard magic: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for user, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (info['ip'], info['port']))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard sorcery: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard whispers on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard snippet from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Injecting received clipboard magic into local clipboard...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated with: {received_text}")
                        # Update copy count
                        for user, info in TARGET_USERS.items():
                            if info['ip'] == addr[0] and info['port'] == addr[1]:
                                info['copy_count'] += 1
                                log_activity(user, f"Copied: {received_text}")
                                break
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard snippets: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection giggles on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection giggle from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, target_username = received_message.split(':', 1)
                    # Prevent accepting connection from self
                    if target_username == username:
                        logging.warning(f"Received connection request from self at {addr[0]}:{addr[1]}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Ping", f"Do you wanna vibe with '{target_username}' from {addr[0]}:{addr[1]}?")
                    if result:
                        TARGET_USERS[target_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                        logging.debug(f"Accepted connection from '{target_username}' at {addr[0]}:{addr[1]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = f"CONNECTION_ACCEPTED:{username}"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                        # Assign color for the new user
                        if target_username not in user_colors:
                            user_colors[target_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                    else:
                        logging.debug(f"Declined connection from '{target_username}' at {addr[0]}:{addr[1]}")
            except Exception as e:
                logging.error(f"Error handling connection giggle: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection acceptance on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    _, responder_username = received_message.split(':', 1)
                    # Find the IP and port based on the responder's address
                    for user, info in TARGET_USERS.items():
                        if info['ip'] == addr[0]:
                            break
                    else:
                        # If not found, add the user
                        TARGET_USERS[responder_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                    logging.debug(f"Connection confirmed with '{responder_username}' at {addr[0]}:{addr[1]}")
                    messagebox.showinfo("Connection Made", f"You're now in cahoots with '{responder_username}'!")
                    is_connected.set()
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_username):
    if not username:
        messagebox.showwarning("Oops!", "Please set your username first!")
        return
    if target_username == username:
        messagebox.showwarning("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    if target_username not in TARGET_USERS:
        messagebox.showerror("Whoops!", f"No one named '{target_username}' found in the vicinity.")
        logging.error(f"Attempted to connect to unknown username '{target_username}'.")
        return
    target_info = TARGET_USERS[target_username]
    target_ip = target_info['ip']
    target_port = target_info['port']
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"REQUEST_CONNECTION:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection giggle to '{target_username}' at {target_ip}:{target_port}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind(('', RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    response_message = data.decode('utf-8')
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        _, responder_username = response_message.split(':', 1)
                        TARGET_USERS[responder_username] = {'ip': target_ip, 'port': target_port, 'copy_count': 0}
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                        messagebox.showinfo("Connection Success", f"Now sharing vibes with '{responder_username}'!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                except socket.timeout:
                    logging.debug(f"No response from '{target_username}' at {target_ip}:{target_port}. Connection request timed out.")
                    messagebox.showerror("No Response", f"'{target_username}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection giggle: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to listen for username broadcasts
    threading.Thread(target=listen_for_usernames, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for user, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(user, info['ip'], info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Username and Port
    settings_frame = tk.Frame(root)
    settings_frame.pack(pady=10)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10))
    username_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30)
    username_entry.grid(row=0, column=1, padx=5, pady=5)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10))
    port_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30)
    port_entry.grid(row=1, column=1, padx=5, pady=5)
    port_info_label = tk.Label(settings_frame, text="Leave blank for automatic selection (5000-5050)", font=("Helvetica", 8), fg="gray")
    port_info_label.grid(row=2, column=0, columnspan=2, padx=5, pady=2)

    # Button to Set Username and Port
    def set_username_port():
        global username, PORT
        entered_username = username_entry.get().strip()
        entered_port = port_entry.get().strip()
        if not entered_username:
            messagebox.showerror("No Name, No Game", "You gotta have a username to play!")
            return
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        messagebox.showerror("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        return
            except ValueError:
                messagebox.showerror("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                logging.debug(f"Automatically selected free port: {PORT}")
            except Exception as e:
                messagebox.showerror("Port Error", str(e))
                return
        username = entered_username
        if broadcast_username():
            messagebox.showinfo("Username Set", f"Username '{username}' set successfully on port {PORT}.")
            # Disable the entries and button after setting
            username_entry.config(state='disabled')
            port_entry.config(state='disabled')
            set_button.config(state='disabled')
            # Display the username and local IP address at the top of the dashboard
            user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
            ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
            # Start the threads after setting username and port
            start_threads()
        else:
            # Username duplication detected; prompt to enter a new one
            username_entry.delete(0, tk.END)

    set_button = tk.Button(settings_frame, text="\U0001f389 Set Username & Port", command=set_username_port)
    set_button.grid(row=3, column=0, columnspan=2, pady=10)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"))
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled', command=lambda: send_connection_request(simpledialog.askstring("Send Invite", "Enter username to invite:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...", font=("Helvetica", 10, "italic"))
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root)
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"))
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10)
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color)
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"))
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def on_close():
        hide_window()
        messagebox.showinfo("ClipHilarity Sync", "Clipboard antics will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
            request_button.config(state='normal')
        else:
            pause_button.pack_forget()
            request_button.config(state='disabled')
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:53:42,345 - DEBUG - Broadcasting clipboard content: Image.ANTIALIAS
2024-11-05 14:53:42,651 - DEBUG - Broadcasting clipboard content: Image.ANTIALIAS
2024-11-05 14:53:43,118 - DEBUG - Broadcasting clipboard content: Image.ANTIALIAS
2024-11-05 14:53:43,198 - DEBUG - Broadcasting clipboard content: Image.ANTIALIAS
2024-11-05 14:54:28,358 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_PORT = 5003  # Port for broadcasting usernames
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target usernames and their IPs
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def on_quit(icon, item):
    logging.debug("Buh-bye! Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Popping the main window back from the shadows.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and teleporting to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Oopsie!", f"Logo file '{image_path}' is missing. Exiting...")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show Me!', show_window), item('Hasta La Vista (QUIT)', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Yikes!", f"System tray setup failed: {e}")

def broadcast_username():
    """Broadcast the username to the network to ensure uniqueness."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        message = f"USERNAME:{username}:{local_ip}:{PORT}"
        sock.sendto(message.encode('utf-8'), ('<broadcast>', USERNAME_PORT))
        logging.debug(f"Broadcasted username '{username}' to the network.")
        # Listen for a short period to check for duplicates
        sock.settimeout(2)
        try:
            while True:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_username == username and received_ip != local_ip:
                        logging.warning(f"Username '{username}' is already taken by {received_ip}:{received_port}.")
                        messagebox.showerror("Username Jam!", f"'{username}' is already taken by {received_ip}:{received_port}. Pick another one!")
                        return False
        except socket.timeout:
            pass  # No duplicates found
    return True

def listen_for_usernames():
    """Listen for username broadcasts to maintain the TARGET_USERS dictionary."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('', USERNAME_PORT))
        logging.debug(f"Listening for username broadcasts on port {USERNAME_PORT}...")
        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_ip == local_ip and received_port == str(PORT):
                        continue  # Ignore own broadcasts
                    if received_username not in TARGET_USERS:
                        TARGET_USERS[received_username] = {'ip': received_ip, 'port': int(received_port), 'copy_count': 0}
                        logging.debug(f"Discovered user '{received_username}' at {received_ip}:{received_port}.")
            except Exception as e:
                logging.error(f"Error receiving username broadcasts: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard magic: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for user, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (info['ip'], info['port']))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard sorcery: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard whispers on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard snippet from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Injecting received clipboard magic into local clipboard...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated with: {received_text}")
                        # Update copy count
                        for user, info in TARGET_USERS.items():
                            if info['ip'] == addr[0] and info['port'] == addr[1]:
                                info['copy_count'] += 1
                                log_activity(user, f"Copied: {received_text}")
                                break
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard snippets: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection giggles on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection giggle from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, target_username = received_message.split(':', 1)
                    # Prevent accepting connection from self
                    if target_username == username:
                        logging.warning(f"Received connection request from self at {addr[0]}:{addr[1]}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Ping", f"Do you wanna vibe with '{target_username}' from {addr[0]}:{addr[1]}?")
                    if result:
                        TARGET_USERS[target_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                        logging.debug(f"Accepted connection from '{target_username}' at {addr[0]}:{addr[1]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = f"CONNECTION_ACCEPTED:{username}"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                        # Assign color for the new user
                        if target_username not in user_colors:
                            user_colors[target_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                    else:
                        logging.debug(f"Declined connection from '{target_username}' at {addr[0]}:{addr[1]}")
            except Exception as e:
                logging.error(f"Error handling connection giggle: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection acceptance on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    _, responder_username = received_message.split(':', 1)
                    # Find the IP and port based on the responder's address
                    for user, info in TARGET_USERS.items():
                        if info['ip'] == addr[0]:
                            break
                    else:
                        # If not found, add the user
                        TARGET_USERS[responder_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                    logging.debug(f"Connection confirmed with '{responder_username}' at {addr[0]}:{addr[1]}")
                    messagebox.showinfo("Connection Made", f"You're now in cahoots with '{responder_username}'!")
                    is_connected.set()
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_username):
    if not username:
        messagebox.showwarning("Oops!", "Please set your username first!")
        return
    if target_username == username:
        messagebox.showwarning("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    if target_username not in TARGET_USERS:
        messagebox.showerror("Whoops!", f"No one named '{target_username}' found in the vicinity.")
        logging.error(f"Attempted to connect to unknown username '{target_username}'.")
        return
    target_info = TARGET_USERS[target_username]
    target_ip = target_info['ip']
    target_port = target_info['port']
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"REQUEST_CONNECTION:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection giggle to '{target_username}' at {target_ip}:{target_port}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind(('', RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    response_message = data.decode('utf-8')
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        _, responder_username = response_message.split(':', 1)
                        TARGET_USERS[responder_username] = {'ip': target_ip, 'port': target_port, 'copy_count': 0}
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                        messagebox.showinfo("Connection Success", f"Now sharing vibes with '{responder_username}'!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                except socket.timeout:
                    logging.debug(f"No response from '{target_username}' at {target_ip}:{target_port}. Connection request timed out.")
                    messagebox.showerror("No Response", f"'{target_username}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection giggle: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to listen for username broadcasts
    threading.Thread(target=listen_for_usernames, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for user, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(user, info['ip'], info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Username and Port
    settings_frame = tk.Frame(root)
    settings_frame.pack(pady=10)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10))
    username_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30)
    username_entry.grid(row=0, column=1, padx=5, pady=5)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10))
    port_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30)
    port_entry.grid(row=1, column=1, padx=5, pady=5)
    port_info_label = tk.Label(settings_frame, text="Leave blank for automatic selection (5000-5050)", font=("Helvetica", 8), fg="gray")
    port_info_label.grid(row=2, column=0, columnspan=2, padx=5, pady=2)

    # Button to Set Username and Port
    def set_username_port():
        global username, PORT
        entered_username = username_entry.get().strip()
        entered_port = port_entry.get().strip()
        if not entered_username:
            messagebox.showerror("No Name, No Game", "You gotta have a username to play!")
            return
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        messagebox.showerror("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        return
            except ValueError:
                messagebox.showerror("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                logging.debug(f"Automatically selected free port: {PORT}")
            except Exception as e:
                messagebox.showerror("Port Error", str(e))
                return
        username = entered_username
        if broadcast_username():
            messagebox.showinfo("Username Set", f"Username '{username}' set successfully on port {PORT}.")
            # Disable the entries and button after setting
            username_entry.config(state='disabled')
            port_entry.config(state='disabled')
            set_button.config(state='disabled')
            # Display the username and local IP address at the top of the dashboard
            user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
            ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
            # Start the threads after setting username and port
            start_threads()
        else:
            # Username duplication detected; prompt to enter a new one
            username_entry.delete(0, tk.END)

    set_button = tk.Button(settings_frame, text="\U0001f389 Set Username & Port", command=set_username_port)
    set_button.grid(row=3, column=0, columnspan=2, pady=10)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"))
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled', command=lambda: send_connection_request(simpledialog.askstring("Send Invite", "Enter username to invite:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...", font=("Helvetica", 10, "italic"))
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root)
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"))
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10)
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color)
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"))
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def on_close():
        hide_window()
        messagebox.showinfo("ClipHilarity Sync", "Clipboard antics will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
            request_button.config(state='normal')
        else:
            pause_button.pack_forget()
            request_button.config(state='disabled')
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:54:28,415 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_PORT = 5003  # Port for broadcasting usernames
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target usernames and their IPs
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def on_quit(icon, item):
    logging.debug("Buh-bye! Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Popping the main window back from the shadows.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and teleporting to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Oopsie!", f"Logo file '{image_path}' is missing. Exiting...")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show Me!', show_window), item('Hasta La Vista (QUIT)', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Yikes!", f"System tray setup failed: {e}")

def broadcast_username():
    """Broadcast the username to the network to ensure uniqueness."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        message = f"USERNAME:{username}:{local_ip}:{PORT}"
        sock.sendto(message.encode('utf-8'), ('<broadcast>', USERNAME_PORT))
        logging.debug(f"Broadcasted username '{username}' to the network.")
        # Listen for a short period to check for duplicates
        sock.settimeout(2)
        try:
            while True:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_username == username and received_ip != local_ip:
                        logging.warning(f"Username '{username}' is already taken by {received_ip}:{received_port}.")
                        messagebox.showerror("Username Jam!", f"'{username}' is already taken by {received_ip}:{received_port}. Pick another one!")
                        return False
        except socket.timeout:
            pass  # No duplicates found
    return True

def listen_for_usernames():
    """Listen for username broadcasts to maintain the TARGET_USERS dictionary."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('', USERNAME_PORT))
        logging.debug(f"Listening for username broadcasts on port {USERNAME_PORT}...")
        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_ip == local_ip and received_port == str(PORT):
                        continue  # Ignore own broadcasts
                    if received_username not in TARGET_USERS:
                        TARGET_USERS[received_username] = {'ip': received_ip, 'port': int(received_port), 'copy_count': 0}
                        logging.debug(f"Discovered user '{received_username}' at {received_ip}:{received_port}.")
            except Exception as e:
                logging.error(f"Error receiving username broadcasts: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard magic: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for user, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (info['ip'], info['port']))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard sorcery: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard whispers on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard snippet from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Injecting received clipboard magic into local clipboard...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated with: {received_text}")
                        # Update copy count
                        for user, info in TARGET_USERS.items():
                            if info['ip'] == addr[0] and info['port'] == addr[1]:
                                info['copy_count'] += 1
                                log_activity(user, f"Copied: {received_text}")
                                break
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard snippets: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection giggles on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection giggle from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, target_username = received_message.split(':', 1)
                    # Prevent accepting connection from self
                    if target_username == username:
                        logging.warning(f"Received connection request from self at {addr[0]}:{addr[1]}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Ping", f"Do you wanna vibe with '{target_username}' from {addr[0]}:{addr[1]}?")
                    if result:
                        TARGET_USERS[target_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                        logging.debug(f"Accepted connection from '{target_username}' at {addr[0]}:{addr[1]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = f"CONNECTION_ACCEPTED:{username}"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                        # Assign color for the new user
                        if target_username not in user_colors:
                            user_colors[target_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                    else:
                        logging.debug(f"Declined connection from '{target_username}' at {addr[0]}:{addr[1]}")
            except Exception as e:
                logging.error(f"Error handling connection giggle: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection acceptance on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    _, responder_username = received_message.split(':', 1)
                    # Find the IP and port based on the responder's address
                    for user, info in TARGET_USERS.items():
                        if info['ip'] == addr[0]:
                            break
                    else:
                        # If not found, add the user
                        TARGET_USERS[responder_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                    logging.debug(f"Connection confirmed with '{responder_username}' at {addr[0]}:{addr[1]}")
                    messagebox.showinfo("Connection Made", f"You're now in cahoots with '{responder_username}'!")
                    is_connected.set()
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_username):
    if not username:
        messagebox.showwarning("Oops!", "Please set your username first!")
        return
    if target_username == username:
        messagebox.showwarning("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    if target_username not in TARGET_USERS:
        messagebox.showerror("Whoops!", f"No one named '{target_username}' found in the vicinity.")
        logging.error(f"Attempted to connect to unknown username '{target_username}'.")
        return
    target_info = TARGET_USERS[target_username]
    target_ip = target_info['ip']
    target_port = target_info['port']
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"REQUEST_CONNECTION:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection giggle to '{target_username}' at {target_ip}:{target_port}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind(('', RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    response_message = data.decode('utf-8')
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        _, responder_username = response_message.split(':', 1)
                        TARGET_USERS[responder_username] = {'ip': target_ip, 'port': target_port, 'copy_count': 0}
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                        messagebox.showinfo("Connection Success", f"Now sharing vibes with '{responder_username}'!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                except socket.timeout:
                    logging.debug(f"No response from '{target_username}' at {target_ip}:{target_port}. Connection request timed out.")
                    messagebox.showerror("No Response", f"'{target_username}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection giggle: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to listen for username broadcasts
    threading.Thread(target=listen_for_usernames, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for user, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(user, info['ip'], info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Username and Port
    settings_frame = tk.Frame(root)
    settings_frame.pack(pady=10)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10))
    username_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30)
    username_entry.grid(row=0, column=1, padx=5, pady=5)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10))
    port_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30)
    port_entry.grid(row=1, column=1, padx=5, pady=5)
    port_info_label = tk.Label(settings_frame, text="Leave blank for automatic selection (5000-5050)", font=("Helvetica", 8), fg="gray")
    port_info_label.grid(row=2, column=0, columnspan=2, padx=5, pady=2)

    # Button to Set Username and Port
    def set_username_port():
        global username, PORT
        entered_username = username_entry.get().strip()
        entered_port = port_entry.get().strip()
        if not entered_username:
            messagebox.showerror("No Name, No Game", "You gotta have a username to play!")
            return
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        messagebox.showerror("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        return
            except ValueError:
                messagebox.showerror("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                logging.debug(f"Automatically selected free port: {PORT}")
            except Exception as e:
                messagebox.showerror("Port Error", str(e))
                return
        username = entered_username
        if broadcast_username():
            messagebox.showinfo("Username Set", f"Username '{username}' set successfully on port {PORT}.")
            # Disable the entries and button after setting
            username_entry.config(state='disabled')
            port_entry.config(state='disabled')
            set_button.config(state='disabled')
            # Display the username and local IP address at the top of the dashboard
            user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
            ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
            # Start the threads after setting username and port
            start_threads()
        else:
            # Username duplication detected; prompt to enter a new one
            username_entry.delete(0, tk.END)

    set_button = tk.Button(settings_frame, text="\U0001f389 Set Username & Port", command=set_username_port)
    set_button.grid(row=3, column=0, columnspan=2, pady=10)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"))
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled', command=lambda: send_connection_request(simpledialog.askstring("Send Invite", "Enter username to invite:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...", font=("Helvetica", 10, "italic"))
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root)
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"))
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10)
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color)
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"))
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def on_close():
        hide_window()
        messagebox.showinfo("ClipHilarity Sync", "Clipboard antics will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
            request_button.config(state='normal')
        else:
            pause_button.pack_forget()
            request_button.config(state='disabled')
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:54:28,636 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_PORT = 5003  # Port for broadcasting usernames
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target usernames and their IPs
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def on_quit(icon, item):
    logging.debug("Buh-bye! Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Popping the main window back from the shadows.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and teleporting to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Oopsie!", f"Logo file '{image_path}' is missing. Exiting...")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show Me!', show_window), item('Hasta La Vista (QUIT)', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Yikes!", f"System tray setup failed: {e}")

def broadcast_username():
    """Broadcast the username to the network to ensure uniqueness."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        message = f"USERNAME:{username}:{local_ip}:{PORT}"
        sock.sendto(message.encode('utf-8'), ('<broadcast>', USERNAME_PORT))
        logging.debug(f"Broadcasted username '{username}' to the network.")
        # Listen for a short period to check for duplicates
        sock.settimeout(2)
        try:
            while True:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_username == username and received_ip != local_ip:
                        logging.warning(f"Username '{username}' is already taken by {received_ip}:{received_port}.")
                        messagebox.showerror("Username Jam!", f"'{username}' is already taken by {received_ip}:{received_port}. Pick another one!")
                        return False
        except socket.timeout:
            pass  # No duplicates found
    return True

def listen_for_usernames():
    """Listen for username broadcasts to maintain the TARGET_USERS dictionary."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('', USERNAME_PORT))
        logging.debug(f"Listening for username broadcasts on port {USERNAME_PORT}...")
        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_ip == local_ip and received_port == str(PORT):
                        continue  # Ignore own broadcasts
                    if received_username not in TARGET_USERS:
                        TARGET_USERS[received_username] = {'ip': received_ip, 'port': int(received_port), 'copy_count': 0}
                        logging.debug(f"Discovered user '{received_username}' at {received_ip}:{received_port}.")
            except Exception as e:
                logging.error(f"Error receiving username broadcasts: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard magic: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for user, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (info['ip'], info['port']))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard sorcery: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard whispers on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard snippet from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Injecting received clipboard magic into local clipboard...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated with: {received_text}")
                        # Update copy count
                        for user, info in TARGET_USERS.items():
                            if info['ip'] == addr[0] and info['port'] == addr[1]:
                                info['copy_count'] += 1
                                log_activity(user, f"Copied: {received_text}")
                                break
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard snippets: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection giggles on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection giggle from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, target_username = received_message.split(':', 1)
                    # Prevent accepting connection from self
                    if target_username == username:
                        logging.warning(f"Received connection request from self at {addr[0]}:{addr[1]}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Ping", f"Do you wanna vibe with '{target_username}' from {addr[0]}:{addr[1]}?")
                    if result:
                        TARGET_USERS[target_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                        logging.debug(f"Accepted connection from '{target_username}' at {addr[0]}:{addr[1]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = f"CONNECTION_ACCEPTED:{username}"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                        # Assign color for the new user
                        if target_username not in user_colors:
                            user_colors[target_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                    else:
                        logging.debug(f"Declined connection from '{target_username}' at {addr[0]}:{addr[1]}")
            except Exception as e:
                logging.error(f"Error handling connection giggle: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection acceptance on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    _, responder_username = received_message.split(':', 1)
                    # Find the IP and port based on the responder's address
                    for user, info in TARGET_USERS.items():
                        if info['ip'] == addr[0]:
                            break
                    else:
                        # If not found, add the user
                        TARGET_USERS[responder_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                    logging.debug(f"Connection confirmed with '{responder_username}' at {addr[0]}:{addr[1]}")
                    messagebox.showinfo("Connection Made", f"You're now in cahoots with '{responder_username}'!")
                    is_connected.set()
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_username):
    if not username:
        messagebox.showwarning("Oops!", "Please set your username first!")
        return
    if target_username == username:
        messagebox.showwarning("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    if target_username not in TARGET_USERS:
        messagebox.showerror("Whoops!", f"No one named '{target_username}' found in the vicinity.")
        logging.error(f"Attempted to connect to unknown username '{target_username}'.")
        return
    target_info = TARGET_USERS[target_username]
    target_ip = target_info['ip']
    target_port = target_info['port']
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"REQUEST_CONNECTION:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection giggle to '{target_username}' at {target_ip}:{target_port}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind(('', RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    response_message = data.decode('utf-8')
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        _, responder_username = response_message.split(':', 1)
                        TARGET_USERS[responder_username] = {'ip': target_ip, 'port': target_port, 'copy_count': 0}
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                        messagebox.showinfo("Connection Success", f"Now sharing vibes with '{responder_username}'!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                except socket.timeout:
                    logging.debug(f"No response from '{target_username}' at {target_ip}:{target_port}. Connection request timed out.")
                    messagebox.showerror("No Response", f"'{target_username}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection giggle: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to listen for username broadcasts
    threading.Thread(target=listen_for_usernames, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for user, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(user, info['ip'], info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Username and Port
    settings_frame = tk.Frame(root)
    settings_frame.pack(pady=10)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10))
    username_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30)
    username_entry.grid(row=0, column=1, padx=5, pady=5)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10))
    port_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30)
    port_entry.grid(row=1, column=1, padx=5, pady=5)
    port_info_label = tk.Label(settings_frame, text="Leave blank for automatic selection (5000-5050)", font=("Helvetica", 8), fg="gray")
    port_info_label.grid(row=2, column=0, columnspan=2, padx=5, pady=2)

    # Button to Set Username and Port
    def set_username_port():
        global username, PORT
        entered_username = username_entry.get().strip()
        entered_port = port_entry.get().strip()
        if not entered_username:
            messagebox.showerror("No Name, No Game", "You gotta have a username to play!")
            return
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        messagebox.showerror("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        return
            except ValueError:
                messagebox.showerror("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                logging.debug(f"Automatically selected free port: {PORT}")
            except Exception as e:
                messagebox.showerror("Port Error", str(e))
                return
        username = entered_username
        if broadcast_username():
            messagebox.showinfo("Username Set", f"Username '{username}' set successfully on port {PORT}.")
            # Disable the entries and button after setting
            username_entry.config(state='disabled')
            port_entry.config(state='disabled')
            set_button.config(state='disabled')
            # Display the username and local IP address at the top of the dashboard
            user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
            ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
            # Start the threads after setting username and port
            start_threads()
        else:
            # Username duplication detected; prompt to enter a new one
            username_entry.delete(0, tk.END)

    set_button = tk.Button(settings_frame, text="\U0001f389 Set Username & Port", command=set_username_port)
    set_button.grid(row=3, column=0, columnspan=2, pady=10)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"))
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled', command=lambda: send_connection_request(simpledialog.askstring("Send Invite", "Enter username to invite:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...", font=("Helvetica", 10, "italic"))
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root)
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"))
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10)
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color)
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"))
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def on_close():
        hide_window()
        messagebox.showinfo("ClipHilarity Sync", "Clipboard antics will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
            request_button.config(state='normal')
        else:
            pause_button.pack_forget()
            request_button.config(state='disabled')
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:54:29,314 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import pystray  # For system tray icon
from pystray import MenuItem as item
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_PORT = 5003  # Port for broadcasting usernames
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target usernames and their IPs
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# System Tray Icon Setup
icon = None

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def on_quit(icon, item):
    logging.debug("Buh-bye! Quitting application.")
    icon.stop()
    sys.exit()

def show_window(icon, item):
    logging.debug("Popping the main window back from the shadows.")
    root.deiconify()

def hide_window():
    logging.debug("Hiding main window and teleporting to system tray.")
    try:
        root.withdraw()
        image_path = "logo.png"
        if not os.path.exists(image_path):
            logging.error(f"Logo file '{image_path}' not found.")
            messagebox.showerror("Oopsie!", f"Logo file '{image_path}' is missing. Exiting...")
            sys.exit()
        image = Image.open(image_path)
        menu = (item('Show Me!', show_window), item('Hasta La Vista (QUIT)', on_quit))
        global icon
        icon = pystray.Icon("ClipboardSync", image, "Clipboard Sync", menu)
        threading.Thread(target=icon.run, daemon=True).start()
    except Exception as e:
        logging.error(f"Error while setting up system tray icon: {e}")
        messagebox.showerror("Yikes!", f"System tray setup failed: {e}")

def broadcast_username():
    """Broadcast the username to the network to ensure uniqueness."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        message = f"USERNAME:{username}:{local_ip}:{PORT}"
        sock.sendto(message.encode('utf-8'), ('<broadcast>', USERNAME_PORT))
        logging.debug(f"Broadcasted username '{username}' to the network.")
        # Listen for a short period to check for duplicates
        sock.settimeout(2)
        try:
            while True:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_username == username and received_ip != local_ip:
                        logging.warning(f"Username '{username}' is already taken by {received_ip}:{received_port}.")
                        messagebox.showerror("Username Jam!", f"'{username}' is already taken by {received_ip}:{received_port}. Pick another one!")
                        return False
        except socket.timeout:
            pass  # No duplicates found
    return True

def listen_for_usernames():
    """Listen for username broadcasts to maintain the TARGET_USERS dictionary."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('', USERNAME_PORT))
        logging.debug(f"Listening for username broadcasts on port {USERNAME_PORT}...")
        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_ip == local_ip and received_port == str(PORT):
                        continue  # Ignore own broadcasts
                    if received_username not in TARGET_USERS:
                        TARGET_USERS[received_username] = {'ip': received_ip, 'port': int(received_port), 'copy_count': 0}
                        logging.debug(f"Discovered user '{received_username}' at {received_ip}:{received_port}.")
            except Exception as e:
                logging.error(f"Error receiving username broadcasts: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard magic: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for user, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (info['ip'], info['port']))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard sorcery: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard whispers on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard snippet from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Injecting received clipboard magic into local clipboard...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated with: {received_text}")
                        # Update copy count
                        for user, info in TARGET_USERS.items():
                            if info['ip'] == addr[0] and info['port'] == addr[1]:
                                info['copy_count'] += 1
                                log_activity(user, f"Copied: {received_text}")
                                break
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard snippets: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection giggles on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection giggle from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, target_username = received_message.split(':', 1)
                    # Prevent accepting connection from self
                    if target_username == username:
                        logging.warning(f"Received connection request from self at {addr[0]}:{addr[1]}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Ping", f"Do you wanna vibe with '{target_username}' from {addr[0]}:{addr[1]}?")
                    if result:
                        TARGET_USERS[target_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                        logging.debug(f"Accepted connection from '{target_username}' at {addr[0]}:{addr[1]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = f"CONNECTION_ACCEPTED:{username}"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                        # Assign color for the new user
                        if target_username not in user_colors:
                            user_colors[target_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                    else:
                        logging.debug(f"Declined connection from '{target_username}' at {addr[0]}:{addr[1]}")
            except Exception as e:
                logging.error(f"Error handling connection giggle: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection acceptance on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    _, responder_username = received_message.split(':', 1)
                    # Find the IP and port based on the responder's address
                    for user, info in TARGET_USERS.items():
                        if info['ip'] == addr[0]:
                            break
                    else:
                        # If not found, add the user
                        TARGET_USERS[responder_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                    logging.debug(f"Connection confirmed with '{responder_username}' at {addr[0]}:{addr[1]}")
                    messagebox.showinfo("Connection Made", f"You're now in cahoots with '{responder_username}'!")
                    is_connected.set()
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_username):
    if not username:
        messagebox.showwarning("Oops!", "Please set your username first!")
        return
    if target_username == username:
        messagebox.showwarning("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    if target_username not in TARGET_USERS:
        messagebox.showerror("Whoops!", f"No one named '{target_username}' found in the vicinity.")
        logging.error(f"Attempted to connect to unknown username '{target_username}'.")
        return
    target_info = TARGET_USERS[target_username]
    target_ip = target_info['ip']
    target_port = target_info['port']
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"REQUEST_CONNECTION:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection giggle to '{target_username}' at {target_ip}:{target_port}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind(('', RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    response_message = data.decode('utf-8')
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        _, responder_username = response_message.split(':', 1)
                        TARGET_USERS[responder_username] = {'ip': target_ip, 'port': target_port, 'copy_count': 0}
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                        messagebox.showinfo("Connection Success", f"Now sharing vibes with '{responder_username}'!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                except socket.timeout:
                    logging.debug(f"No response from '{target_username}' at {target_ip}:{target_port}. Connection request timed out.")
                    messagebox.showerror("No Response", f"'{target_username}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection giggle: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to listen for username broadcasts
    threading.Thread(target=listen_for_usernames, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for user, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(user, info['ip'], info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Username and Port
    settings_frame = tk.Frame(root)
    settings_frame.pack(pady=10)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10))
    username_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30)
    username_entry.grid(row=0, column=1, padx=5, pady=5)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10))
    port_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30)
    port_entry.grid(row=1, column=1, padx=5, pady=5)
    port_info_label = tk.Label(settings_frame, text="Leave blank for automatic selection (5000-5050)", font=("Helvetica", 8), fg="gray")
    port_info_label.grid(row=2, column=0, columnspan=2, padx=5, pady=2)

    # Button to Set Username and Port
    def set_username_port():
        global username, PORT
        entered_username = username_entry.get().strip()
        entered_port = port_entry.get().strip()
        if not entered_username:
            messagebox.showerror("No Name, No Game", "You gotta have a username to play!")
            return
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        messagebox.showerror("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        return
            except ValueError:
                messagebox.showerror("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                logging.debug(f"Automatically selected free port: {PORT}")
            except Exception as e:
                messagebox.showerror("Port Error", str(e))
                return
        username = entered_username
        if broadcast_username():
            messagebox.showinfo("Username Set", f"Username '{username}' set successfully on port {PORT}.")
            # Disable the entries and button after setting
            username_entry.config(state='disabled')
            port_entry.config(state='disabled')
            set_button.config(state='disabled')
            # Display the username and local IP address at the top of the dashboard
            user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
            ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
            # Start the threads after setting username and port
            start_threads()
        else:
            # Username duplication detected; prompt to enter a new one
            username_entry.delete(0, tk.END)

    set_button = tk.Button(settings_frame, text="\U0001f389 Set Username & Port", command=set_username_port)
    set_button.grid(row=3, column=0, columnspan=2, pady=10)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"))
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    request_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled', command=lambda: send_connection_request(simpledialog.askstring("Send Invite", "Enter username to invite:")))
    request_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...", font=("Helvetica", 10, "italic"))
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root)
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"))
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10)
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color)
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"))
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def on_close():
        hide_window()
        messagebox.showinfo("ClipHilarity Sync", "Clipboard antics will continue to run in the background.")

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_connection():
        # Show the pause button once a connection is established
        if is_connected.is_set():
            pause_button.pack(pady=10)
            request_button.config(state='normal')
        else:
            pause_button.pack_forget()
            request_button.config(state='disabled')
        root.after(1000, check_connection)

    # Start checking for connection status
    root.after(1000, check_connection)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 14:54:36,875 - DEBUG - Broadcasting clipboard content: 
2024-11-05 14:54:36,883 - DEBUG - Broadcasting clipboard content: 
2024-11-05 14:54:37,223 - DEBUG - Broadcasting clipboard content: 
2024-11-05 14:54:37,283 - DEBUG - Broadcasting clipboard content: 
2024-11-05 15:00:30,580 - DEBUG - Broadcasting clipboard content: pip install pyperclip pillow

2024-11-05 15:00:31,238 - DEBUG - Broadcasting clipboard content: pip install pyperclip pillow

2024-11-05 15:00:31,372 - DEBUG - Broadcasting clipboard content: pip install pyperclip pillow

2024-11-05 15:00:31,734 - DEBUG - Broadcasting clipboard content: pip install pyperclip pillow

2024-11-05 15:00:37,709 - DEBUG - Broadcasting clipboard content: python clipboard_sync.py

2024-11-05 15:00:37,899 - DEBUG - Broadcasting clipboard content: python clipboard_sync.py

2024-11-05 15:00:37,900 - DEBUG - Broadcasting clipboard content: python clipboard_sync.py

2024-11-05 15:00:38,271 - DEBUG - Broadcasting clipboard content: python clipboard_sync.py

2024-11-05 15:00:44,417 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_PORT = 5003  # Port for broadcasting usernames
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target usernames and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def broadcast_username():
    """Broadcast the username to the network to ensure uniqueness."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        message = f"USERNAME:{username}:{local_ip}:{PORT}"
        sock.sendto(message.encode('utf-8'), ('<broadcast>', USERNAME_PORT))
        logging.debug(f"Broadcasted username '{username}' to the network.")
        # Listen for a short period to check for duplicates
        sock.settimeout(2)
        try:
            while True:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_username == username and received_ip != local_ip:
                        logging.warning(f"Username '{username}' is already taken by {received_ip}:{received_port}.")
                        messagebox.showerror("Username Jam!", f"'{username}' is already taken by {received_ip}:{received_port}. Pick another one!")
                        return False
        except socket.timeout:
            pass  # No duplicates found
    return True

def listen_for_usernames():
    """Listen for username broadcasts to maintain the TARGET_USERS dictionary."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('', USERNAME_PORT))
        logging.debug(f"Listening for username broadcasts on port {USERNAME_PORT}...")
        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_ip == local_ip and int(received_port) == PORT:
                        continue  # Ignore own broadcasts
                    if received_username not in TARGET_USERS:
                        TARGET_USERS[received_username] = {'ip': received_ip, 'port': int(received_port), 'copy_count': 0}
                        logging.debug(f"Discovered user '{received_username}' at {received_ip}:{received_port}.")
                        # Assign color for the new user
                        if received_username not in user_colors:
                            user_colors[received_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
            except Exception as e:
                logging.error(f"Error receiving username broadcasts: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard magic: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for user, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (info['ip'], info['port']))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard sorcery: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard whispers on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard snippet from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Injecting received clipboard magic into local clipboard...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated with: {received_text}")
                        # Update copy count
                        for user, info in TARGET_USERS.items():
                            if info['ip'] == addr[0] and info['port'] == addr[1]:
                                info['copy_count'] += 1
                                log_activity(user, f"Copied: {received_text}")
                                break
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard snippets: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection giggles on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection giggle from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, target_username = received_message.split(':', 1)
                    # Prevent accepting connection from self
                    if target_username == username:
                        logging.warning(f"Received connection request from self at {addr[0]}:{addr[1]}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Ping", f"Do you wanna vibe with '{target_username}' from {addr[0]}:{addr[1]}?")
                    if result:
                        TARGET_USERS[target_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                        logging.debug(f"Accepted connection from '{target_username}' at {addr[0]}:{addr[1]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = f"CONNECTION_ACCEPTED:{username}"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                        # Assign color for the new user
                        if target_username not in user_colors:
                            user_colors[target_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                    else:
                        logging.debug(f"Declined connection from '{target_username}' at {addr[0]}:{addr[1]}")
            except Exception as e:
                logging.error(f"Error handling connection giggle: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection acceptance on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    _, responder_username = received_message.split(':', 1)
                    # Find the IP and port based on the responder's address
                    for user, info in TARGET_USERS.items():
                        if info['ip'] == addr[0]:
                            break
                    else:
                        # If not found, add the user
                        TARGET_USERS[responder_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                    logging.debug(f"Connection confirmed with '{responder_username}' at {addr[0]}:{addr[1]}")
                    messagebox.showinfo("Connection Made", f"You're now in cahoots with '{responder_username}'!")
                    is_connected.set()
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_username):
    if not username:
        messagebox.showwarning("Oops!", "Please set your username first!")
        return
    if target_username == username:
        messagebox.showwarning("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    if target_username not in TARGET_USERS:
        messagebox.showerror("Whoops!", f"No one named '{target_username}' found in the vicinity.")
        logging.error(f"Attempted to connect to unknown username '{target_username}'.")
        return
    target_info = TARGET_USERS[target_username]
    target_ip = target_info['ip']
    target_port = target_info['port']
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"REQUEST_CONNECTION:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection giggle to '{target_username}' at {target_ip}:{target_port}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind(('', RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    response_message = data.decode('utf-8')
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        _, responder_username = response_message.split(':', 1)
                        TARGET_USERS[responder_username] = {'ip': target_ip, 'port': target_port, 'copy_count': 0}
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                        messagebox.showinfo("Connection Success", f"Now sharing vibes with '{responder_username}'!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                except socket.timeout:
                    logging.debug(f"No response from '{target_username}' at {target_ip}:{target_port}. Connection request timed out.")
                    messagebox.showerror("No Response", f"'{target_username}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection giggle: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to listen for username broadcasts
    threading.Thread(target=listen_for_usernames, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for user, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(user, info['ip'], info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Username and Port
    settings_frame = tk.Frame(root)
    settings_frame.pack(pady=10)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10))
    username_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30)
    username_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Username
    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            messagebox.showerror("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            messagebox.showwarning("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        if broadcast_username():
            messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
            # Disable the username entry and button after setting
            username_entry.config(state='disabled')
            set_username_button.config(state='disabled')
            # Display the username and local IP address at the top of the dashboard
            user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
            # Enable the Invite button if at least one connection is possible
            invite_button.config(state='normal')

    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=set_username)
    set_username_button.grid(row=0, column=2, padx=5, pady=5)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10))
    port_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30)
    port_entry.grid(row=1, column=1, padx=5, pady=5)
    port_info_label = tk.Label(settings_frame, text="Leave blank for automatic selection (5000-5050)", font=("Helvetica", 8), fg="gray")
    port_info_label.grid(row=2, column=0, columnspan=3, padx=5, pady=2)

    # Button to Set Port
    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        messagebox.showerror("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                messagebox.showerror("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                logging.debug(f"Automatically selected free port: {PORT}")
                messagebox.showinfo("Port Selected", f"Automatically selected free port: {PORT}")
            except Exception as e:
                messagebox.showerror("Port Error", str(e))
                return
        messagebox.showinfo("Port Set", f"Communication port set to {PORT}.")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Display the local IP address at the top of the dashboard
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Enable the Set Username button if not already set
        if username:
            invite_button.config(state='normal')

    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=set_port)
    set_port_button.grid(row=1, column=2, padx=5, pady=5)

    # Button to Auto-Set Port
    def auto_set_port():
        global PORT
        if PORT:
            messagebox.showinfo("Port Already Set", f"Communication port is already set to {PORT}.")
            return
        try:
            PORT = find_free_port()
            logging.debug(f"Automatically selected free port: {PORT}")
            messagebox.showinfo("Port Selected", f"Automatically selected free port: {PORT}")
            # Update port_entry field
            port_entry.insert(0, str(PORT))
            # Disable the port entry and button after setting
            port_entry.config(state='disabled')
            set_port_button.config(state='disabled')
            # Display the local IP address at the top of the dashboard
            ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
            # Enable the Set Username button if not already set
            if username:
                invite_button.config(state='normal')
        except Exception as e:
            messagebox.showerror("Port Error", str(e))

    # Optionally, you can add an "Auto-Set Port" button
    # auto_set_port_button = tk.Button(settings_frame, text="\U0001f680 Auto-Set Port", command=auto_set_port)
    # auto_set_port_button.grid(row=1, column=3, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"))
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled', command=lambda: send_connection_request(simpledialog.askstring("Send Invite", "Enter username to invite:")))
    invite_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...", font=("Helvetica", 10, "italic"))
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root)
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"))
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10)
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color)
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"))
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:00:45,111 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_PORT = 5003  # Port for broadcasting usernames
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target usernames and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def broadcast_username():
    """Broadcast the username to the network to ensure uniqueness."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        message = f"USERNAME:{username}:{local_ip}:{PORT}"
        sock.sendto(message.encode('utf-8'), ('<broadcast>', USERNAME_PORT))
        logging.debug(f"Broadcasted username '{username}' to the network.")
        # Listen for a short period to check for duplicates
        sock.settimeout(2)
        try:
            while True:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_username == username and received_ip != local_ip:
                        logging.warning(f"Username '{username}' is already taken by {received_ip}:{received_port}.")
                        messagebox.showerror("Username Jam!", f"'{username}' is already taken by {received_ip}:{received_port}. Pick another one!")
                        return False
        except socket.timeout:
            pass  # No duplicates found
    return True

def listen_for_usernames():
    """Listen for username broadcasts to maintain the TARGET_USERS dictionary."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('', USERNAME_PORT))
        logging.debug(f"Listening for username broadcasts on port {USERNAME_PORT}...")
        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_ip == local_ip and int(received_port) == PORT:
                        continue  # Ignore own broadcasts
                    if received_username not in TARGET_USERS:
                        TARGET_USERS[received_username] = {'ip': received_ip, 'port': int(received_port), 'copy_count': 0}
                        logging.debug(f"Discovered user '{received_username}' at {received_ip}:{received_port}.")
                        # Assign color for the new user
                        if received_username not in user_colors:
                            user_colors[received_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
            except Exception as e:
                logging.error(f"Error receiving username broadcasts: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard magic: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for user, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (info['ip'], info['port']))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard sorcery: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard whispers on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard snippet from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Injecting received clipboard magic into local clipboard...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated with: {received_text}")
                        # Update copy count
                        for user, info in TARGET_USERS.items():
                            if info['ip'] == addr[0] and info['port'] == addr[1]:
                                info['copy_count'] += 1
                                log_activity(user, f"Copied: {received_text}")
                                break
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard snippets: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection giggles on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection giggle from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, target_username = received_message.split(':', 1)
                    # Prevent accepting connection from self
                    if target_username == username:
                        logging.warning(f"Received connection request from self at {addr[0]}:{addr[1]}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Ping", f"Do you wanna vibe with '{target_username}' from {addr[0]}:{addr[1]}?")
                    if result:
                        TARGET_USERS[target_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                        logging.debug(f"Accepted connection from '{target_username}' at {addr[0]}:{addr[1]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = f"CONNECTION_ACCEPTED:{username}"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                        # Assign color for the new user
                        if target_username not in user_colors:
                            user_colors[target_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                    else:
                        logging.debug(f"Declined connection from '{target_username}' at {addr[0]}:{addr[1]}")
            except Exception as e:
                logging.error(f"Error handling connection giggle: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection acceptance on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    _, responder_username = received_message.split(':', 1)
                    # Find the IP and port based on the responder's address
                    for user, info in TARGET_USERS.items():
                        if info['ip'] == addr[0]:
                            break
                    else:
                        # If not found, add the user
                        TARGET_USERS[responder_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                    logging.debug(f"Connection confirmed with '{responder_username}' at {addr[0]}:{addr[1]}")
                    messagebox.showinfo("Connection Made", f"You're now in cahoots with '{responder_username}'!")
                    is_connected.set()
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_username):
    if not username:
        messagebox.showwarning("Oops!", "Please set your username first!")
        return
    if target_username == username:
        messagebox.showwarning("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    if target_username not in TARGET_USERS:
        messagebox.showerror("Whoops!", f"No one named '{target_username}' found in the vicinity.")
        logging.error(f"Attempted to connect to unknown username '{target_username}'.")
        return
    target_info = TARGET_USERS[target_username]
    target_ip = target_info['ip']
    target_port = target_info['port']
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"REQUEST_CONNECTION:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection giggle to '{target_username}' at {target_ip}:{target_port}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind(('', RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    response_message = data.decode('utf-8')
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        _, responder_username = response_message.split(':', 1)
                        TARGET_USERS[responder_username] = {'ip': target_ip, 'port': target_port, 'copy_count': 0}
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                        messagebox.showinfo("Connection Success", f"Now sharing vibes with '{responder_username}'!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                except socket.timeout:
                    logging.debug(f"No response from '{target_username}' at {target_ip}:{target_port}. Connection request timed out.")
                    messagebox.showerror("No Response", f"'{target_username}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection giggle: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to listen for username broadcasts
    threading.Thread(target=listen_for_usernames, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for user, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(user, info['ip'], info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Username and Port
    settings_frame = tk.Frame(root)
    settings_frame.pack(pady=10)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10))
    username_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30)
    username_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Username
    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            messagebox.showerror("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            messagebox.showwarning("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        if broadcast_username():
            messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
            # Disable the username entry and button after setting
            username_entry.config(state='disabled')
            set_username_button.config(state='disabled')
            # Display the username and local IP address at the top of the dashboard
            user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
            # Enable the Invite button if at least one connection is possible
            invite_button.config(state='normal')

    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=set_username)
    set_username_button.grid(row=0, column=2, padx=5, pady=5)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10))
    port_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30)
    port_entry.grid(row=1, column=1, padx=5, pady=5)
    port_info_label = tk.Label(settings_frame, text="Leave blank for automatic selection (5000-5050)", font=("Helvetica", 8), fg="gray")
    port_info_label.grid(row=2, column=0, columnspan=3, padx=5, pady=2)

    # Button to Set Port
    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        messagebox.showerror("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                messagebox.showerror("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                logging.debug(f"Automatically selected free port: {PORT}")
                messagebox.showinfo("Port Selected", f"Automatically selected free port: {PORT}")
            except Exception as e:
                messagebox.showerror("Port Error", str(e))
                return
        messagebox.showinfo("Port Set", f"Communication port set to {PORT}.")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Display the local IP address at the top of the dashboard
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Enable the Set Username button if not already set
        if username:
            invite_button.config(state='normal')

    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=set_port)
    set_port_button.grid(row=1, column=2, padx=5, pady=5)

    # Button to Auto-Set Port
    def auto_set_port():
        global PORT
        if PORT:
            messagebox.showinfo("Port Already Set", f"Communication port is already set to {PORT}.")
            return
        try:
            PORT = find_free_port()
            logging.debug(f"Automatically selected free port: {PORT}")
            messagebox.showinfo("Port Selected", f"Automatically selected free port: {PORT}")
            # Update port_entry field
            port_entry.insert(0, str(PORT))
            # Disable the port entry and button after setting
            port_entry.config(state='disabled')
            set_port_button.config(state='disabled')
            # Display the local IP address at the top of the dashboard
            ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
            # Enable the Set Username button if not already set
            if username:
                invite_button.config(state='normal')
        except Exception as e:
            messagebox.showerror("Port Error", str(e))

    # Optionally, you can add an "Auto-Set Port" button
    # auto_set_port_button = tk.Button(settings_frame, text="\U0001f680 Auto-Set Port", command=auto_set_port)
    # auto_set_port_button.grid(row=1, column=3, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"))
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled', command=lambda: send_connection_request(simpledialog.askstring("Send Invite", "Enter username to invite:")))
    invite_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...", font=("Helvetica", 10, "italic"))
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root)
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"))
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10)
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color)
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"))
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:00:45,402 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_PORT = 5003  # Port for broadcasting usernames
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target usernames and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def broadcast_username():
    """Broadcast the username to the network to ensure uniqueness."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        message = f"USERNAME:{username}:{local_ip}:{PORT}"
        sock.sendto(message.encode('utf-8'), ('<broadcast>', USERNAME_PORT))
        logging.debug(f"Broadcasted username '{username}' to the network.")
        # Listen for a short period to check for duplicates
        sock.settimeout(2)
        try:
            while True:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_username == username and received_ip != local_ip:
                        logging.warning(f"Username '{username}' is already taken by {received_ip}:{received_port}.")
                        messagebox.showerror("Username Jam!", f"'{username}' is already taken by {received_ip}:{received_port}. Pick another one!")
                        return False
        except socket.timeout:
            pass  # No duplicates found
    return True

def listen_for_usernames():
    """Listen for username broadcasts to maintain the TARGET_USERS dictionary."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('', USERNAME_PORT))
        logging.debug(f"Listening for username broadcasts on port {USERNAME_PORT}...")
        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_ip == local_ip and int(received_port) == PORT:
                        continue  # Ignore own broadcasts
                    if received_username not in TARGET_USERS:
                        TARGET_USERS[received_username] = {'ip': received_ip, 'port': int(received_port), 'copy_count': 0}
                        logging.debug(f"Discovered user '{received_username}' at {received_ip}:{received_port}.")
                        # Assign color for the new user
                        if received_username not in user_colors:
                            user_colors[received_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
            except Exception as e:
                logging.error(f"Error receiving username broadcasts: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard magic: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for user, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (info['ip'], info['port']))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard sorcery: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard whispers on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard snippet from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Injecting received clipboard magic into local clipboard...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated with: {received_text}")
                        # Update copy count
                        for user, info in TARGET_USERS.items():
                            if info['ip'] == addr[0] and info['port'] == addr[1]:
                                info['copy_count'] += 1
                                log_activity(user, f"Copied: {received_text}")
                                break
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard snippets: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection giggles on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection giggle from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, target_username = received_message.split(':', 1)
                    # Prevent accepting connection from self
                    if target_username == username:
                        logging.warning(f"Received connection request from self at {addr[0]}:{addr[1]}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Ping", f"Do you wanna vibe with '{target_username}' from {addr[0]}:{addr[1]}?")
                    if result:
                        TARGET_USERS[target_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                        logging.debug(f"Accepted connection from '{target_username}' at {addr[0]}:{addr[1]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = f"CONNECTION_ACCEPTED:{username}"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                        # Assign color for the new user
                        if target_username not in user_colors:
                            user_colors[target_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                    else:
                        logging.debug(f"Declined connection from '{target_username}' at {addr[0]}:{addr[1]}")
            except Exception as e:
                logging.error(f"Error handling connection giggle: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection acceptance on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    _, responder_username = received_message.split(':', 1)
                    # Find the IP and port based on the responder's address
                    for user, info in TARGET_USERS.items():
                        if info['ip'] == addr[0]:
                            break
                    else:
                        # If not found, add the user
                        TARGET_USERS[responder_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                    logging.debug(f"Connection confirmed with '{responder_username}' at {addr[0]}:{addr[1]}")
                    messagebox.showinfo("Connection Made", f"You're now in cahoots with '{responder_username}'!")
                    is_connected.set()
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_username):
    if not username:
        messagebox.showwarning("Oops!", "Please set your username first!")
        return
    if target_username == username:
        messagebox.showwarning("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    if target_username not in TARGET_USERS:
        messagebox.showerror("Whoops!", f"No one named '{target_username}' found in the vicinity.")
        logging.error(f"Attempted to connect to unknown username '{target_username}'.")
        return
    target_info = TARGET_USERS[target_username]
    target_ip = target_info['ip']
    target_port = target_info['port']
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"REQUEST_CONNECTION:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection giggle to '{target_username}' at {target_ip}:{target_port}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind(('', RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    response_message = data.decode('utf-8')
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        _, responder_username = response_message.split(':', 1)
                        TARGET_USERS[responder_username] = {'ip': target_ip, 'port': target_port, 'copy_count': 0}
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                        messagebox.showinfo("Connection Success", f"Now sharing vibes with '{responder_username}'!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                except socket.timeout:
                    logging.debug(f"No response from '{target_username}' at {target_ip}:{target_port}. Connection request timed out.")
                    messagebox.showerror("No Response", f"'{target_username}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection giggle: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to listen for username broadcasts
    threading.Thread(target=listen_for_usernames, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for user, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(user, info['ip'], info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Username and Port
    settings_frame = tk.Frame(root)
    settings_frame.pack(pady=10)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10))
    username_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30)
    username_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Username
    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            messagebox.showerror("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            messagebox.showwarning("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        if broadcast_username():
            messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
            # Disable the username entry and button after setting
            username_entry.config(state='disabled')
            set_username_button.config(state='disabled')
            # Display the username and local IP address at the top of the dashboard
            user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
            # Enable the Invite button if at least one connection is possible
            invite_button.config(state='normal')

    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=set_username)
    set_username_button.grid(row=0, column=2, padx=5, pady=5)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10))
    port_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30)
    port_entry.grid(row=1, column=1, padx=5, pady=5)
    port_info_label = tk.Label(settings_frame, text="Leave blank for automatic selection (5000-5050)", font=("Helvetica", 8), fg="gray")
    port_info_label.grid(row=2, column=0, columnspan=3, padx=5, pady=2)

    # Button to Set Port
    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        messagebox.showerror("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                messagebox.showerror("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                logging.debug(f"Automatically selected free port: {PORT}")
                messagebox.showinfo("Port Selected", f"Automatically selected free port: {PORT}")
            except Exception as e:
                messagebox.showerror("Port Error", str(e))
                return
        messagebox.showinfo("Port Set", f"Communication port set to {PORT}.")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Display the local IP address at the top of the dashboard
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Enable the Set Username button if not already set
        if username:
            invite_button.config(state='normal')

    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=set_port)
    set_port_button.grid(row=1, column=2, padx=5, pady=5)

    # Button to Auto-Set Port
    def auto_set_port():
        global PORT
        if PORT:
            messagebox.showinfo("Port Already Set", f"Communication port is already set to {PORT}.")
            return
        try:
            PORT = find_free_port()
            logging.debug(f"Automatically selected free port: {PORT}")
            messagebox.showinfo("Port Selected", f"Automatically selected free port: {PORT}")
            # Update port_entry field
            port_entry.insert(0, str(PORT))
            # Disable the port entry and button after setting
            port_entry.config(state='disabled')
            set_port_button.config(state='disabled')
            # Display the local IP address at the top of the dashboard
            ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
            # Enable the Set Username button if not already set
            if username:
                invite_button.config(state='normal')
        except Exception as e:
            messagebox.showerror("Port Error", str(e))

    # Optionally, you can add an "Auto-Set Port" button
    # auto_set_port_button = tk.Button(settings_frame, text="\U0001f680 Auto-Set Port", command=auto_set_port)
    # auto_set_port_button.grid(row=1, column=3, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"))
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled', command=lambda: send_connection_request(simpledialog.askstring("Send Invite", "Enter username to invite:")))
    invite_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...", font=("Helvetica", 10, "italic"))
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root)
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"))
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10)
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color)
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"))
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:00:45,627 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import simpledialog, messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_PORT = 5003  # Port for broadcasting usernames
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target usernames and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if a connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def broadcast_username():
    """Broadcast the username to the network to ensure uniqueness."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        message = f"USERNAME:{username}:{local_ip}:{PORT}"
        sock.sendto(message.encode('utf-8'), ('<broadcast>', USERNAME_PORT))
        logging.debug(f"Broadcasted username '{username}' to the network.")
        # Listen for a short period to check for duplicates
        sock.settimeout(2)
        try:
            while True:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_username == username and received_ip != local_ip:
                        logging.warning(f"Username '{username}' is already taken by {received_ip}:{received_port}.")
                        messagebox.showerror("Username Jam!", f"'{username}' is already taken by {received_ip}:{received_port}. Pick another one!")
                        return False
        except socket.timeout:
            pass  # No duplicates found
    return True

def listen_for_usernames():
    """Listen for username broadcasts to maintain the TARGET_USERS dictionary."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('', USERNAME_PORT))
        logging.debug(f"Listening for username broadcasts on port {USERNAME_PORT}...")
        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME:"):
                    _, received_username, received_ip, received_port = received_message.split(':', 3)
                    if received_ip == local_ip and int(received_port) == PORT:
                        continue  # Ignore own broadcasts
                    if received_username not in TARGET_USERS:
                        TARGET_USERS[received_username] = {'ip': received_ip, 'port': int(received_port), 'copy_count': 0}
                        logging.debug(f"Discovered user '{received_username}' at {received_ip}:{received_port}.")
                        # Assign color for the new user
                        if received_username not in user_colors:
                            user_colors[received_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
            except Exception as e:
                logging.error(f"Error receiving username broadcasts: {e}")

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{current_text}"
                    logging.debug(f"Broadcasting clipboard magic: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for user, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (info['ip'], info['port']))
        except Exception as e:
            # Print any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard sorcery: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard whispers on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_text = received_message.split(':', 1)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard snippet from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Injecting received clipboard magic into local clipboard...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated with: {received_text}")
                        # Update copy count
                        for user, info in TARGET_USERS.items():
                            if info['ip'] == addr[0] and info['port'] == addr[1]:
                                info['copy_count'] += 1
                                log_activity(user, f"Copied: {received_text}")
                                break
            except Exception as e:
                # Print any errors that occur during receiving
                logging.error(f"Error receiving clipboard snippets: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection giggles on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection giggle from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, target_username = received_message.split(':', 1)
                    # Prevent accepting connection from self
                    if target_username == username:
                        logging.warning(f"Received connection request from self at {addr[0]}:{addr[1]}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root = tk.Tk()
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Ping", f"Do you wanna vibe with '{target_username}' from {addr[0]}:{addr[1]}?")
                    if result:
                        TARGET_USERS[target_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                        logging.debug(f"Accepted connection from '{target_username}' at {addr[0]}:{addr[1]}")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation to the requesting IP
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            confirm_message = f"CONNECTION_ACCEPTED:{username}"
                            confirm_sock.sendto(confirm_message.encode('utf-8'), (addr[0], RESPONSE_PORT))
                        # Assign color for the new user
                        if target_username not in user_colors:
                            user_colors[target_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                    else:
                        logging.debug(f"Declined connection from '{target_username}' at {addr[0]}:{addr[1]}")
            except Exception as e:
                logging.error(f"Error handling connection giggle: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection acceptance on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    _, responder_username = received_message.split(':', 1)
                    # Find the IP and port based on the responder's address
                    for user, info in TARGET_USERS.items():
                        if info['ip'] == addr[0]:
                            break
                    else:
                        # If not found, add the user
                        TARGET_USERS[responder_username] = {'ip': addr[0], 'port': addr[1], 'copy_count': 0}
                    logging.debug(f"Connection confirmed with '{responder_username}' at {addr[0]}:{addr[1]}")
                    messagebox.showinfo("Connection Made", f"You're now in cahoots with '{responder_username}'!")
                    is_connected.set()
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_username):
    if not username:
        messagebox.showwarning("Oops!", "Please set your username first!")
        return
    if target_username == username:
        messagebox.showwarning("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    if target_username not in TARGET_USERS:
        messagebox.showerror("Whoops!", f"No one named '{target_username}' found in the vicinity.")
        logging.error(f"Attempted to connect to unknown username '{target_username}'.")
        return
    target_info = TARGET_USERS[target_username]
    target_ip = target_info['ip']
    target_port = target_info['port']
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"REQUEST_CONNECTION:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection giggle to '{target_username}' at {target_ip}:{target_port}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                response_sock.bind(('', RESPONSE_PORT))
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    data, _ = response_sock.recvfrom(1024)
                    response_message = data.decode('utf-8')
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        _, responder_username = response_message.split(':', 1)
                        TARGET_USERS[responder_username] = {'ip': target_ip, 'port': target_port, 'copy_count': 0}
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                        messagebox.showinfo("Connection Success", f"Now sharing vibes with '{responder_username}'!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                except socket.timeout:
                    logging.debug(f"No response from '{target_username}' at {target_ip}:{target_port}. Connection request timed out.")
                    messagebox.showerror("No Response", f"'{target_username}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection giggle: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to listen for username broadcasts
    threading.Thread(target=listen_for_usernames, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for user, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(user, info['ip'], info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Username and Port
    settings_frame = tk.Frame(root)
    settings_frame.pack(pady=10)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10))
    username_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30)
    username_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Username
    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            messagebox.showerror("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            messagebox.showwarning("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        if broadcast_username():
            messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
            # Disable the username entry and button after setting
            username_entry.config(state='disabled')
            set_username_button.config(state='disabled')
            # Display the username and local IP address at the top of the dashboard
            user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
            # Enable the Invite button if at least one connection is possible
            invite_button.config(state='normal')

    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=set_username)
    set_username_button.grid(row=0, column=2, padx=5, pady=5)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10))
    port_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30)
    port_entry.grid(row=1, column=1, padx=5, pady=5)
    port_info_label = tk.Label(settings_frame, text="Leave blank for automatic selection (5000-5050)", font=("Helvetica", 8), fg="gray")
    port_info_label.grid(row=2, column=0, columnspan=3, padx=5, pady=2)

    # Button to Set Port
    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        messagebox.showerror("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                messagebox.showerror("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                logging.debug(f"Automatically selected free port: {PORT}")
                messagebox.showinfo("Port Selected", f"Automatically selected free port: {PORT}")
            except Exception as e:
                messagebox.showerror("Port Error", str(e))
                return
        messagebox.showinfo("Port Set", f"Communication port set to {PORT}.")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Display the local IP address at the top of the dashboard
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Enable the Set Username button if not already set
        if username:
            invite_button.config(state='normal')

    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=set_port)
    set_port_button.grid(row=1, column=2, padx=5, pady=5)

    # Button to Auto-Set Port
    def auto_set_port():
        global PORT
        if PORT:
            messagebox.showinfo("Port Already Set", f"Communication port is already set to {PORT}.")
            return
        try:
            PORT = find_free_port()
            logging.debug(f"Automatically selected free port: {PORT}")
            messagebox.showinfo("Port Selected", f"Automatically selected free port: {PORT}")
            # Update port_entry field
            port_entry.insert(0, str(PORT))
            # Disable the port entry and button after setting
            port_entry.config(state='disabled')
            set_port_button.config(state='disabled')
            # Display the local IP address at the top of the dashboard
            ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
            # Enable the Set Username button if not already set
            if username:
                invite_button.config(state='normal')
        except Exception as e:
            messagebox.showerror("Port Error", str(e))

    # Optionally, you can add an "Auto-Set Port" button
    # auto_set_port_button = tk.Button(settings_frame, text="\U0001f680 Auto-Set Port", command=auto_set_port)
    # auto_set_port_button.grid(row=1, column=3, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"))
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled', command=lambda: send_connection_request(simpledialog.askstring("Send Invite", "Enter username to invite:")))
    invite_button.pack(pady=10)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...", font=("Helvetica", 10, "italic"))
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root)
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"))
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10)
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color)
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"))
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)
    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:00:55,995 - DEBUG - Broadcasting clipboard content: 
2024-11-05 15:00:56,866 - DEBUG - Broadcasting clipboard content: 
2024-11-05 15:00:56,994 - DEBUG - Broadcasting clipboard content: 
2024-11-05 15:00:57,109 - DEBUG - Broadcasting clipboard content: 
2024-11-05 15:01:46,805 - DEBUG - Broadcasting clipboard content: LANCZOS
2024-11-05 15:01:46,956 - DEBUG - Broadcasting clipboard content: LANCZOS
2024-11-05 15:01:47,370 - DEBUG - Broadcasting clipboard content: LANCZOS
2024-11-05 15:01:47,764 - DEBUG - Broadcasting clipboard content: LANCZOS
2024-11-05 15:01:51,738 - DEBUG - Broadcasting clipboard content: Image.LANCZOS
2024-11-05 15:01:51,956 - DEBUG - Broadcasting clipboard content: Image.LANCZOS
2024-11-05 15:01:52,752 - DEBUG - Broadcasting clipboard content: Image.LANCZOS
2024-11-05 15:01:52,891 - DEBUG - Broadcasting clipboard content: Image.LANCZOS
2024-11-05 15:05:28,328 - DEBUG - Broadcasting clipboard content: field
2024-11-05 15:05:28,598 - DEBUG - Broadcasting clipboard content: field
2024-11-05 15:05:28,648 - DEBUG - Broadcasting clipboard content: field
2024-11-05 15:05:28,792 - DEBUG - Broadcasting clipboard content: field
2024-11-05 15:06:57,967 - DEBUG - Broadcasting clipboard content: Image.ANTIALIAS
2024-11-05 15:06:57,968 - DEBUG - Broadcasting clipboard content: Image.ANTIALIAS
2024-11-05 15:06:58,014 - DEBUG - Broadcasting clipboard content: Image.ANTIALIAS
2024-11-05 15:06:58,249 - DEBUG - Broadcasting clipboard content: Image.ANTIALIAS
2024-11-05 15:07:14,519 - DEBUG - Broadcasting clipboard content: Image.LANCZOS
2024-11-05 15:07:14,833 - DEBUG - Broadcasting clipboard content: Image.LANCZOS
2024-11-05 15:07:15,361 - DEBUG - Broadcasting clipboard content: Image.LANCZOS
2024-11-05 15:07:15,676 - DEBUG - Broadcasting clipboard content: Image.LANCZOS
2024-11-05 15:07:30,973 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, info['port']))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, target_port = received_message.split(':', 1)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and int(target_port) == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{target_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request", f"Do you want to connect with {addr[0]}:{target_port}?")
                    if result:
                        # Receive the username from the connecting user
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.settimeout(5)
                            try:
                                confirm_message, _ = confirm_sock.recvfrom(1024)
                                received_username = confirm_message.decode('utf-8')
                            except socket.timeout:
                                received_username = "Unknown"
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': int(target_port), 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{target_port} as '{received_username}'")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation along with own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.sendto(username.encode('utf-8'), addr)
                        # Assign color for the new user
                        if received_username not in user_colors:
                            user_colors[received_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Show information in logs
                        log_activity(received_username, f"Connected from {addr[0]}:{target_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{target_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_username = data.decode('utf-8')
                # Add the user to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {addr[0]}:{PORT} as '{received_username}'")
                messagebox.showinfo("Connection Made", f"You're now connected with '{received_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if received_username not in user_colors:
                    user_colors[received_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(received_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        messagebox.showwarning("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        messagebox.showwarning("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{target_port}")
            # Send own username to the target
            sock.sendto(username.encode('utf-8'), (target_ip, target_port))
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the user to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success", f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from {target_ip}:{target_port}. Connection request timed out.")
                    messagebox.showerror("No Response", f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            messagebox.showerror("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        # Find the username associated with the IP
        username_display = "Unknown"
        for name, color in user_colors.items():
            if color == user_colors.get(name):
                username_display = name
                break
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root)
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10))
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30)
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        messagebox.showerror("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                messagebox.showerror("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                logging.debug(f"Automatically selected free port: {PORT}")
                messagebox.showinfo("Port Selected", f"Automatically selected free port: {PORT}")
                port_entry.insert(0, str(PORT))
            except Exception as e:
                messagebox.showerror("Port Error", str(e))
                return
        messagebox.showinfo("Port Set", f"Communication port set to {PORT}.")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Display the local IP address at the top of the dashboard
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Enable the Set Username button if not already set
        if username:
            set_username_button.config(state='normal')

    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=set_port)
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10))
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30)
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            messagebox.showerror("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            messagebox.showwarning("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        if broadcast_username():
            messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
            # Disable the username entry and button after setting
            username_entry.config(state='disabled')
            set_username_button.config(state='disabled')
            # Display the username and local IP address at the top of the dashboard
            user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
            # Enable the Invite button
            invite_button.config(state='normal')

    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=set_username)
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"))
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled', command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP and Port
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10))
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30)
        target_ip_entry.pack(pady=5)

        # Port Entry
        target_port_label = tk.Label(invite_window, text="\U0001f527 Target Port:", font=("Helvetica", 10))
        target_port_label.pack(pady=10)
        target_port_entry = tk.Entry(invite_window, width=30)
        target_port_entry.pack(pady=5)

        # Button to Send Connection Request
        def send_request():
            target_ip = target_ip_entry.get().strip()
            target_port = target_port_entry.get().strip()
            if not target_ip or not target_port:
                messagebox.showerror("Incomplete Information", "Please enter both IP address and Port.")
                return
            try:
                target_port = int(target_port)
                if target_port < 1 or target_port > 65535:
                    raise ValueError
            except ValueError:
                messagebox.showerror("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
            # Send the connection request
            invite_window.destroy()
            send_connection_request(target_ip, target_port)

        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite", command=send_request)
        send_button.pack(pady=20)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...", font=("Helvetica", 10, "italic"))
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root)
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"))
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10)
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color)
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"))
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

def log_activity(user, message):
    """Logs activity with colored usernames."""
    log_text.config(state='normal')
    if user in user_colors:
        color = user_colors[user]
    else:
        color = get_next_color()
        user_colors[user] = color
    log_text.tag_config(user, foreground=color)
    log_entry = f"{user}: {message}\n"
    log_text.insert(tk.END, log_entry, user)
    log_text.config(state='disabled')
    log_text.yview(tk.END)

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:07:31,568 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, info['port']))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, target_port = received_message.split(':', 1)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and int(target_port) == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{target_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request", f"Do you want to connect with {addr[0]}:{target_port}?")
                    if result:
                        # Receive the username from the connecting user
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.settimeout(5)
                            try:
                                confirm_message, _ = confirm_sock.recvfrom(1024)
                                received_username = confirm_message.decode('utf-8')
                            except socket.timeout:
                                received_username = "Unknown"
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': int(target_port), 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{target_port} as '{received_username}'")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation along with own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.sendto(username.encode('utf-8'), addr)
                        # Assign color for the new user
                        if received_username not in user_colors:
                            user_colors[received_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Show information in logs
                        log_activity(received_username, f"Connected from {addr[0]}:{target_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{target_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_username = data.decode('utf-8')
                # Add the user to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {addr[0]}:{PORT} as '{received_username}'")
                messagebox.showinfo("Connection Made", f"You're now connected with '{received_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if received_username not in user_colors:
                    user_colors[received_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(received_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        messagebox.showwarning("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        messagebox.showwarning("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{target_port}")
            # Send own username to the target
            sock.sendto(username.encode('utf-8'), (target_ip, target_port))
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the user to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success", f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from {target_ip}:{target_port}. Connection request timed out.")
                    messagebox.showerror("No Response", f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            messagebox.showerror("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        # Find the username associated with the IP
        username_display = "Unknown"
        for name, color in user_colors.items():
            if color == user_colors.get(name):
                username_display = name
                break
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root)
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10))
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30)
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        messagebox.showerror("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                messagebox.showerror("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                logging.debug(f"Automatically selected free port: {PORT}")
                messagebox.showinfo("Port Selected", f"Automatically selected free port: {PORT}")
                port_entry.insert(0, str(PORT))
            except Exception as e:
                messagebox.showerror("Port Error", str(e))
                return
        messagebox.showinfo("Port Set", f"Communication port set to {PORT}.")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Display the local IP address at the top of the dashboard
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Enable the Set Username button if not already set
        if username:
            set_username_button.config(state='normal')

    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=set_port)
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10))
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30)
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            messagebox.showerror("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            messagebox.showwarning("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        if broadcast_username():
            messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
            # Disable the username entry and button after setting
            username_entry.config(state='disabled')
            set_username_button.config(state='disabled')
            # Display the username and local IP address at the top of the dashboard
            user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
            # Enable the Invite button
            invite_button.config(state='normal')

    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=set_username)
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"))
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled', command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP and Port
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10))
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30)
        target_ip_entry.pack(pady=5)

        # Port Entry
        target_port_label = tk.Label(invite_window, text="\U0001f527 Target Port:", font=("Helvetica", 10))
        target_port_label.pack(pady=10)
        target_port_entry = tk.Entry(invite_window, width=30)
        target_port_entry.pack(pady=5)

        # Button to Send Connection Request
        def send_request():
            target_ip = target_ip_entry.get().strip()
            target_port = target_port_entry.get().strip()
            if not target_ip or not target_port:
                messagebox.showerror("Incomplete Information", "Please enter both IP address and Port.")
                return
            try:
                target_port = int(target_port)
                if target_port < 1 or target_port > 65535:
                    raise ValueError
            except ValueError:
                messagebox.showerror("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
            # Send the connection request
            invite_window.destroy()
            send_connection_request(target_ip, target_port)

        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite", command=send_request)
        send_button.pack(pady=20)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...", font=("Helvetica", 10, "italic"))
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root)
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"))
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10)
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color)
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"))
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

def log_activity(user, message):
    """Logs activity with colored usernames."""
    log_text.config(state='normal')
    if user in user_colors:
        color = user_colors[user]
    else:
        color = get_next_color()
        user_colors[user] = color
    log_text.tag_config(user, foreground=color)
    log_entry = f"{user}: {message}\n"
    log_text.insert(tk.END, log_entry, user)
    log_text.config(state='disabled')
    log_text.yview(tk.END)

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:07:31,765 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, info['port']))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, target_port = received_message.split(':', 1)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and int(target_port) == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{target_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request", f"Do you want to connect with {addr[0]}:{target_port}?")
                    if result:
                        # Receive the username from the connecting user
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.settimeout(5)
                            try:
                                confirm_message, _ = confirm_sock.recvfrom(1024)
                                received_username = confirm_message.decode('utf-8')
                            except socket.timeout:
                                received_username = "Unknown"
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': int(target_port), 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{target_port} as '{received_username}'")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation along with own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.sendto(username.encode('utf-8'), addr)
                        # Assign color for the new user
                        if received_username not in user_colors:
                            user_colors[received_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Show information in logs
                        log_activity(received_username, f"Connected from {addr[0]}:{target_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{target_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_username = data.decode('utf-8')
                # Add the user to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {addr[0]}:{PORT} as '{received_username}'")
                messagebox.showinfo("Connection Made", f"You're now connected with '{received_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if received_username not in user_colors:
                    user_colors[received_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(received_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        messagebox.showwarning("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        messagebox.showwarning("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{target_port}")
            # Send own username to the target
            sock.sendto(username.encode('utf-8'), (target_ip, target_port))
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the user to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success", f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from {target_ip}:{target_port}. Connection request timed out.")
                    messagebox.showerror("No Response", f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            messagebox.showerror("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        # Find the username associated with the IP
        username_display = "Unknown"
        for name, color in user_colors.items():
            if color == user_colors.get(name):
                username_display = name
                break
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root)
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10))
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30)
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        messagebox.showerror("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                messagebox.showerror("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                logging.debug(f"Automatically selected free port: {PORT}")
                messagebox.showinfo("Port Selected", f"Automatically selected free port: {PORT}")
                port_entry.insert(0, str(PORT))
            except Exception as e:
                messagebox.showerror("Port Error", str(e))
                return
        messagebox.showinfo("Port Set", f"Communication port set to {PORT}.")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Display the local IP address at the top of the dashboard
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Enable the Set Username button if not already set
        if username:
            set_username_button.config(state='normal')

    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=set_port)
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10))
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30)
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            messagebox.showerror("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            messagebox.showwarning("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        if broadcast_username():
            messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
            # Disable the username entry and button after setting
            username_entry.config(state='disabled')
            set_username_button.config(state='disabled')
            # Display the username and local IP address at the top of the dashboard
            user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
            # Enable the Invite button
            invite_button.config(state='normal')

    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=set_username)
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"))
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled', command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP and Port
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10))
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30)
        target_ip_entry.pack(pady=5)

        # Port Entry
        target_port_label = tk.Label(invite_window, text="\U0001f527 Target Port:", font=("Helvetica", 10))
        target_port_label.pack(pady=10)
        target_port_entry = tk.Entry(invite_window, width=30)
        target_port_entry.pack(pady=5)

        # Button to Send Connection Request
        def send_request():
            target_ip = target_ip_entry.get().strip()
            target_port = target_port_entry.get().strip()
            if not target_ip or not target_port:
                messagebox.showerror("Incomplete Information", "Please enter both IP address and Port.")
                return
            try:
                target_port = int(target_port)
                if target_port < 1 or target_port > 65535:
                    raise ValueError
            except ValueError:
                messagebox.showerror("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
            # Send the connection request
            invite_window.destroy()
            send_connection_request(target_ip, target_port)

        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite", command=send_request)
        send_button.pack(pady=20)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...", font=("Helvetica", 10, "italic"))
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root)
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"))
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10)
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color)
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"))
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

def log_activity(user, message):
    """Logs activity with colored usernames."""
    log_text.config(state='normal')
    if user in user_colors:
        color = user_colors[user]
    else:
        color = get_next_color()
        user_colors[user] = color
    log_text.tag_config(user, foreground=color)
    log_entry = f"{user}: {message}\n"
    log_text.insert(tk.END, log_entry, user)
    log_text.config(state='disabled')
    log_text.yview(tk.END)

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:07:32,145 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, info['port']))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, target_port = received_message.split(':', 1)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and int(target_port) == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{target_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request", f"Do you want to connect with {addr[0]}:{target_port}?")
                    if result:
                        # Receive the username from the connecting user
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.settimeout(5)
                            try:
                                confirm_message, _ = confirm_sock.recvfrom(1024)
                                received_username = confirm_message.decode('utf-8')
                            except socket.timeout:
                                received_username = "Unknown"
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': int(target_port), 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{target_port} as '{received_username}'")
                        is_connected.set()  # Set connection established flag
                        # Send confirmation along with own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as confirm_sock:
                            confirm_sock.sendto(username.encode('utf-8'), addr)
                        # Assign color for the new user
                        if received_username not in user_colors:
                            user_colors[received_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Show information in logs
                        log_activity(received_username, f"Connected from {addr[0]}:{target_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{target_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_username = data.decode('utf-8')
                # Add the user to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {addr[0]}:{PORT} as '{received_username}'")
                messagebox.showinfo("Connection Made", f"You're now connected with '{received_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if received_username not in user_colors:
                    user_colors[received_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(received_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        messagebox.showwarning("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        messagebox.showwarning("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{target_port}")
            # Send own username to the target
            sock.sendto(username.encode('utf-8'), (target_ip, target_port))
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the user to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success", f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from {target_ip}:{target_port}. Connection request timed out.")
                    messagebox.showerror("No Response", f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            messagebox.showerror("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        # Find the username associated with the IP
        username_display = "Unknown"
        for name, color in user_colors.items():
            if color == user_colors.get(name):
                username_display = name
                break
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.ANTIALIAS)
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo)
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root)
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10))
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30)
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        messagebox.showerror("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                messagebox.showerror("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                logging.debug(f"Automatically selected free port: {PORT}")
                messagebox.showinfo("Port Selected", f"Automatically selected free port: {PORT}")
                port_entry.insert(0, str(PORT))
            except Exception as e:
                messagebox.showerror("Port Error", str(e))
                return
        messagebox.showinfo("Port Set", f"Communication port set to {PORT}.")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Display the local IP address at the top of the dashboard
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Enable the Set Username button if not already set
        if username:
            set_username_button.config(state='normal')

    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=set_port)
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10))
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30)
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            messagebox.showerror("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            messagebox.showwarning("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        if broadcast_username():
            messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
            # Disable the username entry and button after setting
            username_entry.config(state='disabled')
            set_username_button.config(state='disabled')
            # Display the username and local IP address at the top of the dashboard
            user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
            # Enable the Invite button
            invite_button.config(state='normal')

    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=set_username)
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"))
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"))
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled', command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP and Port
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10))
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30)
        target_ip_entry.pack(pady=5)

        # Port Entry
        target_port_label = tk.Label(invite_window, text="\U0001f527 Target Port:", font=("Helvetica", 10))
        target_port_label.pack(pady=10)
        target_port_entry = tk.Entry(invite_window, width=30)
        target_port_entry.pack(pady=5)

        # Button to Send Connection Request
        def send_request():
            target_ip = target_ip_entry.get().strip()
            target_port = target_port_entry.get().strip()
            if not target_ip or not target_port:
                messagebox.showerror("Incomplete Information", "Please enter both IP address and Port.")
                return
            try:
                target_port = int(target_port)
                if target_port < 1 or target_port > 65535:
                    raise ValueError
            except ValueError:
                messagebox.showerror("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
            # Send the connection request
            invite_window.destroy()
            send_connection_request(target_ip, target_port)

        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite", command=send_request)
        send_button.pack(pady=20)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...", font=("Helvetica", 10, "italic"))
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root)
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"))
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10)
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color)
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"))
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

def log_activity(user, message):
    """Logs activity with colored usernames."""
    log_text.config(state='normal')
    if user in user_colors:
        color = user_colors[user]
    else:
        color = get_next_color()
        user_colors[user] = color
    log_text.tag_config(user, foreground=color)
    log_entry = f"{user}: {message}\n"
    log_text.insert(tk.END, log_entry, user)
    log_text.config(state='disabled')
    log_text.yview(tk.END)

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:09:42,748 - DEBUG - Received clipboard content from network: md:px-0 lg:px-4
2024-11-05 15:09:42,748 - DEBUG - Updating local clipboard with received content...
2024-11-05 15:09:42,757 - DEBUG - Broadcasting clipboard content: md:px-0 lg:px-4
2024-11-05 15:09:42,757 - DEBUG - Clipboard updated from network: md:px-0 lg:px-4
2024-11-05 15:09:43,022 - DEBUG - Broadcasting clipboard content: md:px-0 lg:px-4
2024-11-05 15:09:43,526 - DEBUG - Broadcasting clipboard content: md:px-0 lg:px-4
2024-11-05 15:10:28,187 - DEBUG - Broadcasting clipboard content: #ff4a38
2024-11-05 15:10:28,754 - DEBUG - Broadcasting clipboard content: #ff4a38
2024-11-05 15:10:29,115 - DEBUG - Broadcasting clipboard content: #ff4a38
2024-11-05 15:10:29,202 - DEBUG - Broadcasting clipboard content: #ff4a38
2024-11-05 15:10:51,195 - DEBUG - Broadcasting clipboard content: #000000
2024-11-05 15:10:51,508 - DEBUG - Broadcasting clipboard content: #000000
2024-11-05 15:10:52,472 - DEBUG - Broadcasting clipboard content: #000000
2024-11-05 15:10:52,692 - DEBUG - Broadcasting clipboard content: #000000
2024-11-05 15:12:12,532 - DEBUG - Broadcasting clipboard content: #70a9c8
2024-11-05 15:12:12,935 - DEBUG - Broadcasting clipboard content: #70a9c8
2024-11-05 15:12:12,987 - DEBUG - Broadcasting clipboard content: #70a9c8
2024-11-05 15:12:13,620 - DEBUG - Broadcasting clipboard content: #70a9c8
2024-11-05 15:13:06,319 - DEBUG - Broadcasting clipboard content: #d9534f
2024-11-05 15:13:06,459 - DEBUG - Broadcasting clipboard content: #d9534f
2024-11-05 15:13:06,852 - DEBUG - Broadcasting clipboard content: #d9534f
2024-11-05 15:13:07,815 - DEBUG - Broadcasting clipboard content: #d9534f
2024-11-05 15:14:00,135 - DEBUG - Broadcasting clipboard content: #269144
2024-11-05 15:14:00,270 - DEBUG - Broadcasting clipboard content: #269144
2024-11-05 15:14:00,394 - DEBUG - Broadcasting clipboard content: #269144
2024-11-05 15:14:01,218 - DEBUG - Broadcasting clipboard content: #269144
2024-11-05 15:15:54,947 - DEBUG - Received clipboard content from network: h-[600px] md:h-[500px] lg:h-[600px]
2024-11-05 15:15:54,948 - DEBUG - Updating local clipboard with received content...
2024-11-05 15:15:54,954 - DEBUG - Clipboard updated from network: h-[600px] md:h-[500px] lg:h-[600px]
2024-11-05 15:15:55,047 - DEBUG - Broadcasting clipboard content: h-[600px] md:h-[500px] lg:h-[600px]
2024-11-05 15:15:55,497 - DEBUG - Broadcasting clipboard content: h-[600px] md:h-[500px] lg:h-[600px]
2024-11-05 15:15:56,348 - DEBUG - Broadcasting clipboard content: h-[600px] md:h-[500px] lg:h-[600px]
2024-11-05 15:16:08,388 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, REQUEST_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_sock.sendto(username.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected from {addr[0]}:{sender_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                responder_username = data.decode('utf-8')
                # Add the responder to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {responder_username} at {addr[0]}:{PORT}")
                messagebox.showinfo("Connection Made",
                                    f"You're now connected with '{responder_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if responder_username not in user_colors:
                    user_colors[responder_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")
    root.configure(bg="#70a9c8")  # Set body color

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=lambda: set_port(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=lambda: set_username(),
                                    bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                    bd=2, relief='solid', highlightbackground="#269144")
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled',
                              command=lambda: invite_buddy(),
                              bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                              bd=2, relief='solid', highlightbackground="#269144")
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)

        # Button to Send Connection Request
        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite",
                                command=lambda: send_request(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause,
                             bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                             bd=2, relief='solid', highlightbackground="#269144")
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            custom_error_popup("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        # Send username to connected users (if any)
        # No username broadcasting is required since connections are IP-based
        messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
        # Disable the username entry and button after setting
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:16:08,434 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, REQUEST_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_sock.sendto(username.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected from {addr[0]}:{sender_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                responder_username = data.decode('utf-8')
                # Add the responder to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {responder_username} at {addr[0]}:{PORT}")
                messagebox.showinfo("Connection Made",
                                    f"You're now connected with '{responder_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if responder_username not in user_colors:
                    user_colors[responder_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")
    root.configure(bg="#70a9c8")  # Set body color

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=lambda: set_port(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=lambda: set_username(),
                                    bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                    bd=2, relief='solid', highlightbackground="#269144")
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled',
                              command=lambda: invite_buddy(),
                              bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                              bd=2, relief='solid', highlightbackground="#269144")
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)

        # Button to Send Connection Request
        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite",
                                command=lambda: send_request(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause,
                             bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                             bd=2, relief='solid', highlightbackground="#269144")
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            custom_error_popup("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        # Send username to connected users (if any)
        # No username broadcasting is required since connections are IP-based
        messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
        # Disable the username entry and button after setting
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:16:08,834 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, REQUEST_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_sock.sendto(username.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected from {addr[0]}:{sender_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                responder_username = data.decode('utf-8')
                # Add the responder to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {responder_username} at {addr[0]}:{PORT}")
                messagebox.showinfo("Connection Made",
                                    f"You're now connected with '{responder_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if responder_username not in user_colors:
                    user_colors[responder_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")
    root.configure(bg="#70a9c8")  # Set body color

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=lambda: set_port(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=lambda: set_username(),
                                    bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                    bd=2, relief='solid', highlightbackground="#269144")
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled',
                              command=lambda: invite_buddy(),
                              bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                              bd=2, relief='solid', highlightbackground="#269144")
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)

        # Button to Send Connection Request
        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite",
                                command=lambda: send_request(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause,
                             bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                             bd=2, relief='solid', highlightbackground="#269144")
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            custom_error_popup("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        # Send username to connected users (if any)
        # No username broadcasting is required since connections are IP-based
        messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
        # Disable the username entry and button after setting
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:16:09,106 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, REQUEST_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_sock.sendto(username.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected from {addr[0]}:{sender_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                responder_username = data.decode('utf-8')
                # Add the responder to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {responder_username} at {addr[0]}:{PORT}")
                messagebox.showinfo("Connection Made",
                                    f"You're now connected with '{responder_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if responder_username not in user_colors:
                    user_colors[responder_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")
    root.configure(bg="#70a9c8")  # Set body color

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=lambda: set_port(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=lambda: set_username(),
                                    bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                    bd=2, relief='solid', highlightbackground="#269144")
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled',
                              command=lambda: invite_buddy(),
                              bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                              bd=2, relief='solid', highlightbackground="#269144")
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)

        # Button to Send Connection Request
        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite",
                                command=lambda: send_request(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause,
                             bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                             bd=2, relief='solid', highlightbackground="#269144")
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            custom_error_popup("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        # Send username to connected users (if any)
        # No username broadcasting is required since connections are IP-based
        messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
        # Disable the username entry and button after setting
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:16:50,014 - DEBUG - Broadcasting clipboard content: #269144
2024-11-05 15:16:50,093 - DEBUG - Broadcasting clipboard content: #269144
2024-11-05 15:16:50,333 - DEBUG - Broadcasting clipboard content: #269144
2024-11-05 15:16:51,563 - DEBUG - Broadcasting clipboard content: #269144
2024-11-05 15:19:10,221 - DEBUG - Received connection request message from 192.168.1.16: REQUEST_CONNECTION:5000
2024-11-05 15:20:18,181 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, REQUEST_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_sock.sendto(username.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected from {addr[0]}:{sender_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                responder_username = data.decode('utf-8')
                # Add the responder to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {responder_username} at {addr[0]}:{PORT}")
                messagebox.showinfo("Connection Made",
                                    f"You're now connected with '{responder_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if responder_username not in user_colors:
                    user_colors[responder_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")
    root.configure(bg="#70a9c8")  # Set body color

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=lambda: set_port(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=lambda: set_username(),
                                    bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                    bd=2, relief='solid', highlightbackground="#269144")
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled',
                              command=lambda: invite_buddy(),
                              bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                              bd=2, relief='solid', highlightbackground="#269144")
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)

        # Button to Send Connection Request
        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite",
                                command=lambda: send_request(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause,
                             bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                             bd=2, relief='solid', highlightbackground="#269144")
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            custom_error_popup("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        # Send username to connected users (if any)
        # No username broadcasting is required since connections are IP-based
        messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
        # Disable the username entry and button after setting
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:20:18,487 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, REQUEST_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_sock.sendto(username.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected from {addr[0]}:{sender_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                responder_username = data.decode('utf-8')
                # Add the responder to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {responder_username} at {addr[0]}:{PORT}")
                messagebox.showinfo("Connection Made",
                                    f"You're now connected with '{responder_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if responder_username not in user_colors:
                    user_colors[responder_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")
    root.configure(bg="#70a9c8")  # Set body color

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=lambda: set_port(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=lambda: set_username(),
                                    bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                    bd=2, relief='solid', highlightbackground="#269144")
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled',
                              command=lambda: invite_buddy(),
                              bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                              bd=2, relief='solid', highlightbackground="#269144")
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)

        # Button to Send Connection Request
        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite",
                                command=lambda: send_request(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause,
                             bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                             bd=2, relief='solid', highlightbackground="#269144")
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            custom_error_popup("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        # Send username to connected users (if any)
        # No username broadcasting is required since connections are IP-based
        messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
        # Disable the username entry and button after setting
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:20:18,696 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, REQUEST_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_sock.sendto(username.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected from {addr[0]}:{sender_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                responder_username = data.decode('utf-8')
                # Add the responder to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {responder_username} at {addr[0]}:{PORT}")
                messagebox.showinfo("Connection Made",
                                    f"You're now connected with '{responder_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if responder_username not in user_colors:
                    user_colors[responder_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")
    root.configure(bg="#70a9c8")  # Set body color

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=lambda: set_port(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=lambda: set_username(),
                                    bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                    bd=2, relief='solid', highlightbackground="#269144")
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled',
                              command=lambda: invite_buddy(),
                              bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                              bd=2, relief='solid', highlightbackground="#269144")
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)

        # Button to Send Connection Request
        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite",
                                command=lambda: send_request(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause,
                             bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                             bd=2, relief='solid', highlightbackground="#269144")
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            custom_error_popup("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        # Send username to connected users (if any)
        # No username broadcasting is required since connections are IP-based
        messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
        # Disable the username entry and button after setting
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:20:19,112 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, REQUEST_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_sock.sendto(username.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected from {addr[0]}:{sender_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                responder_username = data.decode('utf-8')
                # Add the responder to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {responder_username} at {addr[0]}:{PORT}")
                messagebox.showinfo("Connection Made",
                                    f"You're now connected with '{responder_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if responder_username not in user_colors:
                    user_colors[responder_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")
    root.configure(bg="#70a9c8")  # Set body color

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=lambda: set_port(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=lambda: set_username(),
                                    bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                    bd=2, relief='solid', highlightbackground="#269144")
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled',
                              command=lambda: invite_buddy(),
                              bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                              bd=2, relief='solid', highlightbackground="#269144")
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)

        # Button to Send Connection Request
        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite",
                                command=lambda: send_request(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause,
                             bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                             bd=2, relief='solid', highlightbackground="#269144")
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            custom_error_popup("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        # Send username to connected users (if any)
        # No username broadcasting is required since connections are IP-based
        messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
        # Disable the username entry and button after setting
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:20:25,058 - DEBUG - Broadcasting clipboard content: 
2024-11-05 15:20:25,211 - DEBUG - Broadcasting clipboard content: 
2024-11-05 15:20:25,800 - DEBUG - Broadcasting clipboard content: 
2024-11-05 15:20:25,850 - DEBUG - Broadcasting clipboard content: 
2024-11-05 15:23:22,695 - DEBUG - Broadcasting clipboard content: use enter to press button and all buttons are rounded by 16px or any unit you use 

2024-11-05 15:23:22,885 - DEBUG - Broadcasting clipboard content: use enter to press button and all buttons are rounded by 16px or any unit you use 

2024-11-05 15:23:23,405 - DEBUG - Broadcasting clipboard content: use enter to press button and all buttons are rounded by 16px or any unit you use 

2024-11-05 15:23:24,030 - DEBUG - Broadcasting clipboard content: use enter to press button and all buttons are rounded by 16px or any unit you use 

2024-11-05 15:23:29,168 - DEBUG - Broadcasting clipboard content: button border color is still black use this #269144

2024-11-05 15:23:29,354 - DEBUG - Broadcasting clipboard content: button border color is still black use this #269144

2024-11-05 15:23:29,376 - DEBUG - Broadcasting clipboard content: button border color is still black use this #269144

2024-11-05 15:23:30,091 - DEBUG - Broadcasting clipboard content: button border color is still black use this #269144

2024-11-05 15:24:17,255 - DEBUG - Broadcasting clipboard content: 
2024-11-05 15:24:19,001 - DEBUG - Broadcasting clipboard content: button border color is still black use this #269144

2024-11-05 15:25:51,277 - DEBUG - Broadcasting clipboard content: specific
2024-11-05 15:25:52,039 - DEBUG - Broadcasting clipboard content: specific
2024-11-05 15:25:52,354 - DEBUG - Broadcasting clipboard content: specific
2024-11-05 15:25:52,441 - DEBUG - Broadcasting clipboard content: specific
2024-11-05 15:26:32,565 - DEBUG - Broadcasting clipboard content: 1. cant varify of the other person has accepting the request like no connection is being made still its selding a connection request.

2. cant detect if the request is send to yourself

3. button border color is still black use this #269144

4. use enter to press button and all buttons are rounded by 16px or any unit you use 

5. use a list of funny usernames if none sets username by themselfs (let the set username be active so they can change at anytime and when they change the username send a packet showing the new username of the specific person and the other person to show the new username)


2024-11-05 15:26:32,970 - DEBUG - Broadcasting clipboard content: 1. cant varify of the other person has accepting the request like no connection is being made still its selding a connection request.

2. cant detect if the request is send to yourself

3. button border color is still black use this #269144

4. use enter to press button and all buttons are rounded by 16px or any unit you use 

5. use a list of funny usernames if none sets username by themselfs (let the set username be active so they can change at anytime and when they change the username send a packet showing the new username of the specific person and the other person to show the new username)


2024-11-05 15:26:33,170 - DEBUG - Broadcasting clipboard content: 1. cant varify of the other person has accepting the request like no connection is being made still its selding a connection request.

2. cant detect if the request is send to yourself

3. button border color is still black use this #269144

4. use enter to press button and all buttons are rounded by 16px or any unit you use 

5. use a list of funny usernames if none sets username by themselfs (let the set username be active so they can change at anytime and when they change the username send a packet showing the new username of the specific person and the other person to show the new username)


2024-11-05 15:26:33,282 - DEBUG - Broadcasting clipboard content: 1. cant varify of the other person has accepting the request like no connection is being made still its selding a connection request.

2. cant detect if the request is send to yourself

3. button border color is still black use this #269144

4. use enter to press button and all buttons are rounded by 16px or any unit you use 

5. use a list of funny usernames if none sets username by themselfs (let the set username be active so they can change at anytime and when they change the username send a packet showing the new username of the specific person and the other person to show the new username)


2024-11-05 15:26:45,750 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, REQUEST_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_sock.sendto(username.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected from {addr[0]}:{sender_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                responder_username = data.decode('utf-8')
                # Add the responder to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {responder_username} at {addr[0]}:{PORT}")
                messagebox.showinfo("Connection Made",
                                    f"You're now connected with '{responder_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if responder_username not in user_colors:
                    user_colors[responder_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")
    root.configure(bg="#70a9c8")  # Set body color

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=lambda: set_port(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=lambda: set_username(),
                                    bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                    bd=2, relief='solid', highlightbackground="#269144")
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled',
                              command=lambda: invite_buddy(),
                              bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                              bd=2, relief='solid', highlightbackground="#269144")
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)

        # Button to Send Connection Request
        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite",
                                command=lambda: send_request(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause,
                             bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                             bd=2, relief='solid', highlightbackground="#269144")
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            custom_error_popup("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        # Send username to connected users (if any)
        # No username broadcasting is required since connections are IP-based
        messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
        # Disable the username entry and button after setting
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:26:45,980 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, REQUEST_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_sock.sendto(username.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected from {addr[0]}:{sender_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                responder_username = data.decode('utf-8')
                # Add the responder to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {responder_username} at {addr[0]}:{PORT}")
                messagebox.showinfo("Connection Made",
                                    f"You're now connected with '{responder_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if responder_username not in user_colors:
                    user_colors[responder_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")
    root.configure(bg="#70a9c8")  # Set body color

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=lambda: set_port(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=lambda: set_username(),
                                    bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                    bd=2, relief='solid', highlightbackground="#269144")
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled',
                              command=lambda: invite_buddy(),
                              bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                              bd=2, relief='solid', highlightbackground="#269144")
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)

        # Button to Send Connection Request
        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite",
                                command=lambda: send_request(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause,
                             bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                             bd=2, relief='solid', highlightbackground="#269144")
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            custom_error_popup("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        # Send username to connected users (if any)
        # No username broadcasting is required since connections are IP-based
        messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
        # Disable the username entry and button after setting
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:26:46,186 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, REQUEST_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_sock.sendto(username.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected from {addr[0]}:{sender_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                responder_username = data.decode('utf-8')
                # Add the responder to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {responder_username} at {addr[0]}:{PORT}")
                messagebox.showinfo("Connection Made",
                                    f"You're now connected with '{responder_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if responder_username not in user_colors:
                    user_colors[responder_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")
    root.configure(bg="#70a9c8")  # Set body color

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=lambda: set_port(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=lambda: set_username(),
                                    bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                    bd=2, relief='solid', highlightbackground="#269144")
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled',
                              command=lambda: invite_buddy(),
                              bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                              bd=2, relief='solid', highlightbackground="#269144")
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)

        # Button to Send Connection Request
        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite",
                                command=lambda: send_request(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause,
                             bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                             bd=2, relief='solid', highlightbackground="#269144")
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            custom_error_popup("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        # Send username to connected users (if any)
        # No username broadcasting is required since connections are IP-based
        messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
        # Disable the username entry and button after setting
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:26:46,442 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, REQUEST_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_sock.sendto(username.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected from {addr[0]}:{sender_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                responder_username = data.decode('utf-8')
                # Add the responder to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {responder_username} at {addr[0]}:{PORT}")
                messagebox.showinfo("Connection Made",
                                    f"You're now connected with '{responder_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if responder_username not in user_colors:
                    user_colors[responder_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")
    root.configure(bg="#70a9c8")  # Set body color

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=lambda: set_port(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=lambda: set_username(),
                                    bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                    bd=2, relief='solid', highlightbackground="#269144")
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled',
                              command=lambda: invite_buddy(),
                              bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                              bd=2, relief='solid', highlightbackground="#269144")
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)

        # Button to Send Connection Request
        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite",
                                command=lambda: send_request(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause,
                             bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                             bd=2, relief='solid', highlightbackground="#269144")
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            custom_error_popup("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        # Send username to connected users (if any)
        # No username broadcasting is required since connections are IP-based
        messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
        # Disable the username entry and button after setting
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:27:00,580 - DEBUG - Broadcasting clipboard content: 1. cant varify of the other person has accepting the request like no connection is being made still its selding a connection request.

2. cant detect if the request is send to yourself

3. button border color is still black use this #269144

4. use enter to press button and all buttons are rounded by 16px or any unit you use 

5. use a list of funny usernames if none sets username by themselfs (let the set username be active so they can change at anytime and when they change the username send a packet showing the new username of the specific person and the other person to show the new username)

import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, REQUEST_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_sock.sendto(username.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected from {addr[0]}:{sender_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                responder_username = data.decode('utf-8')
                # Add the responder to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {responder_username} at {addr[0]}:{PORT}")
                messagebox.showinfo("Connection Made",
                                    f"You're now connected with '{responder_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if responder_username not in user_colors:
                    user_colors[responder_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")
    root.configure(bg="#70a9c8")  # Set body color

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=lambda: set_port(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=lambda: set_username(),
                                    bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                    bd=2, relief='solid', highlightbackground="#269144")
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled',
                              command=lambda: invite_buddy(),
                              bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                              bd=2, relief='solid', highlightbackground="#269144")
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)

        # Button to Send Connection Request
        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite",
                                command=lambda: send_request(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause,
                             bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                             bd=2, relief='solid', highlightbackground="#269144")
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            custom_error_popup("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        # Send username to connected users (if any)
        # No username broadcasting is required since connections are IP-based
        messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
        # Disable the username entry and button after setting
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:27:00,604 - DEBUG - Broadcasting clipboard content: 1. cant varify of the other person has accepting the request like no connection is being made still its selding a connection request.

2. cant detect if the request is send to yourself

3. button border color is still black use this #269144

4. use enter to press button and all buttons are rounded by 16px or any unit you use 

5. use a list of funny usernames if none sets username by themselfs (let the set username be active so they can change at anytime and when they change the username send a packet showing the new username of the specific person and the other person to show the new username)

import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, REQUEST_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_sock.sendto(username.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected from {addr[0]}:{sender_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                responder_username = data.decode('utf-8')
                # Add the responder to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {responder_username} at {addr[0]}:{PORT}")
                messagebox.showinfo("Connection Made",
                                    f"You're now connected with '{responder_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if responder_username not in user_colors:
                    user_colors[responder_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")
    root.configure(bg="#70a9c8")  # Set body color

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=lambda: set_port(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=lambda: set_username(),
                                    bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                    bd=2, relief='solid', highlightbackground="#269144")
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled',
                              command=lambda: invite_buddy(),
                              bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                              bd=2, relief='solid', highlightbackground="#269144")
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)

        # Button to Send Connection Request
        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite",
                                command=lambda: send_request(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause,
                             bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                             bd=2, relief='solid', highlightbackground="#269144")
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            custom_error_popup("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        # Send username to connected users (if any)
        # No username broadcasting is required since connections are IP-based
        messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
        # Disable the username entry and button after setting
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:27:01,619 - DEBUG - Broadcasting clipboard content: 1. cant varify of the other person has accepting the request like no connection is being made still its selding a connection request.

2. cant detect if the request is send to yourself

3. button border color is still black use this #269144

4. use enter to press button and all buttons are rounded by 16px or any unit you use 

5. use a list of funny usernames if none sets username by themselfs (let the set username be active so they can change at anytime and when they change the username send a packet showing the new username of the specific person and the other person to show the new username)

import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, REQUEST_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_sock.sendto(username.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected from {addr[0]}:{sender_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                responder_username = data.decode('utf-8')
                # Add the responder to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {responder_username} at {addr[0]}:{PORT}")
                messagebox.showinfo("Connection Made",
                                    f"You're now connected with '{responder_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if responder_username not in user_colors:
                    user_colors[responder_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")
    root.configure(bg="#70a9c8")  # Set body color

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=lambda: set_port(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=lambda: set_username(),
                                    bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                    bd=2, relief='solid', highlightbackground="#269144")
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled',
                              command=lambda: invite_buddy(),
                              bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                              bd=2, relief='solid', highlightbackground="#269144")
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)

        # Button to Send Connection Request
        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite",
                                command=lambda: send_request(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause,
                             bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                             bd=2, relief='solid', highlightbackground="#269144")
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            custom_error_popup("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        # Send username to connected users (if any)
        # No username broadcasting is required since connections are IP-based
        messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
        # Disable the username entry and button after setting
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:27:01,656 - DEBUG - Broadcasting clipboard content: 1. cant varify of the other person has accepting the request like no connection is being made still its selding a connection request.

2. cant detect if the request is send to yourself

3. button border color is still black use this #269144

4. use enter to press button and all buttons are rounded by 16px or any unit you use 

5. use a list of funny usernames if none sets username by themselfs (let the set username be active so they can change at anytime and when they change the username send a packet showing the new username of the specific person and the other person to show the new username)

import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, REQUEST_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_sock.sendto(username.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected from {addr[0]}:{sender_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                responder_username = data.decode('utf-8')
                # Add the responder to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {responder_username} at {addr[0]}:{PORT}")
                messagebox.showinfo("Connection Made",
                                    f"You're now connected with '{responder_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if responder_username not in user_colors:
                    user_colors[responder_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")
    root.configure(bg="#70a9c8")  # Set body color

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=lambda: set_port(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=lambda: set_username(),
                                    bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                    bd=2, relief='solid', highlightbackground="#269144")
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled',
                              command=lambda: invite_buddy(),
                              bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                              bd=2, relief='solid', highlightbackground="#269144")
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)

        # Button to Send Connection Request
        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite",
                                command=lambda: send_request(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause,
                             bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                             bd=2, relief='solid', highlightbackground="#269144")
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            custom_error_popup("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        # Send username to connected users (if any)
        # No username broadcasting is required since connections are IP-based
        messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
        # Disable the username entry and button after setting
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:28:12,293 - DEBUG - Broadcasting clipboard content: funny game usernames
2024-11-05 15:28:12,337 - DEBUG - Broadcasting clipboard content: funny game usernames
2024-11-05 15:28:12,540 - DEBUG - Broadcasting clipboard content: funny game usernames
2024-11-05 15:28:12,898 - DEBUG - Broadcasting clipboard content: funny game usernames
2024-11-05 15:30:31,618 - DEBUG - Broadcasting clipboard content: TextualTornado
TypoTitan
ChatChomper
WordWhiskers
EmojiExplorer
LaughingLetter
TxtWizKid
SnappyScript
ByteBandit
PixelPunctuation
LOLLinguist
GrammarGator
BuzzingBeeps
GiggleGlitch
MemeMorsel
S'morePixels
ChuckleCharm
FableFrolic
ScribbleSprite
FontFunk
DizzyDialogue
JollyJabber
TickleTyper
PunctuationPirate
GigabyteGiggler
ChortleChimp
HappyTypo
ScrollSorcerer
LOLingLlama
TypoTreasure






2024-11-05 15:30:31,739 - DEBUG - Broadcasting clipboard content: TextualTornado
TypoTitan
ChatChomper
WordWhiskers
EmojiExplorer
LaughingLetter
TxtWizKid
SnappyScript
ByteBandit
PixelPunctuation
LOLLinguist
GrammarGator
BuzzingBeeps
GiggleGlitch
MemeMorsel
S'morePixels
ChuckleCharm
FableFrolic
ScribbleSprite
FontFunk
DizzyDialogue
JollyJabber
TickleTyper
PunctuationPirate
GigabyteGiggler
ChortleChimp
HappyTypo
ScrollSorcerer
LOLingLlama
TypoTreasure






2024-11-05 15:30:32,094 - DEBUG - Broadcasting clipboard content: TextualTornado
TypoTitan
ChatChomper
WordWhiskers
EmojiExplorer
LaughingLetter
TxtWizKid
SnappyScript
ByteBandit
PixelPunctuation
LOLLinguist
GrammarGator
BuzzingBeeps
GiggleGlitch
MemeMorsel
S'morePixels
ChuckleCharm
FableFrolic
ScribbleSprite
FontFunk
DizzyDialogue
JollyJabber
TickleTyper
PunctuationPirate
GigabyteGiggler
ChortleChimp
HappyTypo
ScrollSorcerer
LOLingLlama
TypoTreasure






2024-11-05 15:30:32,388 - DEBUG - Broadcasting clipboard content: TextualTornado
TypoTitan
ChatChomper
WordWhiskers
EmojiExplorer
LaughingLetter
TxtWizKid
SnappyScript
ByteBandit
PixelPunctuation
LOLLinguist
GrammarGator
BuzzingBeeps
GiggleGlitch
MemeMorsel
S'morePixels
ChuckleCharm
FableFrolic
ScribbleSprite
FontFunk
DizzyDialogue
JollyJabber
TickleTyper
PunctuationPirate
GigabyteGiggler
ChortleChimp
HappyTypo
ScrollSorcerer
LOLingLlama
TypoTreasure






2024-11-05 15:32:27,398 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_UPDATE_PORT = 5003  # Port for username updates
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, info['port']))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update copy count
                            if addr[0] in USER_STATS:
                                USER_STATS[addr[0]] += 1
                            else:
                                USER_STATS[addr[0]] = 1
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                    USER_STATS[addr[0]] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{PORT}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], PORT)
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def handle_username_updates():
    # Create a UDP socket for listening to incoming username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for username updates on USERNAME_UPDATE_PORT
            sock.bind(('', USERNAME_UPDATE_PORT))
            logging.debug(f"Listening for username updates on port {USERNAME_UPDATE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {USERNAME_UPDATE_PORT} for username updates: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME_UPDATE:"):
                    _, new_username = received_message.split(':', 1)
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling username update: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if (target_ip == local_ip and target_port == PORT) or (target_ip == local_ip and target_port == RESPONSE_PORT):
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_sock.bind(('', RESPONSE_PORT))
                    response_message, _ = response_sock.recvfrom(1024)
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        responder_username = response_message.split(':', 1)[1]
                        # Add the responder to TARGET_USERS
                        TARGET_USERS[target_ip] = {'port': PORT, 'copy_count': 0, 'username': responder_username}
                        USER_STATS[target_ip] = 0
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{PORT}")
                        messagebox.showinfo("Connection Success",
                                            f"Now sharing vibes with '{responder_username}' at {target_ip}:{PORT}!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(responder_username, f"Connected from {target_ip}:{PORT}")
                        # Send current username to the new connection
                        send_username_update(target_ip, PORT)
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, USERNAME_UPDATE_PORT))
            logging.debug(f"Sent username update to {target_ip}:{USERNAME_UPDATE_PORT}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to handle username updates
    threading.Thread(target=handle_username_updates, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text, pause_button

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = ttk.Button(settings_frame, text="\U0001f527 Set Port", style='Custom.TButton',
                                 command=lambda: set_port())
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    # Bind Enter key to Set Port and Set Username buttons
    root.bind('<Return>', lambda event: set_port() if port_entry.focus_get() else None)
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:32:27,659 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_UPDATE_PORT = 5003  # Port for username updates
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, info['port']))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update copy count
                            if addr[0] in USER_STATS:
                                USER_STATS[addr[0]] += 1
                            else:
                                USER_STATS[addr[0]] = 1
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                    USER_STATS[addr[0]] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{PORT}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], PORT)
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def handle_username_updates():
    # Create a UDP socket for listening to incoming username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for username updates on USERNAME_UPDATE_PORT
            sock.bind(('', USERNAME_UPDATE_PORT))
            logging.debug(f"Listening for username updates on port {USERNAME_UPDATE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {USERNAME_UPDATE_PORT} for username updates: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME_UPDATE:"):
                    _, new_username = received_message.split(':', 1)
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling username update: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if (target_ip == local_ip and target_port == PORT) or (target_ip == local_ip and target_port == RESPONSE_PORT):
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_sock.bind(('', RESPONSE_PORT))
                    response_message, _ = response_sock.recvfrom(1024)
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        responder_username = response_message.split(':', 1)[1]
                        # Add the responder to TARGET_USERS
                        TARGET_USERS[target_ip] = {'port': PORT, 'copy_count': 0, 'username': responder_username}
                        USER_STATS[target_ip] = 0
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{PORT}")
                        messagebox.showinfo("Connection Success",
                                            f"Now sharing vibes with '{responder_username}' at {target_ip}:{PORT}!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(responder_username, f"Connected from {target_ip}:{PORT}")
                        # Send current username to the new connection
                        send_username_update(target_ip, PORT)
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, USERNAME_UPDATE_PORT))
            logging.debug(f"Sent username update to {target_ip}:{USERNAME_UPDATE_PORT}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to handle username updates
    threading.Thread(target=handle_username_updates, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text, pause_button

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = ttk.Button(settings_frame, text="\U0001f527 Set Port", style='Custom.TButton',
                                 command=lambda: set_port())
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    # Bind Enter key to Set Port and Set Username buttons
    root.bind('<Return>', lambda event: set_port() if port_entry.focus_get() else None)
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:32:27,716 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_UPDATE_PORT = 5003  # Port for username updates
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, info['port']))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update copy count
                            if addr[0] in USER_STATS:
                                USER_STATS[addr[0]] += 1
                            else:
                                USER_STATS[addr[0]] = 1
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                    USER_STATS[addr[0]] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{PORT}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], PORT)
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def handle_username_updates():
    # Create a UDP socket for listening to incoming username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for username updates on USERNAME_UPDATE_PORT
            sock.bind(('', USERNAME_UPDATE_PORT))
            logging.debug(f"Listening for username updates on port {USERNAME_UPDATE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {USERNAME_UPDATE_PORT} for username updates: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME_UPDATE:"):
                    _, new_username = received_message.split(':', 1)
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling username update: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if (target_ip == local_ip and target_port == PORT) or (target_ip == local_ip and target_port == RESPONSE_PORT):
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_sock.bind(('', RESPONSE_PORT))
                    response_message, _ = response_sock.recvfrom(1024)
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        responder_username = response_message.split(':', 1)[1]
                        # Add the responder to TARGET_USERS
                        TARGET_USERS[target_ip] = {'port': PORT, 'copy_count': 0, 'username': responder_username}
                        USER_STATS[target_ip] = 0
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{PORT}")
                        messagebox.showinfo("Connection Success",
                                            f"Now sharing vibes with '{responder_username}' at {target_ip}:{PORT}!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(responder_username, f"Connected from {target_ip}:{PORT}")
                        # Send current username to the new connection
                        send_username_update(target_ip, PORT)
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, USERNAME_UPDATE_PORT))
            logging.debug(f"Sent username update to {target_ip}:{USERNAME_UPDATE_PORT}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to handle username updates
    threading.Thread(target=handle_username_updates, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text, pause_button

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = ttk.Button(settings_frame, text="\U0001f527 Set Port", style='Custom.TButton',
                                 command=lambda: set_port())
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    # Bind Enter key to Set Port and Set Username buttons
    root.bind('<Return>', lambda event: set_port() if port_entry.focus_get() else None)
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:32:28,043 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_UPDATE_PORT = 5003  # Port for username updates
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, info['port']))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update copy count
                            if addr[0] in USER_STATS:
                                USER_STATS[addr[0]] += 1
                            else:
                                USER_STATS[addr[0]] = 1
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                    USER_STATS[addr[0]] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{PORT}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], PORT)
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def handle_username_updates():
    # Create a UDP socket for listening to incoming username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for username updates on USERNAME_UPDATE_PORT
            sock.bind(('', USERNAME_UPDATE_PORT))
            logging.debug(f"Listening for username updates on port {USERNAME_UPDATE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {USERNAME_UPDATE_PORT} for username updates: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME_UPDATE:"):
                    _, new_username = received_message.split(':', 1)
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling username update: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if (target_ip == local_ip and target_port == PORT) or (target_ip == local_ip and target_port == RESPONSE_PORT):
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_sock.bind(('', RESPONSE_PORT))
                    response_message, _ = response_sock.recvfrom(1024)
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        responder_username = response_message.split(':', 1)[1]
                        # Add the responder to TARGET_USERS
                        TARGET_USERS[target_ip] = {'port': PORT, 'copy_count': 0, 'username': responder_username}
                        USER_STATS[target_ip] = 0
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{PORT}")
                        messagebox.showinfo("Connection Success",
                                            f"Now sharing vibes with '{responder_username}' at {target_ip}:{PORT}!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(responder_username, f"Connected from {target_ip}:{PORT}")
                        # Send current username to the new connection
                        send_username_update(target_ip, PORT)
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, USERNAME_UPDATE_PORT))
            logging.debug(f"Sent username update to {target_ip}:{USERNAME_UPDATE_PORT}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to handle username updates
    threading.Thread(target=handle_username_updates, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text, pause_button

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = ttk.Button(settings_frame, text="\U0001f527 Set Port", style='Custom.TButton',
                                 command=lambda: set_port())
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    # Bind Enter key to Set Port and Set Username buttons
    root.bind('<Return>', lambda event: set_port() if port_entry.focus_get() else None)
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:32:30,179 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, REQUEST_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_sock.sendto(username.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected from {addr[0]}:{sender_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                responder_username = data.decode('utf-8')
                # Add the responder to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {responder_username} at {addr[0]}:{PORT}")
                messagebox.showinfo("Connection Made",
                                    f"You're now connected with '{responder_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if responder_username not in user_colors:
                    user_colors[responder_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")
    root.configure(bg="#70a9c8")  # Set body color

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=lambda: set_port(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=lambda: set_username(),
                                    bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                    bd=2, relief='solid', highlightbackground="#269144")
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled',
                              command=lambda: invite_buddy(),
                              bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                              bd=2, relief='solid', highlightbackground="#269144")
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)

        # Button to Send Connection Request
        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite",
                                command=lambda: send_request(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause,
                             bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                             bd=2, relief='solid', highlightbackground="#269144")
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            custom_error_popup("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        # Send username to connected users (if any)
        # No username broadcasting is required since connections are IP-based
        messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
        # Disable the username entry and button after setting
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:32:30,321 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, REQUEST_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_sock.sendto(username.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected from {addr[0]}:{sender_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                responder_username = data.decode('utf-8')
                # Add the responder to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {responder_username} at {addr[0]}:{PORT}")
                messagebox.showinfo("Connection Made",
                                    f"You're now connected with '{responder_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if responder_username not in user_colors:
                    user_colors[responder_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")
    root.configure(bg="#70a9c8")  # Set body color

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=lambda: set_port(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=lambda: set_username(),
                                    bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                    bd=2, relief='solid', highlightbackground="#269144")
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled',
                              command=lambda: invite_buddy(),
                              bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                              bd=2, relief='solid', highlightbackground="#269144")
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)

        # Button to Send Connection Request
        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite",
                                command=lambda: send_request(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause,
                             bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                             bd=2, relief='solid', highlightbackground="#269144")
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            custom_error_popup("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        # Send username to connected users (if any)
        # No username broadcasting is required since connections are IP-based
        messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
        # Disable the username entry and button after setting
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:32:30,722 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, REQUEST_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_sock.sendto(username.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected from {addr[0]}:{sender_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                responder_username = data.decode('utf-8')
                # Add the responder to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {responder_username} at {addr[0]}:{PORT}")
                messagebox.showinfo("Connection Made",
                                    f"You're now connected with '{responder_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if responder_username not in user_colors:
                    user_colors[responder_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")
    root.configure(bg="#70a9c8")  # Set body color

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=lambda: set_port(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=lambda: set_username(),
                                    bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                    bd=2, relief='solid', highlightbackground="#269144")
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled',
                              command=lambda: invite_buddy(),
                              bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                              bd=2, relief='solid', highlightbackground="#269144")
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)

        # Button to Send Connection Request
        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite",
                                command=lambda: send_request(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause,
                             bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                             bd=2, relief='solid', highlightbackground="#269144")
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            custom_error_popup("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        # Send username to connected users (if any)
        # No username broadcasting is required since connections are IP-based
        messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
        # Disable the username entry and button after setting
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:32:31,113 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, REQUEST_PORT))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                received_id, received_username, received_text = received_message.split(':', 2)

                # Ignore the message if it was sent by this instance
                if received_id == instance_id:
                    continue

                logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                # Lock to prevent race conditions when accessing shared resource (last_text)
                with clipboard_lock:
                    # Only update the clipboard if the received content is different
                    if received_text != last_text:
                        logging.debug("Updating local clipboard with received content...")
                        last_text = received_text
                        pyperclip.copy(received_text)
                        logging.debug(f"Clipboard updated from network: {received_text}")
                        # Update copy count
                        if addr[0] in USER_STATS:
                            USER_STATS[addr[0]] += 1
                        else:
                            USER_STATS[addr[0]] = 1
                        log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_sock.sendto(username.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected from {addr[0]}:{sender_port}")
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                responder_username = data.decode('utf-8')
                # Add the responder to TARGET_USERS
                TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                USER_STATS[addr[0]] = 0
                logging.debug(f"Connection confirmed with {responder_username} at {addr[0]}:{PORT}")
                messagebox.showinfo("Connection Made",
                                    f"You're now connected with '{responder_username}' at {addr[0]}:{PORT}!")
                is_connected.set()
                # Assign color for the new user
                if responder_username not in user_colors:
                    user_colors[responder_username] = get_next_color()
                # Update the connected users display
                update_connected_users_display()
                # Log the activity
                log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if target_ip == local_ip and target_port == PORT:
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_message, _ = response_sock.recvfrom(1024)
                    responder_username = response_message.decode('utf-8')
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[target_ip] = {'port': target_port, 'copy_count': 0}
                    USER_STATS[target_ip] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{target_port}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {target_ip}:{target_port}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {target_ip}:{target_port}")
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        connected_users_tree.insert('', 'end', values=(ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("700x600")
    root.configure(bg="#70a9c8")  # Set body color

    # Set the window icon (favicon)
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_photo_icon = ImageTk.PhotoImage(logo_image)
        root.iconphoto(False, logo_photo_icon)

    # Display the logo at the top of the window
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = tk.Button(settings_frame, text="\U0001f527 Set Port", command=lambda: set_port(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = tk.Button(settings_frame, text="\U0001f389 Set Username", command=lambda: set_username(),
                                    bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                    bd=2, relief='solid', highlightbackground="#269144")
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = tk.Button(root, text="\U0001f46b Invite a Buddy", state='disabled',
                              command=lambda: invite_buddy(),
                              bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                              bd=2, relief='solid', highlightbackground="#269144")
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)

        # Button to Send Connection Request
        send_button = tk.Button(invite_window, text="\U0001f4e8 Send Invite",
                                command=lambda: send_request(),
                                bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                                bd=2, relief='solid', highlightbackground="#269144")
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = tk.Button(root, text="\u23f8\ufe0f Pause Sync", command=toggle_pause,
                             bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                             bd=2, relief='solid', highlightbackground="#269144")
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            custom_error_popup("No Name, No Game", "You gotta have a username to play!")
            return
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        username = entered_username
        # Send username to connected users (if any)
        # No username broadcasting is required since connections are IP-based
        messagebox.showinfo("Username Set", f"Username '{username}' set successfully.")
        # Disable the username entry and button after setting
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:32:34,642 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_UPDATE_PORT = 5003  # Port for username updates
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, info['port']))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update copy count
                            if addr[0] in USER_STATS:
                                USER_STATS[addr[0]] += 1
                            else:
                                USER_STATS[addr[0]] = 1
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                    USER_STATS[addr[0]] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{PORT}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], PORT)
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def handle_username_updates():
    # Create a UDP socket for listening to incoming username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for username updates on USERNAME_UPDATE_PORT
            sock.bind(('', USERNAME_UPDATE_PORT))
            logging.debug(f"Listening for username updates on port {USERNAME_UPDATE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {USERNAME_UPDATE_PORT} for username updates: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME_UPDATE:"):
                    _, new_username = received_message.split(':', 1)
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling username update: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if (target_ip == local_ip and target_port == PORT) or (target_ip == local_ip and target_port == RESPONSE_PORT):
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_sock.bind(('', RESPONSE_PORT))
                    response_message, _ = response_sock.recvfrom(1024)
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        responder_username = response_message.split(':', 1)[1]
                        # Add the responder to TARGET_USERS
                        TARGET_USERS[target_ip] = {'port': PORT, 'copy_count': 0, 'username': responder_username}
                        USER_STATS[target_ip] = 0
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{PORT}")
                        messagebox.showinfo("Connection Success",
                                            f"Now sharing vibes with '{responder_username}' at {target_ip}:{PORT}!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(responder_username, f"Connected from {target_ip}:{PORT}")
                        # Send current username to the new connection
                        send_username_update(target_ip, PORT)
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, USERNAME_UPDATE_PORT))
            logging.debug(f"Sent username update to {target_ip}:{USERNAME_UPDATE_PORT}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to handle username updates
    threading.Thread(target=handle_username_updates, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text, pause_button

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = ttk.Button(settings_frame, text="\U0001f527 Set Port", style='Custom.TButton',
                                 command=lambda: set_port())
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    # Bind Enter key to Set Port and Set Username buttons
    root.bind('<Return>', lambda event: set_port() if port_entry.focus_get() else None)
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:32:34,881 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_UPDATE_PORT = 5003  # Port for username updates
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, info['port']))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update copy count
                            if addr[0] in USER_STATS:
                                USER_STATS[addr[0]] += 1
                            else:
                                USER_STATS[addr[0]] = 1
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                    USER_STATS[addr[0]] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{PORT}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], PORT)
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def handle_username_updates():
    # Create a UDP socket for listening to incoming username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for username updates on USERNAME_UPDATE_PORT
            sock.bind(('', USERNAME_UPDATE_PORT))
            logging.debug(f"Listening for username updates on port {USERNAME_UPDATE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {USERNAME_UPDATE_PORT} for username updates: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME_UPDATE:"):
                    _, new_username = received_message.split(':', 1)
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling username update: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if (target_ip == local_ip and target_port == PORT) or (target_ip == local_ip and target_port == RESPONSE_PORT):
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_sock.bind(('', RESPONSE_PORT))
                    response_message, _ = response_sock.recvfrom(1024)
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        responder_username = response_message.split(':', 1)[1]
                        # Add the responder to TARGET_USERS
                        TARGET_USERS[target_ip] = {'port': PORT, 'copy_count': 0, 'username': responder_username}
                        USER_STATS[target_ip] = 0
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{PORT}")
                        messagebox.showinfo("Connection Success",
                                            f"Now sharing vibes with '{responder_username}' at {target_ip}:{PORT}!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(responder_username, f"Connected from {target_ip}:{PORT}")
                        # Send current username to the new connection
                        send_username_update(target_ip, PORT)
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, USERNAME_UPDATE_PORT))
            logging.debug(f"Sent username update to {target_ip}:{USERNAME_UPDATE_PORT}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to handle username updates
    threading.Thread(target=handle_username_updates, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text, pause_button

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = ttk.Button(settings_frame, text="\U0001f527 Set Port", style='Custom.TButton',
                                 command=lambda: set_port())
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    # Bind Enter key to Set Port and Set Username buttons
    root.bind('<Return>', lambda event: set_port() if port_entry.focus_get() else None)
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:32:34,883 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_UPDATE_PORT = 5003  # Port for username updates
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, info['port']))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update copy count
                            if addr[0] in USER_STATS:
                                USER_STATS[addr[0]] += 1
                            else:
                                USER_STATS[addr[0]] = 1
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                    USER_STATS[addr[0]] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{PORT}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], PORT)
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def handle_username_updates():
    # Create a UDP socket for listening to incoming username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for username updates on USERNAME_UPDATE_PORT
            sock.bind(('', USERNAME_UPDATE_PORT))
            logging.debug(f"Listening for username updates on port {USERNAME_UPDATE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {USERNAME_UPDATE_PORT} for username updates: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME_UPDATE:"):
                    _, new_username = received_message.split(':', 1)
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling username update: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if (target_ip == local_ip and target_port == PORT) or (target_ip == local_ip and target_port == RESPONSE_PORT):
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_sock.bind(('', RESPONSE_PORT))
                    response_message, _ = response_sock.recvfrom(1024)
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        responder_username = response_message.split(':', 1)[1]
                        # Add the responder to TARGET_USERS
                        TARGET_USERS[target_ip] = {'port': PORT, 'copy_count': 0, 'username': responder_username}
                        USER_STATS[target_ip] = 0
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{PORT}")
                        messagebox.showinfo("Connection Success",
                                            f"Now sharing vibes with '{responder_username}' at {target_ip}:{PORT}!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(responder_username, f"Connected from {target_ip}:{PORT}")
                        # Send current username to the new connection
                        send_username_update(target_ip, PORT)
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, USERNAME_UPDATE_PORT))
            logging.debug(f"Sent username update to {target_ip}:{USERNAME_UPDATE_PORT}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to handle username updates
    threading.Thread(target=handle_username_updates, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text, pause_button

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = ttk.Button(settings_frame, text="\U0001f527 Set Port", style='Custom.TButton',
                                 command=lambda: set_port())
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    # Bind Enter key to Set Port and Set Username buttons
    root.bind('<Return>', lambda event: set_port() if port_entry.focus_get() else None)
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:32:35,908 - DEBUG - Broadcasting clipboard content: import socket
import threading
import pyperclip
import time
import uuid
import random
import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk
import sys
import os
from PIL import Image, ImageTk  # For handling logo images
import ctypes
import logging  # For debugging purposes

# Set up logging
logging.basicConfig(filename='clipboard_sync.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Get the IP address of the current system
hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)

# Network configuration
DEFAULT_PORT_RANGE = range(5000, 5051)  # Ports 5000 to 5050
PORT = None  # Will be set dynamically or via user input
REQUEST_PORT = 5001  # Static Port for connection requests
RESPONSE_PORT = 5002  # Port for connection responses
USERNAME_UPDATE_PORT = 5003  # Port for username updates
MAX_UDP_SIZE = 65535  # Maximum size for UDP packet

TARGET_USERS = {}  # Dictionary to store target IPs and their details
USER_STATS = {}  # Dictionary to store copy counts per user

# Track the last clipboard content to avoid redundant broadcasts
last_text = ""

# Generate a unique ID for this instance to prevent re-broadcast loops
instance_id = str(uuid.uuid4())

# Lock to prevent race conditions when updating the clipboard
clipboard_lock = threading.Lock()

# Pause flag to control broadcasting and listening
pause_flag = threading.Event()
pause_flag.set()  # Initially not paused

# Variable to track if at least one connection is established
is_connected = threading.Event()

# Store the username
username = None

# Dictionary to store colors for users
user_colors = {}
color_palette = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'yellow']
color_index = 0
color_lock = threading.Lock()

# List of funny usernames
FUNNY_USERNAMES = [
    "TextualTornado", "TypoTitan", "ChatChomper", "WordWhiskers",
    "EmojiExplorer", "LaughingLetter", "TxtWizKid", "SnappyScript",
    "ByteBandit", "PixelPunctuation", "LOLLinguist", "GrammarGator",
    "BuzzingBeeps", "GiggleGlitch", "MemeMorsel", "S'morePixels",
    "ChuckleCharm", "FableFrolic", "ScribbleSprite", "FontFunk",
    "DizzyDialogue", "JollyJabber", "TickleTyper", "PunctuationPirate",
    "GigabyteGiggler", "ChortleChimp", "HappyTypo", "ScrollSorcerer",
    "LOLingLlama", "TypoTreasure"
]

def get_random_funny_username():
    return random.choice(FUNNY_USERNAMES)

def get_next_color():
    global color_index
    with color_lock:
        color = color_palette[color_index % len(color_palette)]
        color_index += 1
    return color

def custom_error_popup(title, message):
    """Creates a custom error popup with specified colors."""
    error_window = tk.Toplevel()
    error_window.title(title)
    error_window.configure(bg="#ff4a38")
    error_window.geometry("400x200")
    error_window.grab_set()  # Make the window modal

    # Message Label
    message_label = tk.Label(error_window, text=message, bg="#ff4a38", fg="#000000",
                             font=("Helvetica", 12, "bold"), wraplength=350, justify='center')
    message_label.pack(pady=40)

    # OK Button
    ok_button = tk.Button(error_window, text="OK", command=error_window.destroy,
                          bg="#d9534f", fg="#ffffff", font=("Helvetica", 10, "bold"),
                          relief='solid', borderwidth=2, highlightbackground="#269144")
    ok_button.pack(pady=10)

def broadcast_clipboard_content():
    global last_text
    while True:
        if not pause_flag.is_set():
            time.sleep(1)
            continue
        try:
            # Get the current clipboard content
            current_text = pyperclip.paste()
            # Lock to prevent race conditions when accessing shared resource (last_text)
            with clipboard_lock:
                # Only broadcast if the clipboard content has changed
                if current_text != last_text:
                    # Truncate clipboard content if it exceeds the maximum allowed size
                    if len(current_text.encode('utf-8')) > MAX_UDP_SIZE:
                        current_text = current_text[:MAX_UDP_SIZE // 2]  # Truncate to fit into a UDP packet
                    last_text = current_text
                    message = f"CLIPBOARD_UPDATE:{instance_id}:{username}:{current_text}"
                    logging.debug(f"Broadcasting clipboard content: {current_text}")
                    # Create a UDP socket for broadcasting the clipboard content
                    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                        # Send the clipboard content to each target IP and specified port
                        for ip, info in TARGET_USERS.items():
                            sock.sendto(message.encode('utf-8'), (ip, info['port']))
        except Exception as e:
            # Log any errors that occur during broadcasting
            logging.error(f"Error broadcasting clipboard content: {e}")
        # Wait for a random period (between 1 and 2 seconds) before checking the clipboard again
        time.sleep(random.uniform(1, 2))

def listen_for_clipboard_updates():
    global last_text
    # Create a UDP socket for listening to incoming clipboard updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to all available network interfaces on the specified port
            sock.bind(('', PORT))
            logging.debug(f"Listening for clipboard updates on port {PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {PORT} for clipboard updates: {e}")
            return

        while True:
            if not pause_flag.is_set():
                time.sleep(1)
                continue
            try:
                # Receive data from the socket (buffer size of MAX_UDP_SIZE bytes)
                data, addr = sock.recvfrom(MAX_UDP_SIZE)
                # Decode the received data to get the clipboard content
                received_message = data.decode('utf-8')
                if received_message.startswith("CLIPBOARD_UPDATE:"):
                    _, received_id, received_username, received_text = received_message.split(':', 3)

                    # Ignore the message if it was sent by this instance
                    if received_id == instance_id:
                        continue

                    logging.debug(f"Received clipboard content from {addr[0]}:{addr[1]}: {received_text}")
                    # Lock to prevent race conditions when accessing shared resource (last_text)
                    with clipboard_lock:
                        # Only update the clipboard if the received content is different
                        if received_text != last_text:
                            logging.debug("Updating local clipboard with received content...")
                            last_text = received_text
                            pyperclip.copy(received_text)
                            logging.debug(f"Clipboard updated from network: {received_text}")
                            # Update copy count
                            if addr[0] in USER_STATS:
                                USER_STATS[addr[0]] += 1
                            else:
                                USER_STATS[addr[0]] = 1
                            log_activity(received_username, f"Copied: {received_text}")
            except Exception as e:
                # Log any errors that occur during receiving
                logging.error(f"Error receiving clipboard content: {e}")

def handle_connection_requests():
    # Create a UDP socket for listening to incoming connection requests
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to the static REQUEST_PORT
            sock.bind(('', REQUEST_PORT))
            logging.debug(f"Listening for connection requests on port {REQUEST_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {REQUEST_PORT} for connection requests: {e}")
            return

        while True:
            try:
                # Receive data from the socket (buffer size of 1024 bytes)
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                logging.debug(f"Received connection request from {addr[0]}:{addr[1]}: {received_message}")
                if received_message.startswith("REQUEST_CONNECTION:"):
                    _, sender_port = received_message.split(':', 1)
                    sender_port = int(sender_port)
                    # Prevent accepting connection from self
                    if addr[0] == local_ip and sender_port == PORT:
                        logging.warning(f"Received connection request from self at {addr[0]}:{sender_port}. Ignoring.")
                        continue
                    # Ask the user if they want to accept the connection
                    root.withdraw()  # Hide the root window
                    result = messagebox.askyesno("Connection Request",
                                                 f"Do you want to connect with user at {addr[0]}:{sender_port}?")
                    if result:
                        # Send back own username
                        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                            response_message = f"CONNECTION_ACCEPTED:{username}"
                            response_sock.sendto(response_message.encode('utf-8'), addr)
                        # Add the user to TARGET_USERS
                        TARGET_USERS[addr[0]] = {'port': sender_port, 'copy_count': 0}
                        USER_STATS[addr[0]] = 0
                        logging.debug(f"Accepted connection from {addr[0]}:{sender_port}")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if username not in user_colors:
                            user_colors[username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(username, f"Connected with {addr[0]}:{sender_port}")
                        # Send current username to the new connection
                        send_username_update(addr[0], TARGET_USERS[addr[0]]['port'])
                    else:
                        logging.debug(f"Declined connection from {addr[0]}:{sender_port}")
            except Exception as e:
                logging.error(f"Error handling connection request: {e}")

def handle_connection_responses():
    # Create a UDP socket for listening to incoming connection responses
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for responses on RESPONSE_PORT
            sock.bind(('', RESPONSE_PORT))
            logging.debug(f"Listening for connection responses on port {RESPONSE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {RESPONSE_PORT} for connection responses: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("CONNECTION_ACCEPTED:"):
                    responder_username = received_message.split(':', 1)[1]
                    # Add the responder to TARGET_USERS
                    TARGET_USERS[addr[0]] = {'port': PORT, 'copy_count': 0}
                    USER_STATS[addr[0]] = 0
                    logging.debug(f"Connection established with '{responder_username}' at {addr[0]}:{PORT}")
                    messagebox.showinfo("Connection Success",
                                        f"Now sharing vibes with '{responder_username}' at {addr[0]}:{PORT}!")
                    is_connected.set()  # Set connection established flag
                    # Assign color for the new user
                    if responder_username not in user_colors:
                        user_colors[responder_username] = get_next_color()
                    # Update the connected users display
                    update_connected_users_display()
                    # Log the activity
                    log_activity(responder_username, f"Connected from {addr[0]}:{PORT}")
                    # Send own username to the new connection
                    send_username_update(addr[0], PORT)
            except Exception as e:
                logging.error(f"Error handling connection response: {e}")

def handle_username_updates():
    # Create a UDP socket for listening to incoming username updates
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # Bind the socket to listen for username updates on USERNAME_UPDATE_PORT
            sock.bind(('', USERNAME_UPDATE_PORT))
            logging.debug(f"Listening for username updates on port {USERNAME_UPDATE_PORT}...")
        except Exception as e:
            logging.error(f"Error binding to port {USERNAME_UPDATE_PORT} for username updates: {e}")
            return

        while True:
            try:
                data, addr = sock.recvfrom(1024)
                received_message = data.decode('utf-8')
                if received_message.startswith("USERNAME_UPDATE:"):
                    _, new_username = received_message.split(':', 1)
                    # Update the username in TARGET_USERS
                    if addr[0] in TARGET_USERS:
                        old_username = TARGET_USERS[addr[0]].get('username', 'Unknown')
                        TARGET_USERS[addr[0]]['username'] = new_username
                        # Assign color if not already
                        if new_username not in user_colors:
                            user_colors[new_username] = get_next_color()
                        update_connected_users_display()
                        log_activity(new_username, f"Changed username from {old_username} to {new_username}")
            except Exception as e:
                logging.error(f"Error handling username update: {e}")

def send_connection_request(target_ip, target_port):
    if not username:
        custom_error_popup("Oops!", "Please set your username first!")
        return
    if (target_ip == local_ip and target_port == PORT) or (target_ip == local_ip and target_port == RESPONSE_PORT):
        custom_error_popup("Oops!", "BRUHHH you are sending request to yourself")
        logging.warning("User attempted to send connection request to themselves.")
        return
    # Create a UDP socket for sending a connection request
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            # Send connection request with sender's port
            message = f"REQUEST_CONNECTION:{PORT}"
            sock.sendto(message.encode('utf-8'), (target_ip, REQUEST_PORT))
            logging.debug(f"Sent connection request to {target_ip}:{REQUEST_PORT}")
            # Wait for a response on the RESPONSE_PORT
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as response_sock:
                response_sock.settimeout(10)  # Set timeout for response
                try:
                    response_sock.bind(('', RESPONSE_PORT))
                    response_message, _ = response_sock.recvfrom(1024)
                    if response_message.startswith("CONNECTION_ACCEPTED:"):
                        responder_username = response_message.split(':', 1)[1]
                        # Add the responder to TARGET_USERS
                        TARGET_USERS[target_ip] = {'port': PORT, 'copy_count': 0, 'username': responder_username}
                        USER_STATS[target_ip] = 0
                        logging.debug(f"Connection established with '{responder_username}' at {target_ip}:{PORT}")
                        messagebox.showinfo("Connection Success",
                                            f"Now sharing vibes with '{responder_username}' at {target_ip}:{PORT}!")
                        is_connected.set()  # Set connection established flag
                        # Assign color for the new user
                        if responder_username not in user_colors:
                            user_colors[responder_username] = get_next_color()
                        # Update the connected users display
                        update_connected_users_display()
                        # Log the activity
                        log_activity(responder_username, f"Connected from {target_ip}:{PORT}")
                        # Send current username to the new connection
                        send_username_update(target_ip, PORT)
                except socket.timeout:
                    logging.debug(f"No response from '{target_ip}:{target_port}'. Connection request timed out.")
                    custom_error_popup("No Response",
                                       f"'{target_ip}:{target_port}' didn't reply. Maybe they're busy?")
        except Exception as e:
            logging.error(f"Error sending connection request: {e}")
            custom_error_popup("Error", f"Failed to send connection request: {e}")

def send_username_update(target_ip, target_port):
    if not username:
        return
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        try:
            message = f"USERNAME_UPDATE:{username}"
            sock.sendto(message.encode('utf-8'), (target_ip, USERNAME_UPDATE_PORT))
            logging.debug(f"Sent username update to {target_ip}:{USERNAME_UPDATE_PORT}")
        except Exception as e:
            logging.error(f"Error sending username update: {e}")

def find_free_port():
    """Finds a free port within the DEFAULT_PORT_RANGE."""
    for port in DEFAULT_PORT_RANGE:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except:
                continue
    raise Exception("No free ports available in the specified range.")

def start_threads():
    # Start a thread to broadcast clipboard content
    threading.Thread(target=broadcast_clipboard_content, daemon=True).start()
    # Start a thread to listen for incoming clipboard updates
    threading.Thread(target=listen_for_clipboard_updates, daemon=True).start()
    # Start a thread to handle connection requests
    threading.Thread(target=handle_connection_requests, daemon=True).start()
    # Start a thread to handle connection responses
    threading.Thread(target=handle_connection_responses, daemon=True).start()
    # Start a thread to handle username updates
    threading.Thread(target=handle_username_updates, daemon=True).start()

def update_connected_users_display():
    """Updates the connected users table in the GUI."""
    for i in connected_users_tree.get_children():
        connected_users_tree.delete(i)
    for ip, info in TARGET_USERS.items():
        display_username = info.get('username', 'Unknown')
        connected_users_tree.insert('', 'end', values=(display_username, ip, info['port'], info['copy_count']))

# GUI Setup
def main():
    global root, username, PORT, connected_users_tree, log_text, pause_button

    root = tk.Tk()
    root.title("ClipHilarity Sync")
    root.geometry("800x700")
    root.configure(bg="#70a9c8")  # Set body color

    # Style configuration using ttk
    style = ttk.Style()
    style.theme_use('default')

    # Configure button styles
    style.configure('Custom.TButton',
                    bordercolor='#269144',
                    borderwidth=2,
                    focusthickness=3,
                    focuscolor='none',
                    padding=6)
    style.map('Custom.TButton',
              foreground=[('active', '#ffffff')],
              background=[('active', '#d9534f')])

    # Display the logo at the top of the window
    image_path = "logo.png"
    if os.path.exists(image_path):
        logo_image = Image.open(image_path)
        logo_image = logo_image.resize((100, 100), Image.LANCZOS)  # Use Image.LANCZOS
        logo_photo = ImageTk.PhotoImage(logo_image)
        logo_label = tk.Label(root, image=logo_photo, bg="#70a9c8")
        logo_label.image = logo_photo  # Keep a reference to prevent garbage collection
        logo_label.pack(pady=10)

    # Frame for Port and Username
    settings_frame = tk.Frame(root, bg="#70a9c8")
    settings_frame.pack(pady=10)

    # Port Entry
    port_label = tk.Label(settings_frame, text="\U0001f527 Communication Port:", font=("Helvetica", 10, "bold"),
                          bg="#70a9c8")
    port_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
    port_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                          highlightbackground="#269144")
    port_entry.grid(row=0, column=1, padx=5, pady=5)

    # Button to Set Port
    set_port_button = ttk.Button(settings_frame, text="\U0001f527 Set Port", style='Custom.TButton',
                                 command=lambda: set_port())
    set_port_button.grid(row=0, column=2, padx=5, pady=5)

    # Username Entry
    username_label = tk.Label(settings_frame, text="\U0001f9d1\u200d\U0001f3a4 Your Funky Username:", font=("Helvetica", 10, "bold"),
                              bg="#70a9c8")
    username_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
    username_entry = tk.Entry(settings_frame, width=30, font=("Helvetica", 10, "bold"), bd=2, relief='solid',
                              highlightbackground="#269144")
    username_entry.grid(row=1, column=1, padx=5, pady=5)

    # Button to Set Username
    set_username_button = ttk.Button(settings_frame, text="\U0001f389 Set Username", style='Custom.TButton',
                                     command=lambda: set_username())
    set_username_button.grid(row=1, column=2, padx=5, pady=5)

    # Display the username and local IP address at the top of the dashboard
    user_label = tk.Label(root, text="\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: Not Set", font=("Helvetica", 12, "bold"),
                          bg="#70a9c8")
    user_label.pack(pady=5)

    ip_label = tk.Label(root, text="\U0001f310 Your Secret Lair IP: Not Set", font=("Helvetica", 12, "bold"),
                        bg="#70a9c8")
    ip_label.pack(pady=5)

    # Add a button to send a connection request
    invite_button = ttk.Button(root, text="\U0001f46b Invite a Buddy", style='Custom.TButton',
                               state='disabled',
                               command=lambda: invite_buddy())
    invite_button.pack(pady=10)

    # Function to handle inviting a buddy
    def invite_buddy():
        # Prompt the user to enter the target IP
        invite_window = tk.Toplevel(root)
        invite_window.title("Invite a Buddy")
        invite_window.geometry("400x200")
        invite_window.configure(bg="#70a9c8")
        invite_window.grab_set()  # Make the window modal

        # Bind Enter key to send_button
        invite_window.bind('<Return>', lambda event: send_button.invoke())

        # IP Entry
        target_ip_label = tk.Label(invite_window, text="\U0001f3af Target IP Address:", font=("Helvetica", 10, "bold"),
                                   bg="#70a9c8")
        target_ip_label.pack(pady=10)
        target_ip_entry = tk.Entry(invite_window, width=30, font=("Helvetica", 10, "bold"), bd=2,
                                   relief='solid', highlightbackground="#269144")
        target_ip_entry.pack(pady=5)
        target_ip_entry.focus_set()

        # Button to Send Connection Request
        send_button = ttk.Button(invite_window, text="\U0001f4e8 Send Invite", style='Custom.TButton',
                                 command=lambda: send_request())
        send_button.pack(pady=20)

        def send_request():
            target_ip = target_ip_entry.get().strip()
            if not target_ip:
                custom_error_popup("Incomplete Information", "Please enter the target IP address.")
                return
            # Send the connection request to static port 5001
            invite_window.destroy()
            send_connection_request(target_ip, REQUEST_PORT)

    # Add a label to indicate listening for incoming requests
    listening_label = tk.Label(root, text="\U0001f576\ufe0f Chilling and waiting for buddies to join...",
                                font=("Helvetica", 10, "italic"), bg="#70a9c8")
    listening_label.pack(pady=5)

    # Add a Pause button to pause or resume syncing only after connection is established
    def toggle_pause():
        if pause_flag.is_set():
            pause_flag.clear()
            pause_button.config(text="\u23ef\ufe0f Resume Sync")
            log_activity("System", "Clipboard syncing is now on snooze mode.")
        else:
            pause_flag.set()
            pause_button.config(text="\u23f8\ufe0f Pause Sync")
            log_activity("System", "Clipboard syncing resumed. Back in action!")

    pause_button = ttk.Button(root, text="\u23f8\ufe0f Pause Sync", style='Custom.TButton', command=toggle_pause)
    pause_button.pack(pady=10)
    pause_button.pack_forget()  # Hide the pause button initially

    # Add a scrolled text widget for logs
    log_frame = tk.Frame(root, bg="#70a9c8")
    log_frame.pack(pady=10, fill=tk.BOTH, expand=True)

    log_label = tk.Label(log_frame, text="\U0001f4dd Connection Logs:", font=("Helvetica", 12, "bold"),
                         bg="#70a9c8")
    log_label.pack(anchor='w')

    log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, state='disabled', height=10,
                                        bg="#ffffff", fg="#000000", font=("Helvetica", 10, "bold"))
    log_text.pack(fill=tk.BOTH, expand=True)

    # Function to log activities with colors
    def log_activity(user, message):
        log_text.config(state='normal')
        if user in user_colors:
            color = user_colors[user]
        else:
            color = get_next_color()
            user_colors[user] = color
        log_text.tag_config(user, foreground=color, font=("Helvetica", 10, "bold"))
        log_entry = f"{user}: {message}\n"
        log_text.insert(tk.END, log_entry, user)
        log_text.config(state='disabled')
        log_text.yview(tk.END)

    # Add a Treeview to display connected users
    connected_users_label = tk.Label(root, text="\U0001f465 Connected Users:", font=("Helvetica", 12, "bold"),
                                     bg="#70a9c8")
    connected_users_label.pack(pady=5)

    connected_users_tree = ttk.Treeview(root, columns=("Username", "IP Address", "Port", "Copy Count"), show='headings')
    connected_users_tree.heading("Username", text="Username")
    connected_users_tree.heading("IP Address", text="IP Address")
    connected_users_tree.heading("Port", text="Port")
    connected_users_tree.heading("Copy Count", text="Copy Count")
    connected_users_tree.pack(pady=5, fill=tk.BOTH, expand=True)

    # Start threads for clipboard sync and connection handling are initiated after setting username and port

    def set_port():
        global PORT
        entered_port = port_entry.get().strip()
        if entered_port:
            try:
                port_num = int(entered_port)
                if port_num < 1 or port_num > 65535:
                    raise ValueError
                PORT = port_num
                # Check if port is available
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    try:
                        s.bind(('', PORT))
                    except socket.error:
                        custom_error_popup("Port Occupied", f"Port {PORT} is already in use. Please choose another one.")
                        PORT = None
                        return
            except ValueError:
                custom_error_popup("Invalid Port", "Please enter a valid port number between 1 and 65535.")
                return
        else:
            try:
                PORT = find_free_port()
                # Automatically set the port in the entry field without popup
                port_entry.insert(0, str(PORT))
            except Exception as e:
                custom_error_popup("Port Error", str(e))
                return
        # Update the IP label
        ip_label.config(text=f"\U0001f310 Your Secret Lair IP: {local_ip}:{PORT}")
        # Disable the port entry and button after setting
        port_entry.config(state='disabled')
        set_port_button.config(state='disabled')
        # Start threads after setting port
        start_threads()
        # Enable the Set Username button
        set_username_button.config(state='normal')

    def set_username():
        global username
        entered_username = username_entry.get().strip()
        if not entered_username:
            # Assign a random funny username if none provided
            username = get_random_funny_username()
            messagebox.showinfo("Username Assigned", f"No username entered. Assigned '{username}' for you!")
        else:
            username = entered_username
        if not PORT:
            custom_error_popup("Port Not Set", "Please set your communication port first.")
            return
        # Disable the username entry and button after setting
        username_entry.delete(0, tk.END)
        username_entry.config(state='disabled')
        set_username_button.config(state='disabled')
        # Display the username at the top of the dashboard
        user_label.config(text=f"\U0001f9d1\u200d\U0001f3a4 Your Cool Alias: {username}")
        # Enable the Invite button
        invite_button.config(state='normal')
        # If there are existing connections, send username updates
        for ip, info in TARGET_USERS.items():
            send_username_update(ip, info['port'])

    def on_close():
        if messagebox.askokcancel("Exit", "Are you sure you want to exit?"):
            sys.exit()

    root.protocol("WM_DELETE_WINDOW", on_close)

    def check_ready():
        """Enable the Invite button if Username and Port are set."""
        if username and PORT:
            invite_button.config(state='normal')
            pause_button.pack(pady=10)  # Show the pause button once ready
        else:
            invite_button.config(state='disabled')
        root.after(1000, check_ready)

    # Start checking if Username and Port are set
    root.after(1000, check_ready)

    # Bind Enter key to Set Port and Set Username buttons
    root.bind('<Return>', lambda event: set_port() if port_entry.focus_get() else None)
    root.bind('<Return>', lambda event: set_username() if username_entry.focus_get() else None)

    root.mainloop()

if __name__ == "__main__":
    main()
    # Keep the threads running in the background even after closing the GUI
    while True:
        time.sleep(1)

2024-11-05 15:33:19,352 - ERROR - Error handling connection request: [WinError 10040] A message sent on a datagram socket was larger than the internal message buffer or some other network limit, or the buffer used to receive a datagram into was smaller than the datagram itself
